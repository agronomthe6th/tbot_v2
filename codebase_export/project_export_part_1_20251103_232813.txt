=== EXPORT PART 1/10 ===

================================================================================
File: tbot/config.py
================================================================================
# config.py
import os
from dataclasses import dataclass
from typing import List, Dict

@dataclass
class DatabaseConfig:
    """–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö"""
    url: str = os.getenv(
        "DATABASE_URL", 
        "postgresql://postgres:password@localhost:5432/trader_tracker"
    )
    pool_size: int = 20
    max_overflow: int = 30
    echo: bool = False

@dataclass
class TinkoffConfig:
    """–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è Tinkoff API"""
    token: str = os.getenv("TINKOFF_TOKEN", "")
    sandbox: bool = os.getenv("TINKOFF_SANDBOX", "false").lower() == "true"
    cache_ttl_seconds: int = 60

@dataclass
class TelegramConfig:
    """–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è Telegram"""
    api_id: int = int(os.getenv("tg_api_id", "0"))
    api_hash: str = os.getenv("tg_api_hash", "")
    session_name: str = os.getenv("TELEGRAM_SESSION", "trader_session")

@dataclass
class TrackingConfig:
    """–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è —Å–∏–≥–Ω–∞–ª–æ–≤"""
    position_timeout_hours: int = 24  # –¢–∞–π–º–∞—É—Ç –ø–æ–∑–∏—Ü–∏–π
    processing_interval_seconds: int = 60  # –ò–Ω—Ç–µ—Ä–≤–∞–ª –æ–±—Ä–∞–±–æ—Ç–∫–∏
    max_signals_per_batch: int = 50
    lookback_days: int = 30  # –ü–µ—Ä–∏–æ–¥ –¥–ª—è –ø–æ–∏—Å–∫–∞ —Å–∏–≥–Ω–∞–ª–æ–≤

@dataclass 
class APIConfig:
    """–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è API"""
    host: str = "0.0.0.0"
    port: int = int(os.getenv("PORT", "8000"))
    reload: bool = os.getenv("DEBUG", "false").lower() == "true"
    cors_origins: List[str] = None

    def __post_init__(self):
        if self.cors_origins is None:
            origins_str = os.getenv("CORS_ORIGINS", "*")
            self.cors_origins = [origin.strip() for origin in origins_str.split(",")]

@dataclass
class Config:
    """–ì–ª–∞–≤–Ω–∞—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è"""
    database: DatabaseConfig
    tinkoff: TinkoffConfig
    telegram: TelegramConfig
    tracking: TrackingConfig
    api: APIConfig
    
    # –†–µ–∂–∏–º—ã —Ä–∞–±–æ—Ç—ã
    enable_telegram: bool = os.getenv("ENABLE_TELEGRAM", "true").lower() == "true"
    enable_tinkoff: bool = os.getenv("ENABLE_TINKOFF", "true").lower() == "true"
    enable_background_tasks: bool = os.getenv("ENABLE_BG_TASKS", "true").lower() == "true"
    
    # –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
    log_level: str = os.getenv("LOG_LEVEL", "INFO")
    log_file: str = os.getenv("LOG_FILE", "logs/trader_tracker.log")

# –ì–ª–æ–±–∞–ª—å–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
config = Config(
    database=DatabaseConfig(),
    tinkoff=TinkoffConfig(),
    telegram=TelegramConfig(),
    tracking=TrackingConfig(),
    api=APIConfig()
)

================================================================================
File: tbot/start_demo.py
================================================================================
# run.py - –ü—Ä–æ—Å—Ç–æ–π –∑–∞–ø—É—Å–∫ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ –ø—Ä–æ–µ–∫—Ç–∞
import os
import sys
import asyncio
import uvicorn
from pathlib import Path
from dotenv import load_dotenv

def main():
    """–ü—Ä–æ—Å—Ç–æ–π –∑–∞–ø—É—Å–∫ –ø—Ä–æ–µ–∫—Ç–∞ –∫–∞–∫ –µ—Å—Ç—å"""
    print("üöÄ Starting Trader Tracker...")
    
    # –ó–∞–≥—Ä—É–∂–∞–µ–º .env –µ—Å–ª–∏ –µ—Å—Ç—å
    env_file = Path(".env")
    if env_file.exists():
        load_dotenv()
        print("‚úÖ Loaded .env file")
    else:
        print("‚ö†Ô∏è  No .env file found, using defaults")
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –ë–î –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∞
    database_url = os.getenv("DATABASE_URL")
    if not database_url:
        print("‚ùå DATABASE_URL not configured")
        print("üí° Set DATABASE_URL environment variable or create .env file")
        return
    
    print(f"üìö Database: {database_url}")
    
    # –°–æ–∑–¥–∞–µ–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –¥–ª—è –ª–æ–≥–æ–≤ –µ—Å–ª–∏ –Ω–µ—Ç
    os.makedirs("logs", exist_ok=True)
    
    # –ó–∞–ø—É—Å–∫–∞–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–µ API –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ
    try:
        print("üåê Starting API server...")
        print("üìä Access API at: http://localhost:8000")
        print("üìã API docs at: http://localhost:8000/docs")
        print("üí° Press Ctrl+C to stop")
        
        # –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ
        from api.app import app
        
        # –ó–∞–ø—É—Å–∫–∞–µ–º uvicorn
        uvicorn.run(
            app,
            host="0.0.0.0", 
            port=8000,
            log_level="info",
            reload=False  # –û—Ç–∫–ª—é—á–∞–µ–º reload –¥–ª—è —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç–∏
        )
        
    except KeyboardInterrupt:
        print("\nüëã Server stopped by user")
    except Exception as e:
        print(f"‚ùå Failed to start server: {e}")
        print("üí° Check your configuration and database connection")

if __name__ == "__main__":
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏
    try:
        import fastapi
        import sqlalchemy
    except ImportError as e:
        print(f"‚ùå Missing dependency: {e}")
        print("üí° Install dependencies: pip install -r requirements.txt")
        sys.exit(1)
    
    main()

================================================================================
File: tbot/core/database/database.py
================================================================================
# core/database/database.py - –ü–ï–†–ï–ü–ò–°–ê–ù–ù–ê–Ø –í–ï–†–°–ò–Ø —Å —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–º–∏ –º–µ—Ç–æ–¥–∞–º–∏
"""
–ö–ª–∞—Å—Å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å PostgreSQL —Å —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–º–∏ –º–µ—Ç–æ–¥–∞–º–∏ –¥–ª—è –Ω–æ–≤–æ–≥–æ API
"""
import logging
from typing import Optional, List, Dict, Any, Tuple
from datetime import datetime, timedelta
from contextlib import contextmanager, asynccontextmanager
from utils.datetime_utils import now_utc, utc_from_days_ago, ensure_timezone_aware
from sqlalchemy import create_engine, func, and_, or_, desc, asc, text
from sqlalchemy.orm import sessionmaker, Session
from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession
from sqlalchemy.dialects.postgresql import insert
from sqlalchemy.exc import IntegrityError

from .models import *

logger = logging.getLogger(__name__)

class Database:
    """–ö–ª–∞—Å—Å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å PostgreSQL (sync + async) —Å —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–º–∏ –º–µ—Ç–æ–¥–∞–º–∏"""
    
    def __init__(self, database_url: str, pool_size: int = 10, echo: bool = False):
        """
        –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –ë–î
        
        Args:
            database_url: PostgreSQL URL –≤–∏–¥–∞ postgresql://user:pass@host:port/db
            pool_size: —Ä–∞–∑–º–µ—Ä –ø—É–ª–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π
            echo: –≤—ã–≤–æ–¥–∏—Ç—å SQL –∑–∞–ø—Ä–æ—Å—ã –≤ –ª–æ–≥
        """
        self.database_url = database_url
        
        # –°–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π engine
        self.engine = create_engine(
            database_url,
            pool_size=pool_size,
            max_overflow=pool_size * 2,
            pool_pre_ping=True,
            echo=echo
        )
        self.SessionLocal = sessionmaker(bind=self.engine)
        
        # –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π engine
        async_url = database_url.replace('postgresql://', 'postgresql+asyncpg://')
        self.async_engine = create_async_engine(
            async_url,
            pool_size=pool_size,
            max_overflow=pool_size * 2,
            echo=echo
        )
        self.AsyncSessionLocal = async_sessionmaker(bind=self.async_engine)
        
        logger.info(f"Database initialized: {self._mask_url(database_url)}")
    
    def _mask_url(self, url: str) -> str:
        """–ú–∞—Å–∫–∏—Ä–æ–≤–∫–∞ –ø–∞—Ä–æ–ª—è –≤ URL –¥–ª—è –ª–æ–≥–æ–≤"""
        if '@' in url and ':' in url:
            parts = url.split('@')
            if len(parts) == 2:
                user_pass = parts[0].split('://')[-1]
                if ':' in user_pass:
                    user = user_pass.split(':')[0]
                    return url.replace(user_pass, f"{user}:***")
        return url
    
    @contextmanager
    def session(self):
        """–ö–æ–Ω—Ç–µ–∫—Å—Ç–Ω—ã–π –º–µ–Ω–µ–¥–∂–µ—Ä –¥–ª—è —Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏–π"""
        session = self.SessionLocal()
        try:
            yield session
            session.commit()
        except Exception:
            session.rollback()
            raise
        finally:
            session.close()
    
    @asynccontextmanager
    async def async_session(self):
        """–ö–æ–Ω—Ç–µ–∫—Å—Ç–Ω—ã–π –º–µ–Ω–µ–¥–∂–µ—Ä –¥–ª—è –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏–π"""
        async with self.AsyncSessionLocal() as session:
            try:
                yield session
                await session.commit()
            except Exception:
                await session.rollback()
                raise
    
    def close(self):
        """–ó–∞–∫—Ä—ã—Ç—å –≤—Å–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è"""
        self.engine.dispose()
        logger.info("Database connections closed")

    # ===== –£–ù–ò–í–ï–†–°–ê–õ–¨–ù–´–ï –ú–ï–¢–û–î–´ –î–õ–Ø –°–ò–ì–ù–ê–õ–û–í =====
    
    def get_signals_universal(self, 
                             ticker: Optional[str] = None,
                             author: Optional[str] = None, 
                             trader_id: Optional[int] = None,
                             direction: Optional[str] = None,
                             status: Optional[str] = None,
                             from_date: Optional[datetime] = None,
                             to_date: Optional[datetime] = None,
                             limit: int = 50,
                             offset: int = 0,
                             order_by: str = "timestamp",
                             order_desc: bool = True) -> List[Dict]:
        """
        –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –º–µ—Ç–æ–¥ –ø–æ–ª—É—á–µ–Ω–∏—è —Å–∏–≥–Ω–∞–ª–æ–≤ —Å –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–º–∏ —Ñ–∏–ª—å—Ç—Ä–∞–º–∏
        
        Args:
            ticker: —Ñ–∏–ª—å—Ç—Ä –ø–æ —Ç–∏–∫–µ—Ä—É
            author: —Ñ–∏–ª—å—Ç—Ä –ø–æ –∞–≤—Ç–æ—Ä—É (–∏–º—è)
            trader_id: —Ñ–∏–ª—å—Ç—Ä –ø–æ ID —Ç—Ä–µ–π–¥–µ—Ä–∞
            direction: —Ñ–∏–ª—å—Ç—Ä –ø–æ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—é (long/short/exit)
            status: —Ñ–∏–ª—å—Ç—Ä –ø–æ —Å—Ç–∞—Ç—É—Å—É —Å–∏–≥–Ω–∞–ª–∞ (active/closed/all)
            from_date: —Å–∏–≥–Ω–∞–ª—ã –æ—Ç –¥–∞—Ç—ã
            to_date: —Å–∏–≥–Ω–∞–ª—ã –¥–æ –¥–∞—Ç—ã
            limit: –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ
            offset: —Å–º–µ—â–µ–Ω–∏–µ –¥–ª—è –ø–∞–≥–∏–Ω–∞—Ü–∏–∏
            order_by: –ø–æ–ª–µ –¥–ª—è —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏
            order_desc: –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏
            
        Returns:
            List[Dict]: —Å–ø–∏—Å–æ–∫ —Å–∏–≥–Ω–∞–ª–æ–≤
        """
        with self.session() as session:
            # –ë–∞–∑–æ–≤—ã–π –∑–∞–ø—Ä–æ—Å —Å JOIN –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Ç–∞—Ç—É—Å–∞ –∏–∑ results
            query = session.query(
                ParsedSignal,
                SignalResult.status.label('result_status')
            ).outerjoin(SignalResult, ParsedSignal.id == SignalResult.signal_id)
            
            # –ü—Ä–∏–º–µ–Ω—è–µ–º —Ñ–∏–ª—å—Ç—Ä—ã
            if ticker:
                query = query.filter(ParsedSignal.ticker.ilike(f"%{ticker.upper()}%"))
            
            if author:
                query = query.filter(ParsedSignal.author.ilike(f"%{author}%"))
            
            if trader_id:
                query = query.filter(ParsedSignal.trader_id == trader_id)
            
            if direction and direction.lower() != 'all':
                query = query.filter(ParsedSignal.direction == direction.lower())
            
            if status and status.lower() != 'all':
                if status.lower() == 'active':
                    query = query.filter(
                        or_(
                            SignalResult.status == 'active',
                            SignalResult.status.is_(None)  # –°–∏–≥–Ω–∞–ª—ã –±–µ–∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ —Ç–æ–∂–µ –∞–∫—Ç–∏–≤–Ω—ã
                        )
                    )
                else:
                    query = query.filter(SignalResult.status == status.lower())
            
            if from_date:
                query = query.filter(ParsedSignal.timestamp >= from_date)
            
            if to_date:
                query = query.filter(ParsedSignal.timestamp <= to_date)
            
            # –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞
            order_field = getattr(ParsedSignal, order_by, ParsedSignal.timestamp)
            if order_desc:
                query = query.order_by(desc(order_field))
            else:
                query = query.order_by(asc(order_field))
            
            # –ü–∞–≥–∏–Ω–∞—Ü–∏—è
            if offset > 0:
                query = query.offset(offset)
            
            if limit > 0:
                query = query.limit(limit)
            
            results = query.all()
            
            # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
            signals = []
            for signal, result_status in results:
                signal_dict = {
                    'id': str(signal.id),
                    'timestamp': signal.timestamp.isoformat() if signal.timestamp else None,
                    'ticker': signal.ticker,
                    'direction': signal.direction,
                    'signal_type': signal.signal_type,
                    'target_price': float(signal.target_price) if signal.target_price else None,
                    'stop_loss': float(signal.stop_loss) if signal.stop_loss else None,
                    'take_profit': float(signal.take_profit) if signal.take_profit else None,
                    'author': signal.author,
                    'trader_id': signal.trader_id,
                    'confidence_score': float(signal.confidence_score) if signal.confidence_score else None,
                    'original_text': signal.original_text[:200] + "..." if signal.original_text and len(signal.original_text) > 200 else signal.original_text,
                    'parser_version': signal.parser_version,
                    'channel_id': signal.channel_id,
                    'status': result_status or 'unknown'
                }
                signals.append(signal_dict)
            
            logger.info(f"Retrieved {len(signals)} signals with filters: ticker={ticker}, author={author}, direction={direction}")
            return signals
    
    def get_signals_stats(self,
                         ticker: Optional[str] = None,
                         author: Optional[str] = None,
                         trader_id: Optional[int] = None, 
                         direction: Optional[str] = None,
                         status: Optional[str] = None,
                         from_date: Optional[datetime] = None) -> Dict[str, Any]:
        """
        –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ —Å–∏–≥–Ω–∞–ª–∞–º —Å —Ç–µ–º–∏ –∂–µ —Ñ–∏–ª—å—Ç—Ä–∞–º–∏
        
        Returns:
            Dict: —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ —Å–∏–≥–Ω–∞–ª–∞–º
        """
        with self.session() as session:
            # –ë–∞–∑–æ–≤—ã–π –∑–∞–ø—Ä–æ—Å
            query = session.query(ParsedSignal).outerjoin(SignalResult)
            
            # –ü—Ä–∏–º–µ–Ω—è–µ–º —Ç–µ –∂–µ —Ñ–∏–ª—å—Ç—Ä—ã
            if ticker:
                query = query.filter(ParsedSignal.ticker.ilike(f"%{ticker.upper()}%"))
            
            if author:
                query = query.filter(ParsedSignal.author.ilike(f"%{author}%"))
            
            if trader_id:
                query = query.filter(ParsedSignal.trader_id == trader_id)
            
            if direction and direction.lower() != 'all':
                query = query.filter(ParsedSignal.direction == direction.lower())
            
            if from_date:
                query = query.filter(ParsedSignal.timestamp >= from_date)
            
            # –û—Å–Ω–æ–≤–Ω–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
            total_signals = query.count()
            
            # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è–º
            direction_stats = session.query(
                ParsedSignal.direction,
                func.count(ParsedSignal.id).label('count')
            )
            
            # –ü—Ä–∏–º–µ–Ω—è–µ–º —Ñ–∏–ª—å—Ç—Ä—ã –∏ –∫ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–π
            if ticker:
                direction_stats = direction_stats.filter(ParsedSignal.ticker.ilike(f"%{ticker.upper()}%"))
            if author:
                direction_stats = direction_stats.filter(ParsedSignal.author.ilike(f"%{author}%"))
            if trader_id:
                direction_stats = direction_stats.filter(ParsedSignal.trader_id == trader_id)
            if from_date:
                direction_stats = direction_stats.filter(ParsedSignal.timestamp >= from_date)
            
            direction_stats = direction_stats.group_by(ParsedSignal.direction).all()
            
            # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ —Å—Ç–∞—Ç—É—Å–∞–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
            status_query = query.join(SignalResult, isouter=True)
            status_stats = session.query(
                func.coalesce(SignalResult.status, 'no_result').label('status'),
                func.count(ParsedSignal.id).label('count')
            ).select_from(
                ParsedSignal
            ).outerjoin(SignalResult).group_by(
                func.coalesce(SignalResult.status, 'no_result')
            )
            
            # –ü—Ä–∏–º–µ–Ω—è–µ–º —Ñ–∏–ª—å—Ç—Ä—ã –∫ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–µ —Å—Ç–∞—Ç—É—Å–æ–≤
            if ticker:
                status_stats = status_stats.filter(ParsedSignal.ticker.ilike(f"%{ticker.upper()}%"))
            if author:
                status_stats = status_stats.filter(ParsedSignal.author.ilike(f"%{author}%"))
            if trader_id:
                status_stats = status_stats.filter(ParsedSignal.trader_id == trader_id)
            if from_date:
                status_stats = status_stats.filter(ParsedSignal.timestamp >= from_date)
            
            status_stats = status_stats.all()
            
            # –¢–æ–ø —Ç–∏–∫–µ—Ä—ã (–µ—Å–ª–∏ –Ω–µ —Ñ–∏–ª—å—Ç—Ä—É–µ–º –ø–æ —Ç–∏–∫–µ—Ä—É)
            top_tickers = []
            if not ticker:
                ticker_stats = session.query(
                    ParsedSignal.ticker,
                    func.count(ParsedSignal.id).label('count')
                )
                
                if author:
                    ticker_stats = ticker_stats.filter(ParsedSignal.author.ilike(f"%{author}%"))
                if trader_id:
                    ticker_stats = ticker_stats.filter(ParsedSignal.trader_id == trader_id)
                if from_date:
                    ticker_stats = ticker_stats.filter(ParsedSignal.timestamp >= from_date)
                
                top_tickers = ticker_stats.group_by(
                    ParsedSignal.ticker
                ).order_by(
                    desc(func.count(ParsedSignal.id))
                ).limit(10).all()
            
            # –¢–æ–ø –∞–≤—Ç–æ—Ä—ã (–µ—Å–ª–∏ –Ω–µ —Ñ–∏–ª—å—Ç—Ä—É–µ–º –ø–æ –∞–≤—Ç–æ—Ä—É)
            top_authors = []
            if not author:
                author_stats = session.query(
                    ParsedSignal.author,
                    func.count(ParsedSignal.id).label('count')
                )
                
                if ticker:
                    author_stats = author_stats.filter(ParsedSignal.ticker.ilike(f"%{ticker.upper()}%"))
                if trader_id:
                    author_stats = author_stats.filter(ParsedSignal.trader_id == trader_id)
                if from_date:
                    author_stats = author_stats.filter(ParsedSignal.timestamp >= from_date)
                
                top_authors = author_stats.filter(
                    ParsedSignal.author.isnot(None)
                ).group_by(
                    ParsedSignal.author
                ).order_by(
                    desc(func.count(ParsedSignal.id))
                ).limit(10).all()
            
            return {
                'total_signals': total_signals,
                'by_direction': {direction: count for direction, count in direction_stats},
                'by_status': {status: count for status, count in status_stats},
                'top_tickers': [{'ticker': ticker, 'count': count} for ticker, count in top_tickers],
                'top_authors': [{'author': author, 'count': count} for author, count in top_authors],
                'filters_applied': {
                    'ticker': ticker,
                    'author': author,
                    'trader_id': trader_id,
                    'direction': direction,
                    'from_date': from_date.isoformat() if from_date else None
                }
            }
    
    def get_signal_by_id(self, signal_id: str) -> Optional[Dict]:
        """
        –ü–æ–ª—É—á–µ–Ω–∏–µ –¥–µ—Ç–∞–ª—å–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Å–∏–≥–Ω–∞–ª–µ –ø–æ ID
        
        Args:
            signal_id: UUID —Å–∏–≥–Ω–∞–ª–∞
            
        Returns:
            Dict: –¥–µ—Ç–∞–ª—å–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Å–∏–≥–Ω–∞–ª–µ –∏–ª–∏ None
        """
        with self.session() as session:
            signal = session.query(ParsedSignal).filter(
                ParsedSignal.id == signal_id
            ).first()
            
            if not signal:
                return None
            
            # –ü–æ–ª—É—á–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –µ—Å–ª–∏ –µ—Å—Ç—å
            result = session.query(SignalResult).filter(
                SignalResult.signal_id == signal_id
            ).first()
            
            # –ü–æ–ª—É—á–∞–µ–º —Å—ã—Ä–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –µ—Å–ª–∏ –µ—Å—Ç—å
            raw_message = None
            if signal.raw_message_id:
                raw_message = session.query(RawMessage).filter(
                    RawMessage.id == signal.raw_message_id
                ).first()
            
            # –ü–æ–ª—É—á–∞–µ–º —Ç—Ä–µ–π–¥–µ—Ä–∞ –µ—Å–ª–∏ –µ—Å—Ç—å
            trader = None
            if signal.trader_id:
                trader = session.query(Trader).filter(
                    Trader.id == signal.trader_id
                ).first()
            
            signal_dict = {
                'id': str(signal.id),
                'timestamp': signal.timestamp.isoformat() if signal.timestamp else None,
                'created_at': signal.created_at.isoformat() if signal.created_at else None,
                'parser_version': signal.parser_version,
                'confidence_score': float(signal.confidence_score) if signal.confidence_score else None,
                'channel_id': signal.channel_id,
                'trader_id': signal.trader_id,
                'author': signal.author,
                'original_text': signal.original_text,
                'ticker': signal.ticker,
                'figi': signal.figi,
                'direction': signal.direction,
                'signal_type': signal.signal_type,
                'target_price': float(signal.target_price) if signal.target_price else None,
                'stop_loss': float(signal.stop_loss) if signal.stop_loss else None,
                'take_profit': float(signal.take_profit) if signal.take_profit else None,
                'entry_condition': signal.entry_condition,
                'confidence_level': signal.confidence_level,
                'timeframe': signal.timeframe,
                'views': signal.views,
                'extracted_data': signal.extracted_data
            }
            
            # –î–æ–±–∞–≤–ª—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –µ—Å–ª–∏ –µ—Å—Ç—å
            if result:
                signal_dict['result'] = {
                    'id': str(result.id),
                    'planned_entry_price': float(result.planned_entry_price) if result.planned_entry_price else None,
                    'actual_entry_price': float(result.actual_entry_price) if result.actual_entry_price else None,
                    'exit_price': float(result.exit_price) if result.exit_price else None,
                    'profit_loss_pct': float(result.profit_loss_pct) if result.profit_loss_pct else None,
                    'profit_loss_abs': float(result.profit_loss_abs) if result.profit_loss_abs else None,
                    'entry_time': result.entry_time.isoformat() if result.entry_time else None,
                    'exit_time': result.exit_time.isoformat() if result.exit_time else None,
                    'duration_minutes': result.duration_minutes,
                    'status': result.status,
                    'exit_reason': result.exit_reason,
                    'tracking_started_at': result.tracking_started_at.isoformat() if result.tracking_started_at else None,
                    'last_updated_at': result.last_updated_at.isoformat() if result.last_updated_at else None
                }
            
            # –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ç—Ä–µ–π–¥–µ—Ä–µ
            if trader:
                signal_dict['trader'] = {
                    'id': trader.id,
                    'name': trader.name,
                    'telegram_username': trader.telegram_username,
                    'is_active': trader.is_active
                }
            
            # –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Å—ã—Ä–æ–º —Å–æ–æ–±—â–µ–Ω–∏–∏
            if raw_message:
                signal_dict['raw_message'] = {
                    'id': raw_message.id,
                    'channel_id': raw_message.channel_id,
                    'message_id': raw_message.message_id,
                    'timestamp': raw_message.timestamp.isoformat() if raw_message.timestamp else None,
                    'author': raw_message.author
                }
            
            return signal_dict

    # ===== –ú–ï–¢–û–î–´ –î–õ–Ø –¢–†–ï–ô–î–ï–†–û–í =====
    
    def get_traders(self, include_stats: bool = False, active_only: bool = True) -> List[Dict]:
        """
        –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ —Ç—Ä–µ–π–¥–µ—Ä–æ–≤ —Å –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–π —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–æ–π
        
        Args:
            include_stats: –≤–∫–ª—é—á–∏—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ –∫–∞–∂–¥–æ–º—É —Ç—Ä–µ–π–¥–µ—Ä—É
            active_only: —Ç–æ–ª—å–∫–æ –∞–∫—Ç–∏–≤–Ω—ã–µ —Ç—Ä–µ–π–¥–µ—Ä—ã
            
        Returns:
            List[Dict]: —Å–ø–∏—Å–æ–∫ —Ç—Ä–µ–π–¥–µ—Ä–æ–≤
        """
        with self.session() as session:
            query = session.query(Trader)
            
            if active_only:
                query = query.filter(Trader.is_active == True)
            
            traders = query.order_by(asc(Trader.name)).all()
            
            result = []
            for trader in traders:
                trader_dict = {
                    'id': trader.id,
                    'name': trader.name,
                    'telegram_username': trader.telegram_username,
                    'channel_id': trader.channel_id,
                    'is_active': trader.is_active,
                    'first_signal_at': trader.first_signal_at.isoformat() if trader.first_signal_at else None,
                    'last_signal_at': trader.last_signal_at.isoformat() if trader.last_signal_at else None,
                    'total_signals': trader.total_signals,
                    'win_rate': float(trader.win_rate) if trader.win_rate else None,
                    'avg_profit_pct': float(trader.avg_profit_pct) if trader.avg_profit_pct else None,
                    'created_at': trader.created_at.isoformat() if trader.created_at else None
                }
                
                # –î–æ–±–∞–≤–ª—è–µ–º —Å–≤–µ–∂—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –µ—Å–ª–∏ –∑–∞–ø—Ä–æ—à–µ–Ω–∞
                if include_stats:
                    stats = self._calculate_trader_stats(session, trader.id)
                    trader_dict['live_stats'] = stats
                
                result.append(trader_dict)
            
            return result
    
    def get_trader_by_id(self, trader_id: int) -> Optional[Dict]:
        """
        –ü–æ–ª—É—á–µ–Ω–∏–µ –¥–µ—Ç–∞–ª—å–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Ç—Ä–µ–π–¥–µ—Ä–µ
        
        Args:
            trader_id: ID —Ç—Ä–µ–π–¥–µ—Ä–∞
            
        Returns:
            Dict: –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Ç—Ä–µ–π–¥–µ—Ä–µ –∏–ª–∏ None
        """
        with self.session() as session:
            trader = session.query(Trader).filter(Trader.id == trader_id).first()
            
            if not trader:
                return None
            
            # –ü–æ–ª—É—á–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
            stats = self._calculate_trader_stats(session, trader_id)
            
            return {
                'id': trader.id,
                'name': trader.name,
                'telegram_username': trader.telegram_username,
                'channel_id': trader.channel_id,
                'is_active': trader.is_active,
                'first_signal_at': trader.first_signal_at.isoformat() if trader.first_signal_at else None,
                'last_signal_at': trader.last_signal_at.isoformat() if trader.last_signal_at else None,
                'total_signals': trader.total_signals,
                'win_rate': float(trader.win_rate) if trader.win_rate else None,
                'avg_profit_pct': float(trader.avg_profit_pct) if trader.avg_profit_pct else None,
                'max_drawdown_pct': float(trader.max_drawdown_pct) if trader.max_drawdown_pct else None,
                'sharpe_ratio': float(trader.sharpe_ratio) if trader.sharpe_ratio else None,
                'created_at': trader.created_at.isoformat() if trader.created_at else None,
                'updated_at': trader.updated_at.isoformat() if trader.updated_at else None,
                'live_stats': stats
            }
    
    def get_trader_stats(self, trader_id: int, from_date: Optional[datetime] = None) -> Optional[Dict]:
        """
        –ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ —Ç—Ä–µ–π–¥–µ—Ä–∞ –∑–∞ –ø–µ—Ä–∏–æ–¥
        
        Args:
            trader_id: ID —Ç—Ä–µ–π–¥–µ—Ä–∞
            from_date: –Ω–∞—á–∞–ª—å–Ω–∞—è –¥–∞—Ç–∞ –¥–ª—è —Ä–∞—Å—á–µ—Ç–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
            
        Returns:
            Dict: —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Ç—Ä–µ–π–¥–µ—Ä–∞ –∏–ª–∏ None
        """
        with self.session() as session:
            trader = session.query(Trader).filter(Trader.id == trader_id).first()
            
            if not trader:
                return None
            
            stats = self._calculate_trader_stats(session, trader_id, from_date)
            
            return {
                'trader_id': trader.id,
                'trader_name': trader.name,
                'period_from': from_date.isoformat() if from_date else None,
                'period_to': datetime.utcnow().isoformat(),
                **stats
            }
    
    def _calculate_trader_stats(self, session: Session, trader_id: int, 
                            from_date: Optional[datetime] = None) -> Dict:
        # –î–û–ë–ê–í–¨ –≠–¢–ò –õ–û–ì–ò
        signals_query = session.query(ParsedSignal).filter(ParsedSignal.trader_id == trader_id)
        
        if from_date:
            signals_query = signals_query.filter(ParsedSignal.timestamp >= from_date)
        
        total_signals = signals_query.count()
        
        logger.info(f"üîç _calculate_trader_stats: trader_id={trader_id}, from_date={from_date}, total_signals={total_signals}")
        
        # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º
        results_query = session.query(SignalResult).join(ParsedSignal).filter(
            ParsedSignal.trader_id == trader_id
        )
        
        if from_date:
            results_query = results_query.filter(ParsedSignal.timestamp >= from_date)
        
        total_results = results_query.count()
        closed_results = results_query.filter(SignalResult.status == 'closed').all()
        active_results = results_query.filter(SignalResult.status == 'active').count()
        
        # –†–∞—Å—á–µ—Ç –≤–∏–Ω—Ä–µ–π—Ç–∞ –∏ –ø—Ä–∏–±—ã–ª–∏
        profitable_trades = [r for r in closed_results if r.profit_loss_pct and r.profit_loss_pct > 0]
        win_count = len(profitable_trades)
        loss_count = len(closed_results) - win_count
        
        win_rate = (win_count / len(closed_results) * 100) if closed_results else 0
        
        avg_profit = sum(float(r.profit_loss_pct or 0) for r in closed_results) / len(closed_results) if closed_results else 0
        
        # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è–º
        direction_stats = session.query(
            ParsedSignal.direction,
            func.count(ParsedSignal.id).label('count')
        ).filter(ParsedSignal.trader_id == trader_id)
        
        if from_date:
            direction_stats = direction_stats.filter(ParsedSignal.timestamp >= from_date)
        
        direction_stats = direction_stats.group_by(ParsedSignal.direction).all()
        
        # –¢–æ–ø —Ç–∏–∫–µ—Ä—ã —Ç—Ä–µ–π–¥–µ—Ä–∞
        top_tickers = session.query(
            ParsedSignal.ticker,
            func.count(ParsedSignal.id).label('count')
        ).filter(ParsedSignal.trader_id == trader_id)
        
        if from_date:
            top_tickers = top_tickers.filter(ParsedSignal.timestamp >= from_date)
        
        top_tickers = top_tickers.group_by(ParsedSignal.ticker).order_by(
            desc(func.count(ParsedSignal.id))
        ).limit(5).all()
        
        return {
            'total_signals': total_signals,
            'total_results': total_results,
            'active_results': active_results,
            'closed_results': len(closed_results),
            'win_count': win_count,
            'loss_count': loss_count,
            'win_rate': round(win_rate, 2),
            'avg_profit_pct': round(avg_profit, 2),
            'by_direction': {direction: count for direction, count in direction_stats},
            'top_tickers': [{'ticker': ticker, 'count': count} for ticker, count in top_tickers]
        }

    # ===== –ú–ï–¢–û–î–´ –î–õ–Ø –¢–ò–ö–ï–†–û–í =====
    
    def get_available_tickers(self, with_stats: bool = True, include_candles_stats: bool = False) -> List[Dict]:
        """
        –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Ç–∏–∫–µ—Ä–æ–≤ —Å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–æ–π
        
        Args:
            with_stats: –≤–∫–ª—é—á–∏—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ —Å–∏–≥–Ω–∞–ª–∞–º
            include_candles_stats: –≤–∫–ª—é—á–∏—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ —Å–≤–µ—á–∞–º (–º–µ–¥–ª–µ–Ω–Ω–∞—è –æ–ø–µ—Ä–∞—Ü–∏—è)
            
        Returns:
            List[Dict]: —Å–ø–∏—Å–æ–∫ —Ç–∏–∫–µ—Ä–æ–≤
        """
        with self.session() as session:
            if with_stats:
                # –ó–∞–ø—Ä–æ—Å —Å –∞–≥—Ä–µ–≥–∞—Ü–∏–µ–π —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∏–∑ —Å–∏–≥–Ω–∞–ª–æ–≤
                ticker_stats = session.query(
                    ParsedSignal.ticker,
                    func.count(ParsedSignal.id).label('signal_count'),
                    func.max(ParsedSignal.timestamp).label('last_signal'),
                    func.min(ParsedSignal.timestamp).label('first_signal'),
                    func.count(func.distinct(ParsedSignal.author)).label('unique_authors')
                ).group_by(
                    ParsedSignal.ticker
                ).order_by(
                    desc(func.count(ParsedSignal.id))
                ).all()
                
                result = []
                for ticker, count, last_signal, first_signal, unique_authors in ticker_stats:
                    ticker_data = {
                        'ticker': ticker,
                        'signal_count': count,
                        'last_signal': ensure_timezone_aware(last_signal).isoformat() if last_signal else None,
                        'first_signal': ensure_timezone_aware(first_signal).isoformat() if first_signal else None,
                        'unique_authors': unique_authors
                    }
                    
                    # –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–µ –∏ —Å–≤–µ—á–∞—Ö —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –∑–∞–ø—Ä–æ—à–µ–Ω–æ
                    if include_candles_stats:
                        instrument = session.query(Instrument).filter(
                            Instrument.ticker == ticker
                        ).first()
                        
                        if instrument:
                            ticker_data['name'] = instrument.name
                            ticker_data['figi'] = instrument.figi
                            
                            # –°—á–∏—Ç–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–≤–µ—á–µ–π
                            candles_count = session.query(Candle).filter(
                                Candle.instrument_id == instrument.figi
                            ).count()
                            
                            ticker_data['candles_count'] = candles_count
                            
                            # –ü–æ–ª—É—á–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω—é—é —Å–≤–µ—á—É
                            latest_candle_obj = session.query(Candle).filter(
                                Candle.instrument_id == instrument.figi
                            ).order_by(Candle.time.desc()).first()
                            
                            if latest_candle_obj:
                                ticker_data['latest_candle'] = ensure_timezone_aware(latest_candle_obj.time).isoformat()
                            else:
                                ticker_data['latest_candle'] = None
                        else:
                            ticker_data['name'] = ticker
                            ticker_data['figi'] = None
                            ticker_data['candles_count'] = 0
                            ticker_data['latest_candle'] = None
                    
                    result.append(ticker_data)
                
                return result
            else:
                # –ü—Ä–æ—Å—Ç–æ–π —Å–ø–∏—Å–æ–∫ —Ç–∏–∫–µ—Ä–æ–≤ –±–µ–∑ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
                tickers = session.query(ParsedSignal.ticker).distinct().all()
                return [{'ticker': t[0]} for t in tickers]

    # ===== –ú–ï–¢–û–î–´ –î–õ–Ø –°–û–û–ë–©–ï–ù–ò–ô =====
    
    def get_unparsed_messages(self, limit: int = 20) -> List[Dict]:
        """
        –ü–æ–ª—É—á–µ–Ω–∏–µ –Ω–µ—Ä–∞–∑–æ–±—Ä–∞–Ω–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π
        
        Args:
            limit: –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–æ–æ–±—â–µ–Ω–∏–π
            
        Returns:
            List[Dict]: —Å–ø–∏—Å–æ–∫ –Ω–µ—Ä–∞–∑–æ–±—Ä–∞–Ω–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π
        """
        with self.session() as session:
            messages = session.query(RawMessage).filter(
                RawMessage.is_processed == False
            ).order_by(
                desc(RawMessage.timestamp)
            ).limit(limit).all()
            
            return [
                {
                    'id': msg.id,
                    'channel_id': msg.channel_id,
                    'message_id': msg.message_id,
                    'timestamp': msg.timestamp.isoformat() if msg.timestamp else None,
                    'text': msg.text[:300] + "..." if len(msg.text) > 300 else msg.text,
                    'text_length': len(msg.text),
                    # 'author': msg.author_username, —Ç—É—Ç –Ω–µ—Ç—É –∞–≤—Ç–æ—Ä–∞ –ø–æ —Å–∫–æ–ª—å–∫—É –º—ã –µ–≥–æ –ø–∞—Ä—Å–∏–º —É–∂–µ –Ω–∞ —Å–ª–µ–¥—É—é—â–µ–º —à–∞–≥–µ
                    'collected_at': msg.collected_at.isoformat() if msg.collected_at else None
                }
                for msg in messages
            ]
    
    def get_unparsed_messages_count(self) -> int:
        """
        –ü–æ–ª—É—á–µ–Ω–∏–µ –æ–±—â–µ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –Ω–µ—Ä–∞–∑–æ–±—Ä–∞–Ω–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π
        
        Returns:
            int: –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –Ω–µ—Ä–∞–∑–æ–±—Ä–∞–Ω–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π
        """
        with self.session() as session:
            count = session.query(RawMessage).filter(
                RawMessage.is_processed == False
            ).count()
            
            return count

    def get_raw_messages_sample(self, limit: int = 10) -> List[Dict]:
        """
        –ü–æ–ª—É—á–µ–Ω–∏–µ –æ–±—Ä–∞–∑—Ü–∞ —Å—ã—Ä—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
        
        Args:
            limit: –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–æ–æ–±—â–µ–Ω–∏–π
            
        Returns:
            List[Dict]: –æ–±—Ä–∞–∑–µ—Ü —Å–æ–æ–±—â–µ–Ω–∏–π
        """
        with self.session() as session:
            messages = session.query(RawMessage).order_by(
                desc(RawMessage.timestamp)
            ).limit(limit).all()
            
            return [
                {
                    'id': msg.id,
                    'channel_id': msg.channel_id,
                    'message_id': msg.message_id,
                    'timestamp': msg.timestamp.isoformat() if msg.timestamp else None,
                    'text': msg.text[:200] + "..." if len(msg.text) > 200 else msg.text,
                    'author': msg.author_username,
                    'is_processed': msg.is_processed
                }
                for msg in messages
            ]

    # ===== –°–ò–°–¢–ï–ú–ù–´–ï –ú–ï–¢–û–î–´ =====
    
    def get_system_statistics(self) -> Dict[str, Any]:
        """
        –ü–æ–ª—É—á–∏—Ç—å –æ–±—â—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É —Å–∏—Å—Ç–µ–º—ã
        
        Returns:
            Dict: —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ –≤—Å–µ–º —Ç–∞–±–ª–∏—Ü–∞–º
        """
        with self.session() as session:
            # –û—Å–Ω–æ–≤–Ω–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
            total_messages = session.query(RawMessage).count()
            processed_messages = session.query(RawMessage).filter(RawMessage.is_processed == True).count()
            total_signals = session.query(ParsedSignal).count()
            total_traders = session.query(Trader).count()
            active_traders = session.query(Trader).filter(Trader.is_active == True).count()
            total_results = session.query(SignalResult).count()
            active_results = session.query(SignalResult).filter(SignalResult.status == 'active').count()
            
            # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 24 —á–∞—Å–∞
            last_24h = datetime.utcnow() - timedelta(hours=24)
            recent_signals = session.query(ParsedSignal).filter(
                ParsedSignal.timestamp >= last_24h
            ).count()
            recent_messages = session.query(RawMessage).filter(
                RawMessage.timestamp >= last_24h
            ).count()
            
            # –£–Ω–∏–∫–∞–ª—å–Ω—ã–µ —Ç–∏–∫–µ—Ä—ã
            unique_tickers = session.query(ParsedSignal.ticker).distinct().count()
            
            # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞–º –∏ —Å–≤–µ—á–∞–º
            total_instruments = session.query(Instrument).count()
            total_candles = session.query(Candle).count()
            
            return {
                'messages': {
                    'total': total_messages,
                    'processed': processed_messages,
                    'unprocessed': total_messages - processed_messages,
                    'last_24h': recent_messages
                },
                'signals': {
                    'total': total_signals,
                    'unique_tickers': unique_tickers,
                    'last_24h': recent_signals
                },
                'traders': {
                    'total': total_traders,
                    'active': active_traders,
                    'inactive': total_traders - active_traders
                },
                'results': {
                    'total': total_results,
                    'active': active_results,
                    'closed': total_results - active_results
                },
                'market_data': {
                    'instruments': total_instruments,
                    'candles': total_candles
                },
                'timestamp': datetime.utcnow().isoformat()
            }
    
    def get_debug_signals_info(self) -> Dict[str, Any]:
        """
        DEBUG: –î–µ—Ç–∞–ª—å–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Å–∏–≥–Ω–∞–ª–∞—Ö –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
        
        Returns:
            Dict: –æ—Ç–ª–∞–¥–æ—á–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è
        """
        with self.session() as session:
            # –û—Å–Ω–æ–≤–Ω–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
            total_signals = session.query(ParsedSignal).count()
            
            # –†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –ø–æ –≥–æ–¥–∞–º
            year_distribution = session.query(
                func.extract('year', ParsedSignal.timestamp).label('year'),
                func.count(ParsedSignal.id).label('count')
            ).group_by(
                func.extract('year', ParsedSignal.timestamp)
            ).order_by('year').all()
            
            # –¢–æ–ø –∞–≤—Ç–æ—Ä—ã
            top_authors = session.query(
                ParsedSignal.author,
                func.count(ParsedSignal.id).label('count')
            ).filter(
                ParsedSignal.author.isnot(None)
            ).group_by(
                ParsedSignal.author
            ).order_by(
                desc(func.count(ParsedSignal.id))
            ).limit(10).all()
            
            # –¢–æ–ø —Ç–∏–∫–µ—Ä—ã
            top_tickers = session.query(
                ParsedSignal.ticker,
                func.count(ParsedSignal.id).label('count')
            ).group_by(
                ParsedSignal.ticker
            ).order_by(
                desc(func.count(ParsedSignal.id))
            ).limit(10).all()
            
            # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è–º
            direction_stats = session.query(
                ParsedSignal.direction,
                func.count(ParsedSignal.id).label('count')
            ).group_by(
                ParsedSignal.direction
            ).all()
            
            # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ –ø–∞—Ä—Å–µ—Ä–∞–º
            parser_stats = session.query(
                ParsedSignal.parser_version,
                func.count(ParsedSignal.id).label('count')
            ).group_by(
                ParsedSignal.parser_version
            ).all()
            
            # –û–±—Ä–∞–∑—Ü—ã —Å–∏–≥–Ω–∞–ª–æ–≤
            sample_signals = session.query(ParsedSignal).order_by(
                desc(ParsedSignal.timestamp)
            ).limit(5).all()
            
            samples = []
            for signal in sample_signals:
                samples.append({
                    'id': str(signal.id),
                    'timestamp': signal.timestamp.isoformat() if signal.timestamp else None,
                    'ticker': signal.ticker,
                    'direction': signal.direction,
                    'author': signal.author,
                    'confidence_score': float(signal.confidence_score) if signal.confidence_score else None,
                    'original_text': signal.original_text[:100] + "..." if signal.original_text and len(signal.original_text) > 100 else signal.original_text
                })
            
            return {
                'total_signals': total_signals,
                'by_year': [{'year': int(year), 'count': count} for year, count in year_distribution],
                'top_authors': [{'author': author, 'count': count} for author, count in top_authors],
                'top_tickers': [{'ticker': ticker, 'count': count} for ticker, count in top_tickers],
                'by_direction': [{'direction': direction, 'count': count} for direction, count in direction_stats],
                'by_parser': [{'parser': parser, 'count': count} for parser, count in parser_stats],
                'sample_signals': samples,
                'timestamp': datetime.utcnow().isoformat()
            }
    
    def health_check(self) -> Dict[str, Any]:
        """
        –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–¥–æ—Ä–æ–≤—å—è –ë–î
        
        Returns:
            Dict: —Å—Ç–∞—Ç—É—Å –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∏ –æ—Å–Ω–æ–≤–Ω—ã–µ –º–µ—Ç—Ä–∏–∫–∏
        """
        try:
            with self.session() as session:
                # –ü—Ä–æ—Å—Ç–æ–π –∑–∞–ø—Ä–æ—Å –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
                session.execute(text("SELECT 1"))
                
                # –ë—ã—Å—Ç—Ä–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –æ—Å–Ω–æ–≤–Ω—ã—Ö —Ç–∞–±–ª–∏—Ü
                tables_status = {}
                try:
                    tables_status['raw_messages'] = session.query(RawMessage).count()
                except:
                    tables_status['raw_messages'] = 'error'
                
                try:
                    tables_status['parsed_signals'] = session.query(ParsedSignal).count()
                except:
                    tables_status['parsed_signals'] = 'error'
                
                try:
                    tables_status['traders'] = session.query(Trader).count()
                except:
                    tables_status['traders'] = 'error'
                
                return {
                    'status': 'healthy',
                    'database_url': self._mask_url(self.database_url),
                    'connection': 'ok',
                    'tables': tables_status,
                    'timestamp': datetime.utcnow().isoformat()
                }
                
        except Exception as e:
            return {
                'status': 'unhealthy',
                'error': str(e),
                'error_type': type(e).__name__,
                'timestamp': datetime.utcnow().isoformat()
            }

    # ===== LEGACY –ú–ï–¢–û–î–´ (–¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏) =====
    
    def save_message(self, channel_id: int, message_id: int, 
                    timestamp: datetime, text: str, author: str = None,
                    is_processed: bool = False) -> int:
        """–°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Å—ã—Ä–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏–∑ Telegram"""
        with self.session() as session:
            # –°–æ–∑–¥–∞–µ–º –æ–±—ä–µ–∫—Ç —Å –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏
            message = RawMessage(
                channel_id=channel_id,
                message_id=message_id,
                timestamp=timestamp,
                text=text,
                is_processed=is_processed
                # author_username –º–æ–∂–Ω–æ –Ω–µ —É–∫–∞–∑—ã–≤–∞—Ç—å - –æ–Ω nullable
            )
            
            try:
                session.add(message)
                session.flush()
                logger.debug(f"Message saved: {message.id}")
                return message.id
                
            except IntegrityError:
                session.rollback()
                # –î—É–±–ª–∏–∫–∞—Ç - –≤–æ–∑–≤—Ä–∞—â–∞–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π ID
                existing = session.query(RawMessage).filter(
                    RawMessage.channel_id == channel_id,
                    RawMessage.message_id == message_id
                ).first()
                
                if existing:
                    # –û–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ: –æ–±–Ω–æ–≤–ª—è–µ–º —Ç–µ–∫—Å—Ç –µ—Å–ª–∏ –∏–∑–º–µ–Ω–∏–ª—Å—è
                    if existing.text != text:
                        existing.text = text
                        existing.is_processed = False  # –ü–µ—Ä–µ—Ä–∞–∑–æ–±—Ä–∞—Ç—å
                        session.flush()
                    return existing.id
                
                raise

    def save_signal(self, signal_data: Dict) -> str:
        """–°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ç–æ—Ä–≥–æ–≤—ã–π —Å–∏–≥–Ω–∞–ª —Å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–º –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ–º trader_id"""
        with self.session() as session:
            trader_id = signal_data.get('trader_id')
            
            if not trader_id:
                author = signal_data.get('author')
                channel_id = signal_data.get('channel_id')
                
                if author:
                    trader = session.query(Trader).filter(
                        Trader.name == author,
                        Trader.is_active == True
                    ).first()
                    
                    if trader:
                        trader_id = trader.id
                        logger.debug(f"Auto-assigned trader_id={trader_id} by author={author}")
                
                if not trader_id and channel_id:
                    trader = session.query(Trader).filter(
                        Trader.channel_id == channel_id,
                        Trader.is_active == True
                    ).first()
                    
                    if trader:
                        trader_id = trader.id
                        logger.debug(f"Auto-assigned trader_id={trader_id} by channel_id={channel_id}")
            
            signal = ParsedSignal(
                raw_message_id=signal_data.get('raw_message_id'),
                timestamp=signal_data['timestamp'],
                parser_version=signal_data.get('parser_version', '1.0'),
                confidence_score=signal_data.get('confidence_score'),
                channel_id=signal_data['channel_id'],
                trader_id=trader_id,
                author=signal_data.get('author'),
                original_text=signal_data['original_text'],
                ticker=signal_data['ticker'],
                figi=signal_data.get('figi'),
                direction=signal_data.get('direction'),
                signal_type=signal_data.get('signal_type'),
                target_price=signal_data.get('target_price'),
                stop_loss=signal_data.get('stop_loss'),
                take_profit=signal_data.get('take_profit'),
                entry_condition=signal_data.get('entry_condition'),
                confidence_level=signal_data.get('confidence_level'),
                timeframe=signal_data.get('timeframe'),
                extracted_data=signal_data.get('extracted_data')
            )
            
            session.add(signal)
            session.flush()
            
            logger.debug(f"Signal saved: {signal.id}, trader_id={trader_id}, author={signal_data.get('author')}")
            return str(signal.id)

    def get_signals(self, ticker: str = None, trader_id: int = None,
                   channel_id: int = None, direction: str = None,
                   from_date: datetime = None, limit: int = 100) -> List[Dict]:
        """–ü–æ–ª—É—á–∏—Ç—å —Å–∏–≥–Ω–∞–ª—ã —Å —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–µ–π (legacy –º–µ—Ç–æ–¥, –ø–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–ª—è–µ—Ç –Ω–∞ –Ω–æ–≤—ã–π)"""
        return self.get_signals_universal(
            ticker=ticker,
            trader_id=trader_id,
            direction=direction,
            from_date=from_date,
            limit=limit
        )
    
    def get_messages(self, channel_id: int = None, is_processed: bool = None,
                    from_date: datetime = None, limit: int = 1000) -> List[Dict]:
        """–ü–æ–ª—É—á–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏—è —Å —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–µ–π (legacy –º–µ—Ç–æ–¥)"""
        with self.session() as session:
            query = session.query(RawMessage)
            
            if channel_id is not None:
                query = query.filter(RawMessage.channel_id == channel_id)
            
            if is_processed is not None:
                query = query.filter(RawMessage.is_processed == is_processed)
                
            if from_date:
                query = query.filter(RawMessage.timestamp >= from_date)
            
            messages = query.order_by(desc(RawMessage.timestamp)).limit(limit).all()
            
            return [
                {
                    'id': msg.id,
                    'channel_id': msg.channel_id,
                    'message_id': msg.message_id,
                    'timestamp': msg.timestamp,
                    'text': msg.text,
                    'author': msg.author_username,
                    'is_processed': msg.is_processed
                }
                for msg in messages
            ]
    
    def mark_message_processed(self, message_id: int):
        """–û—Ç–º–µ—Ç–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –∫–∞–∫ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω–æ–µ (legacy –º–µ—Ç–æ–¥)"""
        with self.session() as session:
            session.query(RawMessage).filter(RawMessage.id == message_id).update(
                {'is_processed': True}
            )
    
    def get_trader_id_by_channel(self, channel_id: int) -> Optional[int]:
        with self.session() as session:
            trader = session.query(Trader).filter(
                Trader.channel_id == channel_id,
                Trader.is_active == True
            ).first()
            
            return trader.id if trader else None

    def get_all_traders(self, active_only: bool = True) -> List[Dict]:
        """–ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö —Ç—Ä–µ–π–¥–µ—Ä–æ–≤ (legacy –º–µ—Ç–æ–¥, –ø–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–ª—è–µ—Ç –Ω–∞ –Ω–æ–≤—ã–π)"""
        return self.get_traders(include_stats=False, active_only=active_only)

    def get_statistics(self) -> Dict[str, Any]:
        """–ü–æ–ª—É—á–∏—Ç—å –æ–±—â—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É —Å–∏—Å—Ç–µ–º—ã (legacy –º–µ—Ç–æ–¥, –ø–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–ª—è–µ—Ç –Ω–∞ –Ω–æ–≤—ã–π)"""
        return self.get_system_statistics()

    # ===== –ú–ï–¢–û–î–´ –î–õ–Ø –†–ê–ë–û–¢–´ –°–û –°–í–ï–ß–ê–ú–ò (–∏–∑ –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–≥–æ —Ñ–∞–π–ª–∞) =====
    
    def save_candles(self, candles_data, figi: str = None, interval: str = None) -> Dict:
        """–ú–∞—Å—Å–æ–≤–æ–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Å–≤–µ—á–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö —Å –±–∞—Ç—á–∏–Ω–≥–æ–º –¥–ª—è PostgreSQL"""
        if not candles_data:
            logger.warning("save_candles called with empty data")
            return {'saved': 0, 'errors': 0}
        
        logger.info(f"Attempting to save {len(candles_data)} candles...")
        
        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ñ–æ—Ä–º–∞—Ç –¥–∞–Ω–Ω—ã—Ö
        first_item = candles_data[0]
        is_dict_format = isinstance(first_item, dict)
        
        logger.info(f"Data format: {'dict' if is_dict_format else 'tuple'}")
        
        if is_dict_format and (not figi or not interval):
            logger.error("Dict format requires figi and interval parameters")
            return {'saved': 0, 'errors': len(candles_data)}
        
        with self.session() as session:
            try:
                candles_dicts = []
                errors = 0
                seen_times = set()  # –û—Ç—Å–ª–µ–∂–∏–≤–∞–µ–º –¥—É–±–ª–∏–∫–∞—Ç—ã –ø–æ –≤—Ä–µ–º–µ–Ω–∏
                
                # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –¥–∞–Ω–Ω—ã–µ –≤ –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç
                for i, candle in enumerate(candles_data):
                    try:
                        if is_dict_format:
                            # –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ñ–æ—Ä–º–∞—Ç–∞ —Å–ª–æ–≤–∞—Ä–µ–π (–æ—Ç Tinkoff API)
                            candle_time = candle['time']
                            
                            # –ü–†–û–í–ï–†–Ø–ï–ú –î–£–ë–õ–ò–ö–ê–¢–´ –ü–û –í–†–ï–ú–ï–ù–ò
                            time_key = (figi, interval, candle_time)
                            if time_key in seen_times:
                                logger.warning(f"Skipping duplicate candle at {candle_time}")
                                continue
                            seen_times.add(time_key)
                            
                            candle_dict = {
                                'instrument_id': figi,
                                'interval': interval,
                                'time': candle_time,
                                'open': float(candle['open']),
                                'high': float(candle['high']),
                                'low': float(candle['low']),
                                'close': float(candle['close']),
                                'volume': int(candle.get('volume', 0))
                            }
                        else:
                            # –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ñ–æ—Ä–º–∞—Ç–∞ –∫–æ—Ä—Ç–µ–∂–µ–π (—Å—Ç–∞—Ä—ã–π —Ñ–æ—Ä–º–∞—Ç)
                            if len(candle) < 7:
                                logger.error(f"Invalid tuple length at index {i}: {len(candle)}")
                                errors += 1
                                continue
                            
                            # –ü–†–û–í–ï–†–Ø–ï–ú –î–£–ë–õ–ò–ö–ê–¢–´ –ü–û –í–†–ï–ú–ï–ù–ò
                            time_key = (candle[0], candle[1], candle[2])
                            if time_key in seen_times:
                                logger.warning(f"Skipping duplicate candle at {candle[2]}")
                                continue
                            seen_times.add(time_key)
                            
                            candle_dict = {
                                'instrument_id': candle[0],
                                'interval': candle[1],
                                'time': candle[2],
                                'open': float(candle[3]),
                                'high': float(candle[4]),
                                'low': float(candle[5]),
                                'close': float(candle[6]),
                                'volume': int(candle[7]) if len(candle) > 7 else 0
                            }
                        
                        candles_dicts.append(candle_dict)
                        
                    except (ValueError, IndexError, TypeError, KeyError) as e:
                        logger.error(f"Error processing candle at index {i}: {e}")
                        errors += 1
                        continue
                
                if not candles_dicts:
                    logger.error("No valid candles to save after processing")
                    return {'saved': 0, 'errors': len(candles_data)}
                
                logger.info(f"Processed {len(candles_dicts)} valid candles, {errors} errors")
                
                # –ë–ê–¢–ß–ò–ù–ì
                BATCH_SIZE = 500  # –£–º–µ–Ω—å—à–µ–Ω–æ –¥–ª—è —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç–∏
                total_saved = 0
                
                # –†–∞–∑–±–∏–≤–∞–µ–º –¥–∞–Ω–Ω—ã–µ –Ω–∞ –±–∞—Ç—á–∏
                for i in range(0, len(candles_dicts), BATCH_SIZE):
                    batch = candles_dicts[i:i + BATCH_SIZE]
                    logger.info(f"Processing batch {i//BATCH_SIZE + 1}: {len(batch)} records")
                    
                    try:
                        # –°–æ–∑–¥–∞–µ–º –∑–∞–ø—Ä–æ—Å –¥–ª—è –±–∞—Ç—á–∞
                        stmt = insert(Candle).values(batch)
                        
                        # ON CONFLICT –¥–ª—è –∏–∑–±–µ–∂–∞–Ω–∏—è –¥—É–±–ª–∏–∫–∞—Ç–æ–≤
                        stmt = stmt.on_conflict_do_update(
                            index_elements=['instrument_id', 'interval', 'time'],
                            set_={
                                'open': stmt.excluded.open,
                                'high': stmt.excluded.high,
                                'low': stmt.excluded.low,
                                'close': stmt.excluded.close,
                                'volume': stmt.excluded.volume
                            }
                        )
                        

=== –ö–û–î –û–ë–†–´–í–ê–ï–¢–°–Ø. –ü–†–û–î–û–õ–ñ–ï–ù–ò–ï –í –°–õ–ï–î–£–Æ–©–ï–ú –§–ê–ô–õ–ï ===

