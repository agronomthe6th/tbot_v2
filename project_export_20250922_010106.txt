Project Export Generated at 2025-09-22 01:01:06

=== Project Structure ===
.
‚îú‚îÄ‚îÄ frontend
‚îÇ   ‚îú‚îÄ‚îÄ src
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ frontend/src/App.vue
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ frontend/src/components/AppNavigation.vue
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ frontend/src/components/DataManagement.vue
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ frontend/src/components/SignalCard.vue
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ charts
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ frontend/src/components/charts/ChartControls.vue
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ frontend/src/components/charts/TradingChart.vue
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ signals
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ widgets
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ frontend/src/main.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ router
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ frontend/src/router/index.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ services
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ frontend/src/services/api.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ stores
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ frontend/src/stores/tradingStore.js
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ views
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ frontend/src/views/SignalsChart.vue
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ frontend/src/views/TraderProfile.vue
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ frontend/src/views/TradingDashboard.vue
‚îÇ   ‚îú‚îÄ‚îÄ frontend/tailwind.config.js
‚îÇ   ‚îî‚îÄ‚îÄ frontend/vite.config.js
‚îú‚îÄ‚îÄ tbot
‚îÇ   ‚îú‚îÄ‚îÄ analysis
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ tbot/analysis/message_parser.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ tbot/analysis/signal_matcher.py
‚îÇ   ‚îú‚îÄ‚îÄ api
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ tbot/api/app.py
‚îÇ   ‚îú‚îÄ‚îÄ tbot/config.py
‚îÇ   ‚îú‚îÄ‚îÄ core
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ database
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ tbot/core/database/database.py
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ tbot/core/database/migrations.py
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ tbot/core/database/models.py
‚îÇ   ‚îú‚îÄ‚îÄ integrations
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ tbot/integrations/historical_data_loader.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ tbot/integrations/tinkoff_integration.py
‚îÇ   ‚îú‚îÄ‚îÄ tbot/start_demo.py
‚îÇ   ‚îî‚îÄ‚îÄ utils
‚îÇ       ‚îî‚îÄ‚îÄ tbot/utils/datetime_utils.py

=== File Contents ===

================================================================================
File: tbot/config.py
================================================================================
# config.py
import os
from dataclasses import dataclass
from typing import List, Dict

@dataclass
class DatabaseConfig:
    """–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö"""
    url: str = os.getenv(
        "DATABASE_URL", 
        "postgresql://postgres:password@localhost:5432/trader_tracker"
    )
    pool_size: int = 20
    max_overflow: int = 30
    echo: bool = False

@dataclass
class TinkoffConfig:
    """–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è Tinkoff API"""
    token: str = os.getenv("TINKOFF_TOKEN", "")
    sandbox: bool = os.getenv("TINKOFF_SANDBOX", "false").lower() == "true"
    cache_ttl_seconds: int = 60

@dataclass
class TelegramConfig:
    """–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è Telegram"""
    api_id: int = int(os.getenv("TELEGRAM_API_ID", "0"))
    api_hash: str = os.getenv("TELEGRAM_API_HASH", "")
    session_name: str = os.getenv("TELEGRAM_SESSION", "demo_session")

@dataclass
class TrackingConfig:
    """–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è —Å–∏–≥–Ω–∞–ª–æ–≤"""
    position_timeout_hours: int = 24  # –¢–∞–π–º–∞—É—Ç –ø–æ–∑–∏—Ü–∏–π
    processing_interval_seconds: int = 60  # –ò–Ω—Ç–µ—Ä–≤–∞–ª –æ–±—Ä–∞–±–æ—Ç–∫–∏
    max_signals_per_batch: int = 50
    lookback_days: int = 30  # –ü–µ—Ä–∏–æ–¥ –¥–ª—è –ø–æ–∏—Å–∫–∞ —Å–∏–≥–Ω–∞–ª–æ–≤

@dataclass 
class APIConfig:
    """–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è API"""
    host: str = "0.0.0.0"
    port: int = int(os.getenv("PORT", "8000"))
    reload: bool = os.getenv("DEBUG", "false").lower() == "true"
    cors_origins: List[str] = None

    def __post_init__(self):
        if self.cors_origins is None:
            origins_str = os.getenv("CORS_ORIGINS", "*")
            self.cors_origins = [origin.strip() for origin in origins_str.split(",")]

@dataclass
class Config:
    """–ì–ª–∞–≤–Ω–∞—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è"""
    database: DatabaseConfig
    tinkoff: TinkoffConfig
    telegram: TelegramConfig
    tracking: TrackingConfig
    api: APIConfig
    
    # –†–µ–∂–∏–º—ã —Ä–∞–±–æ—Ç—ã
    enable_telegram: bool = os.getenv("ENABLE_TELEGRAM", "true").lower() == "true"
    enable_tinkoff: bool = os.getenv("ENABLE_TINKOFF", "true").lower() == "true"
    enable_background_tasks: bool = os.getenv("ENABLE_BG_TASKS", "true").lower() == "true"
    
    # –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
    log_level: str = os.getenv("LOG_LEVEL", "INFO")
    log_file: str = os.getenv("LOG_FILE", "logs/trader_tracker.log")

# –ì–ª–æ–±–∞–ª—å–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
config = Config(
    database=DatabaseConfig(),
    tinkoff=TinkoffConfig(),
    telegram=TelegramConfig(),
    tracking=TrackingConfig(),
    api=APIConfig()
)

================================================================================
File: tbot/start_demo.py
================================================================================
# run.py - –ü—Ä–æ—Å—Ç–æ–π –∑–∞–ø—É—Å–∫ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ –ø—Ä–æ–µ–∫—Ç–∞
import os
import sys
import asyncio
import uvicorn
from pathlib import Path
from dotenv import load_dotenv

def main():
    """–ü—Ä–æ—Å—Ç–æ–π –∑–∞–ø—É—Å–∫ –ø—Ä–æ–µ–∫—Ç–∞ –∫–∞–∫ –µ—Å—Ç—å"""
    print("üöÄ Starting Trader Tracker...")
    
    # –ó–∞–≥—Ä—É–∂–∞–µ–º .env –µ—Å–ª–∏ –µ—Å—Ç—å
    env_file = Path(".env")
    if env_file.exists():
        load_dotenv()
        print("‚úÖ Loaded .env file")
    else:
        print("‚ö†Ô∏è  No .env file found, using defaults")
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –ë–î –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∞
    database_url = os.getenv("DATABASE_URL")
    if not database_url:
        print("‚ùå DATABASE_URL not configured")
        print("üí° Set DATABASE_URL environment variable or create .env file")
        return
    
    print(f"üìö Database: {database_url}")
    
    # –°–æ–∑–¥–∞–µ–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –¥–ª—è –ª–æ–≥–æ–≤ –µ—Å–ª–∏ –Ω–µ—Ç
    os.makedirs("logs", exist_ok=True)
    
    # –ó–∞–ø—É—Å–∫–∞–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–µ API –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ
    try:
        print("üåê Starting API server...")
        print("üìä Access API at: http://localhost:8000")
        print("üìã API docs at: http://localhost:8000/docs")
        print("üí° Press Ctrl+C to stop")
        
        # –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ
        from api.app import app
        
        # –ó–∞–ø—É—Å–∫–∞–µ–º uvicorn
        uvicorn.run(
            app,
            host="0.0.0.0", 
            port=8000,
            log_level="info",
            reload=False  # –û—Ç–∫–ª—é—á–∞–µ–º reload –¥–ª—è —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç–∏
        )
        
    except KeyboardInterrupt:
        print("\nüëã Server stopped by user")
    except Exception as e:
        print(f"‚ùå Failed to start server: {e}")
        print("üí° Check your configuration and database connection")

if __name__ == "__main__":
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏
    try:
        import fastapi
        import sqlalchemy
    except ImportError as e:
        print(f"‚ùå Missing dependency: {e}")
        print("üí° Install dependencies: pip install -r requirements.txt")
        sys.exit(1)
    
    main()

================================================================================
File: tbot/core/database/database.py
================================================================================
# core/database/database.py
"""
–ö–ª–∞—Å—Å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å PostgreSQL
"""
import logging
from typing import Optional, List, Dict, Any, Tuple
from datetime import datetime, timedelta
from contextlib import contextmanager, asynccontextmanager

from sqlalchemy import create_engine, func, and_, or_, desc, asc
from sqlalchemy.orm import sessionmaker, Session
from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession
from sqlalchemy.dialects.postgresql import insert
from sqlalchemy.exc import IntegrityError

from .models import *

logger = logging.getLogger(__name__)

class Database:
    """–ö–ª–∞—Å—Å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å PostgreSQL (sync + async)"""
    
    def __init__(self, database_url: str, pool_size: int = 10, echo: bool = False):
        """
        –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –ë–î
        
        Args:
            database_url: PostgreSQL URL –≤–∏–¥–∞ postgresql://user:pass@host:port/db
            pool_size: —Ä–∞–∑–º–µ—Ä –ø—É–ª–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π
            echo: –≤—ã–≤–æ–¥–∏—Ç—å SQL –∑–∞–ø—Ä–æ—Å—ã –≤ –ª–æ–≥
        """
        self.database_url = database_url
        
        # –°–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π engine
        self.engine = create_engine(
            database_url,
            pool_size=pool_size,
            max_overflow=pool_size * 2,
            pool_pre_ping=True,
            echo=echo
        )
        self.SessionLocal = sessionmaker(bind=self.engine)
        
        # –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π engine
        async_url = database_url.replace('postgresql://', 'postgresql+asyncpg://')
        self.async_engine = create_async_engine(
            async_url,
            pool_size=pool_size,
            max_overflow=pool_size * 2,
            echo=echo
        )
        self.AsyncSessionLocal = async_sessionmaker(bind=self.async_engine)
        
        logger.info(f"‚úÖ Database initialized: {self._mask_url(database_url)}")
    
    def _mask_url(self, url: str) -> str:
        """–ú–∞—Å–∫–∏—Ä–æ–≤–∫–∞ –ø–∞—Ä–æ–ª—è –≤ URL –¥–ª—è –ª–æ–≥–æ–≤"""
        if '@' in url and ':' in url:
            parts = url.split('@')
            if len(parts) == 2:
                user_pass = parts[0].split('://')[-1]
                if ':' in user_pass:
                    user = user_pass.split(':')[0]
                    return url.replace(user_pass, f"{user}:***")
        return url
    
    @contextmanager
    def session(self):
        """–ö–æ–Ω—Ç–µ–∫—Å—Ç–Ω—ã–π –º–µ–Ω–µ–¥–∂–µ—Ä –¥–ª—è —Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏–π"""
        session = self.SessionLocal()
        try:
            yield session
            session.commit()
        except Exception:
            session.rollback()
            raise
        finally:
            session.close()
    
    @asynccontextmanager
    async def async_session(self):
        """–ö–æ–Ω—Ç–µ–∫—Å—Ç–Ω—ã–π –º–µ–Ω–µ–¥–∂–µ—Ä –¥–ª—è –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏–π"""
        async with self.AsyncSessionLocal() as session:
            try:
                yield session
                await session.commit()
            except Exception:
                await session.rollback()
                raise
    
    def close(self):
        """–ó–∞–∫—Ä—ã—Ç—å –≤—Å–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è"""
        self.engine.dispose()
        logger.info("üîå Database connections closed")
    
    # ===== –°–û–û–ë–©–ï–ù–ò–Ø =====
    
    def save_message(self, channel_id: int, message_id: int, 
                    timestamp: datetime, text: str, author: str = None,
                    is_processed: bool = False) -> int:
        """
        –°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Å—ã—Ä–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏–∑ Telegram
        
        Returns:
            int: ID —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è
        """
        with self.session() as session:
            message = RawMessage(
                channel_id=channel_id,
                message_id=message_id,
                timestamp=timestamp,
                text=text,
                author=author,
                is_processed=is_processed
            )
            
            try:
                session.add(message)
                session.flush()
                logger.debug(f"üíæ Message saved: {message.id}")
                return message.id
                
            except IntegrityError:
                session.rollback()
                # –°–æ–æ–±—â–µ–Ω–∏–µ —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç - –æ–±–Ω–æ–≤–ª—è–µ–º
                existing = session.query(RawMessage).filter(
                    RawMessage.channel_id == channel_id,
                    RawMessage.message_id == message_id
                ).first()
                
                if existing:
                    existing.text = text
                    existing.author = author
                    existing.is_processed = is_processed
                    session.flush()
                    return existing.id
                
                raise
    
    def get_messages(self, channel_id: int = None, is_processed: bool = None,
                    from_date: datetime = None, limit: int = 1000) -> List[Dict]:
        """
        –ü–æ–ª—É—á–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏—è —Å —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–µ–π
        
        Returns:
            List[Dict]: —Å–ø–∏—Å–æ–∫ —Å–æ–æ–±—â–µ–Ω–∏–π –≤ –≤–∏–¥–µ —Å–ª–æ–≤–∞—Ä–µ–π
        """
        with self.session() as session:
            query = session.query(RawMessage)
            
            if channel_id is not None:
                query = query.filter(RawMessage.channel_id == channel_id)
            
            if is_processed is not None:
                query = query.filter(RawMessage.is_processed == is_processed)
                
            if from_date:
                query = query.filter(RawMessage.timestamp >= from_date)
            
            messages = query.order_by(desc(RawMessage.timestamp)).limit(limit).all()
            
            return [
                {
                    'id': msg.id,
                    'channel_id': msg.channel_id,
                    'message_id': msg.message_id,
                    'timestamp': msg.timestamp,
                    'text': msg.text,
                    'author': msg.author,
                    'is_processed': msg.is_processed
                }
                for msg in messages
            ]
    
    def mark_message_processed(self, message_id: int):
        """–û—Ç–º–µ—Ç–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –∫–∞–∫ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω–æ–µ"""
        with self.session() as session:
            session.query(RawMessage).filter(RawMessage.id == message_id).update(
                {'is_processed': True}
            )
    
    # ===== –°–ò–ì–ù–ê–õ–´ =====
    
    def save_signal(self, signal_data: Dict) -> str:
        """
        –°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ç–æ—Ä–≥–æ–≤—ã–π —Å–∏–≥–Ω–∞–ª
        
        Args:
            signal_data: —Å–ª–æ–≤–∞—Ä—å —Å –¥–∞–Ω–Ω—ã–º–∏ —Å–∏–≥–Ω–∞–ª–∞
            
        Returns:
            str: UUID —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω–æ–≥–æ —Å–∏–≥–Ω–∞–ª–∞
        """
        with self.session() as session:
            signal = ParsedSignal(
                raw_message_id=signal_data.get('raw_message_id'),
                timestamp=signal_data['timestamp'],
                parser_version=signal_data.get('parser_version', '1.0'),
                confidence_score=signal_data.get('confidence_score'),
                channel_id=signal_data['channel_id'],
                trader_id=signal_data.get('trader_id'),
                author=signal_data.get('author'),
                original_text=signal_data['original_text'],
                ticker=signal_data['ticker'],
                figi=signal_data.get('figi'),
                direction=signal_data.get('direction'),
                signal_type=signal_data.get('signal_type'),
                target_price=signal_data.get('target_price'),
                stop_loss=signal_data.get('stop_loss'),
                take_profit=signal_data.get('take_profit'),
                entry_condition=signal_data.get('entry_condition'),
                confidence_level=signal_data.get('confidence_level'),
                timeframe=signal_data.get('timeframe'),
                extracted_data=signal_data.get('extracted_data')
            )
            
            session.add(signal)
            session.flush()
            
            logger.debug(f"üìà Signal saved: {signal.id}")
            return str(signal.id)
    
    def get_signals(self, ticker: str = None, trader_id: int = None,
                   channel_id: int = None, direction: str = None,
                   from_date: datetime = None, limit: int = 100) -> List[Dict]:
        """
        –ü–æ–ª—É—á–∏—Ç—å —Å–∏–≥–Ω–∞–ª—ã —Å —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–µ–π
        
        Returns:
            List[Dict]: —Å–ø–∏—Å–æ–∫ —Å–∏–≥–Ω–∞–ª–æ–≤
        """
        with self.session() as session:
            query = session.query(ParsedSignal)
            
            if ticker:
                query = query.filter(ParsedSignal.ticker == ticker)
            
            if trader_id:
                query = query.filter(ParsedSignal.trader_id == trader_id)
                
            if channel_id:
                query = query.filter(ParsedSignal.channel_id == channel_id)
                
            if direction:
                query = query.filter(ParsedSignal.direction == direction)
                
            if from_date:
                query = query.filter(ParsedSignal.timestamp >= from_date)
            
            signals = query.order_by(desc(ParsedSignal.timestamp)).limit(limit).all()
            
            return [
                {
                    'id': str(signal.id),
                    'timestamp': signal.timestamp,
                    'ticker': signal.ticker,
                    'direction': signal.direction,
                    'signal_type': signal.signal_type,
                    'target_price': float(signal.target_price) if signal.target_price else None,
                    'stop_loss': float(signal.stop_loss) if signal.stop_loss else None,
                    'take_profit': float(signal.take_profit) if signal.take_profit else None,
                    'author': signal.author,
                    'trader_id': signal.trader_id,
                    'confidence_score': float(signal.confidence_score) if signal.confidence_score else None,
                    'original_text': signal.original_text
                }
                for signal in signals
            ]
    
    # ===== –¢–†–ï–ô–î–ï–†–´ =====
    
    def create_trader(self, name: str, channel_id: int, 
                     telegram_username: str = None) -> int:
        """
        –°–æ–∑–¥–∞—Ç—å –ø—Ä–æ—Ñ–∏–ª—å —Ç—Ä–µ–π–¥–µ—Ä–∞
        
        Returns:
            int: ID —Å–æ–∑–¥–∞–Ω–Ω–æ–≥–æ —Ç—Ä–µ–π–¥–µ—Ä–∞
        """
        with self.session() as session:
            trader = Trader(
                name=name,
                channel_id=channel_id,
                telegram_username=telegram_username,
                is_active=True,
                total_signals=0
            )
            
            try:
                session.add(trader)
                session.flush()
                logger.info(f"üë§ Trader created: {trader.name} (ID: {trader.id})")
                return trader.id
                
            except IntegrityError:
                session.rollback()
                # –¢—Ä–µ–π–¥–µ—Ä —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
                existing = session.query(Trader).filter(Trader.name == name).first()
                if existing:
                    return existing.id
                raise
    
    def get_trader_stats(self, trader_id: int) -> Optional[Dict]:
        """
        –ü–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É —Ç—Ä–µ–π–¥–µ—Ä–∞
        
        Returns:
            Dict: —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Ç—Ä–µ–π–¥–µ—Ä–∞ –∏–ª–∏ None
        """
        with self.session() as session:
            trader = session.query(Trader).filter(Trader.id == trader_id).first()
            
            if not trader:
                return None
            
            # –°—á–∏—Ç–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ —Å–∏–≥–Ω–∞–ª–∞–º
            total_signals = session.query(ParsedSignal).filter(
                ParsedSignal.trader_id == trader_id
            ).count()
            
            # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º
            results_query = session.query(SignalResult).join(ParsedSignal).filter(
                ParsedSignal.trader_id == trader_id
            )
            
            total_results = results_query.count()
            closed_results = results_query.filter(SignalResult.status == 'closed').all()
            
            win_count = len([r for r in closed_results if r.profit_loss_pct and r.profit_loss_pct > 0])
            win_rate = (win_count / len(closed_results) * 100) if closed_results else 0
            
            avg_profit = sum(float(r.profit_loss_pct or 0) for r in closed_results) / len(closed_results) if closed_results else 0
            
            return {
                'trader_id': trader.id,
                'name': trader.name,
                'telegram_username': trader.telegram_username,
                'channel_id': trader.channel_id,
                'is_active': trader.is_active,
                'total_signals': total_signals,
                'total_results': total_results,
                'closed_results': len(closed_results),
                'win_rate': round(win_rate, 2),
                'avg_profit_pct': round(avg_profit, 2),
                'first_signal_at': trader.first_signal_at,
                'last_signal_at': trader.last_signal_at
            }
    
    def get_all_traders(self, active_only: bool = True) -> List[Dict]:
        """
        –ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö —Ç—Ä–µ–π–¥–µ—Ä–æ–≤
        
        Returns:
            List[Dict]: —Å–ø–∏—Å–æ–∫ —Ç—Ä–µ–π–¥–µ—Ä–æ–≤
        """
        with self.session() as session:
            query = session.query(Trader)
            
            if active_only:
                query = query.filter(Trader.is_active == True)
            
            traders = query.order_by(asc(Trader.name)).all()
            
            return [
                {
                    'id': trader.id,
                    'name': trader.name,
                    'telegram_username': trader.telegram_username,
                    'channel_id': trader.channel_id,
                    'is_active': trader.is_active,
                    'total_signals': trader.total_signals,
                    'win_rate': float(trader.win_rate) if trader.win_rate else None,
                    'avg_profit_pct': float(trader.avg_profit_pct) if trader.avg_profit_pct else None
                }
                for trader in traders
            ]
    
    # ===== –†–ï–ó–£–õ–¨–¢–ê–¢–´ –°–ò–ì–ù–ê–õ–û–í =====
    
    def save_signal_result(self, signal_id: str, result_data: Dict) -> str:
        """
        –°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è —Å–∏–≥–Ω–∞–ª–∞
        
        Returns:
            str: UUID —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
        """
        with self.session() as session:
            result = SignalResult(
                signal_id=signal_id,
                planned_entry_price=result_data.get('planned_entry_price'),
                actual_entry_price=result_data.get('actual_entry_price'),
                exit_price=result_data.get('exit_price'),
                profit_loss_pct=result_data.get('profit_loss_pct'),
                profit_loss_abs=result_data.get('profit_loss_abs'),
                entry_time=result_data.get('entry_time'),
                exit_time=result_data.get('exit_time'),
                duration_minutes=result_data.get('duration_minutes'),
                status=result_data.get('status', 'active'),
                exit_reason=result_data.get('exit_reason')
            )
            
            session.add(result)
            session.flush()
            
            logger.debug(f"üìä Signal result saved: {result.id}")
            return str(result.id)
    
    def update_signal_result(self, result_id: str, updates: Dict):
        """–û–±–Ω–æ–≤–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç —Å–∏–≥–Ω–∞–ª–∞"""
        with self.session() as session:
            session.query(SignalResult).filter(SignalResult.id == result_id).update(updates)
    
    def get_active_signals(self) -> List[Dict]:
        """
        –ü–æ–ª—É—á–∏—Ç—å –∞–∫—Ç–∏–≤–Ω—ã–µ —Å–∏–≥–Ω–∞–ª—ã –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è
        
        Returns:
            List[Dict]: –∞–∫—Ç–∏–≤–Ω—ã–µ —Å–∏–≥–Ω–∞–ª—ã —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º–∏
        """
        with self.session() as session:
            query = session.query(ParsedSignal, SignalResult).outerjoin(SignalResult).filter(
                or_(
                    SignalResult.status == 'active',
                    SignalResult.status.is_(None)  # –°–∏–≥–Ω–∞–ª—ã –±–µ–∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
                )
            )
            
            results = []
            for signal, result in query.all():
                signal_data = {
                    'signal_id': str(signal.id),
                    'timestamp': signal.timestamp,
                    'ticker': signal.ticker,
                    'direction': signal.direction,
                    'target_price': float(signal.target_price) if signal.target_price else None,
                    'stop_loss': float(signal.stop_loss) if signal.stop_loss else None,
                    'take_profit': float(signal.take_profit) if signal.take_profit else None,
                    'trader_id': signal.trader_id,
                    'author': signal.author
                }
                
                if result:
                    signal_data.update({
                        'result_id': str(result.id),
                        'actual_entry_price': float(result.actual_entry_price) if result.actual_entry_price else None,
                        'status': result.status,
                        'entry_time': result.entry_time,
                        'tracking_started_at': result.tracking_started_at
                    })
                
                results.append(signal_data)
            
            return results
    
    # ===== –ò–ù–°–¢–†–£–ú–ï–ù–¢–´ –ò –°–í–ï–ß–ò =====
    
    def save_instrument(self, figi: str, ticker: str, name: str, 
                       instrument_type: str = 'share') -> str:
        """
        –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–µ
        
        Returns:
            str: FIGI –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞
        """
        with self.session() as session:
            instrument = Instrument(
                figi=figi,
                ticker=ticker,
                name=name,
                type=instrument_type,
                is_active=True
            )
            
            try:
                session.merge(instrument)  # –ò—Å–ø–æ–ª—å–∑—É–µ–º merge –¥–ª—è upsert
                return figi
                
            except Exception as e:
                session.rollback()
                logger.error(f"‚ùå Error saving instrument {ticker}: {e}")
                raise
    
    def get_instrument_by_ticker(self, ticker: str) -> Optional[Dict]:
        """
        –ü–æ–ª—É—á–∏—Ç—å –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç –ø–æ —Ç–∏–∫–µ—Ä—É
        
        Returns:
            Dict: –¥–∞–Ω–Ω—ã–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞ –∏–ª–∏ None
        """
        with self.session() as session:
            instrument = session.query(Instrument).filter(
                Instrument.ticker == ticker
            ).first()
            
            if not instrument:
                return None
            
            return {
                'figi': instrument.figi,
                'ticker': instrument.ticker,
                'name': instrument.name,
                'type': instrument.type,
                'currency': instrument.currency,
                'lot': instrument.lot,
                'is_active': instrument.is_active
            }

    # –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π –º–µ—Ç–æ–¥ save_candles –¥–ª—è core/database/database.py

    def save_candles(self, candles_data, figi: str = None, interval: str = None) -> Dict:
        """
        –ú–∞—Å—Å–æ–≤–æ–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Å–≤–µ—á–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö —Å –±–∞—Ç—á–∏–Ω–≥–æ–º –¥–ª—è PostgreSQL
        
        Args:
            candles_data: —Å–ø–∏—Å–æ–∫ –∫–æ—Ä—Ç–µ–∂–µ–π (figi, interval, time, open, high, low, close, volume)
                        –ò–õ–ò —Å–ø–∏—Å–æ–∫ —Å–ª–æ–≤–∞—Ä–µ–π {'time': ..., 'open': ..., ...} + figi –∏ interval –æ—Ç–¥–µ–ª—å–Ω–æ
            figi: FIGI –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞ (–µ—Å–ª–∏ candles_data —ç—Ç–æ —Å–ø–∏—Å–æ–∫ —Å–ª–æ–≤–∞—Ä–µ–π)
            interval: –∏–Ω—Ç–µ—Ä–≤–∞–ª (–µ—Å–ª–∏ candles_data —ç—Ç–æ —Å–ø–∏—Å–æ–∫ —Å–ª–æ–≤–∞—Ä–µ–π)
            
        Returns:
            Dict: —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è
        """
        if not candles_data:
            logger.warning("‚ö†Ô∏è save_candles called with empty data")
            return {'saved': 0, 'errors': 0}
        
        logger.info(f"üíæ Attempting to save {len(candles_data)} candles...")
        
        # üîç –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ñ–æ—Ä–º–∞—Ç –¥–∞–Ω–Ω—ã—Ö
        first_item = candles_data[0]
        is_dict_format = isinstance(first_item, dict)
        
        logger.info(f"üìä Data format: {'dict' if is_dict_format else 'tuple'}")
        
        if is_dict_format and (not figi or not interval):
            logger.error("‚ùå Dict format requires figi and interval parameters")
            return {'saved': 0, 'errors': len(candles_data)}
        
        with self.session() as session:
            try:
                candles_dicts = []
                errors = 0
                seen_times = set()  # üÜï –û—Ç—Å–ª–µ–∂–∏–≤–∞–µ–º –¥—É–±–ª–∏–∫–∞—Ç—ã –ø–æ –≤—Ä–µ–º–µ–Ω–∏
                
                # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –¥–∞–Ω–Ω—ã–µ –≤ –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç
                for i, candle in enumerate(candles_data):
                    try:
                        if is_dict_format:
                            # –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ñ–æ—Ä–º–∞—Ç–∞ —Å–ª–æ–≤–∞—Ä–µ–π (–æ—Ç Tinkoff API)
                            candle_time = candle['time']
                            
                            # üÜï –ü–†–û–í–ï–†–Ø–ï–ú –î–£–ë–õ–ò–ö–ê–¢–´ –ü–û –í–†–ï–ú–ï–ù–ò
                            time_key = (figi, interval, candle_time)
                            if time_key in seen_times:
                                logger.warning(f"‚ö†Ô∏è Skipping duplicate candle at {candle_time}")
                                continue
                            seen_times.add(time_key)
                            
                            candle_dict = {
                                'instrument_id': figi,
                                'interval': interval,
                                'time': candle_time,
                                'open': float(candle['open']),
                                'high': float(candle['high']),
                                'low': float(candle['low']),
                                'close': float(candle['close']),
                                'volume': int(candle.get('volume', 0))
                            }
                        else:
                            # –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ñ–æ—Ä–º–∞—Ç–∞ –∫–æ—Ä—Ç–µ–∂–µ–π (—Å—Ç–∞—Ä—ã–π —Ñ–æ—Ä–º–∞—Ç)
                            if len(candle) < 7:
                                logger.error(f"‚ùå Invalid tuple length at index {i}: {len(candle)}")
                                errors += 1
                                continue
                            
                            # üÜï –ü–†–û–í–ï–†–Ø–ï–ú –î–£–ë–õ–ò–ö–ê–¢–´ –ü–û –í–†–ï–ú–ï–ù–ò
                            time_key = (candle[0], candle[1], candle[2])
                            if time_key in seen_times:
                                logger.warning(f"‚ö†Ô∏è Skipping duplicate candle at {candle[2]}")
                                continue
                            seen_times.add(time_key)
                            
                            candle_dict = {
                                'instrument_id': candle[0],
                                'interval': candle[1],
                                'time': candle[2],
                                'open': float(candle[3]),
                                'high': float(candle[4]),
                                'low': float(candle[5]),
                                'close': float(candle[6]),
                                'volume': int(candle[7]) if len(candle) > 7 else 0
                            }
                        
                        candles_dicts.append(candle_dict)
                        
                    except (ValueError, IndexError, TypeError, KeyError) as e:
                        logger.error(f"‚ùå Error processing candle at index {i}: {e}")
                        errors += 1
                        continue
                
                if not candles_dicts:
                    logger.error("‚ùå No valid candles to save after processing")
                    return {'saved': 0, 'errors': len(candles_data)}
                
                logger.info(f"‚úÖ Processed {len(candles_dicts)} valid candles (removed {len(candles_data) - len(candles_dicts)} duplicates), {errors} errors")
                
                # üî• –ö–õ–Æ–ß–ï–í–û–ï –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –£–ú–ï–ù–¨–®–ï–ù–ù–´–ô –†–ê–ó–ú–ï–† –ë–ê–¢–ß–ê
                from sqlalchemy.dialects.postgresql import insert
                
                BATCH_SIZE = 500  # üÜï –£–º–µ–Ω—å—à–µ–Ω–æ —Å 1000 –¥–æ 500 –¥–ª—è —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç–∏
                total_saved = 0
                
                # –†–∞–∑–±–∏–≤–∞–µ–º –¥–∞–Ω–Ω—ã–µ –Ω–∞ –±–∞—Ç—á–∏
                for i in range(0, len(candles_dicts), BATCH_SIZE):
                    batch = candles_dicts[i:i + BATCH_SIZE]
                    logger.info(f"üì¶ Processing batch {i//BATCH_SIZE + 1}/{(len(candles_dicts)-1)//BATCH_SIZE + 1}: {len(batch)} records")
                    
                    try:
                        # –°–æ–∑–¥–∞–µ–º –∑–∞–ø—Ä–æ—Å –¥–ª—è –±–∞—Ç—á–∞
                        stmt = insert(Candle).values(batch)
                        
                        # ON CONFLICT –¥–ª—è –∏–∑–±–µ–∂–∞–Ω–∏—è –¥—É–±–ª–∏–∫–∞—Ç–æ–≤
                        stmt = stmt.on_conflict_do_update(
                            index_elements=['instrument_id', 'interval', 'time'],
                            set_={
                                'open': stmt.excluded.open,
                                'high': stmt.excluded.high,
                                'low': stmt.excluded.low,
                                'close': stmt.excluded.close,
                                'volume': stmt.excluded.volume
                            }
                        )
                        
                        # –í—ã–ø–æ–ª–Ω—è–µ–º –∑–∞–ø—Ä–æ—Å –¥–ª—è –±–∞—Ç—á–∞
                        result = session.execute(stmt)
                        session.commit()  # üÜï –ö–æ–º–º–∏—Ç–∏–º –∫–∞–∂–¥—ã–π –±–∞—Ç—á –æ—Ç–¥–µ–ª—å–Ω–æ
                        total_saved += len(batch)
                        
                        logger.info(f"‚úÖ Saved batch {i//BATCH_SIZE + 1}: {len(batch)} records")
                        
                    except Exception as batch_error:
                        session.rollback()  # üÜï –û—Ç–∫–∞—Ç—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ —Ç–µ–∫—É—â–∏–π –±–∞—Ç—á
                        logger.error(f"‚ùå Error saving batch {i//BATCH_SIZE + 1}: {batch_error}")
                        
                        # üÜï –ü—ã—Ç–∞–µ–º—Å—è —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –ø–æ –æ–¥–Ω–æ–π –∑–∞–ø–∏—Å–∏ –¥–ª—è –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏
                        if len(batch) <= 10:  # –¢–æ–ª—å–∫–æ –¥–ª—è –Ω–µ–±–æ–ª—å—à–∏—Ö –±–∞—Ç—á–µ–π
                            single_saved = 0
                            for single_candle in batch:
                                try:
                                    single_stmt = insert(Candle).values([single_candle])
                                    single_stmt = single_stmt.on_conflict_do_update(
                                        index_elements=['instrument_id', 'interval', 'time'],
                                        set_={
                                            'open': single_stmt.excluded.open,
                                            'high': single_stmt.excluded.high,
                                            'low': single_stmt.excluded.low,
                                            'close': single_stmt.excluded.close,
                                            'volume': single_stmt.excluded.volume
                                        }
                                    )
                                    session.execute(single_stmt)
                                    session.commit()
                                    single_saved += 1
                                except Exception as single_error:
                                    session.rollback()
                                    logger.error(f"‚ùå Failed to save single candle: {single_error}")
                                    logger.error(f"‚ùå Problem candle: {single_candle}")
                            
                            total_saved += single_saved
                            logger.info(f"üîÑ Saved {single_saved}/{len(batch)} records individually")
                
                logger.info(f"üéâ Successfully saved {total_saved} candles to database")
                
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –¥–∞–Ω–Ω—ã–µ —Å–æ—Ö—Ä–∞–Ω–∏–ª–∏—Å—å
                if is_dict_format:
                    verification_count = session.query(Candle).filter(
                        Candle.instrument_id == figi,
                        Candle.interval == interval
                    ).count()
                    logger.info(f"üîç Verification: {verification_count} candles now in DB for {figi}/{interval}")
                
                return {'saved': total_saved, 'errors': errors}
                
            except Exception as e:
                session.rollback()
                logger.error(f"‚ùå Error saving candles: {e}")
                logger.error(f"‚ùå Error type: {type(e)}")
                
                # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø—Ä–∏–º–µ—Ä –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –æ—à–∏–±–∫–µ
                if candles_dicts:
                    logger.error(f"‚ùå Sample candle_dict: {candles_dicts[0]}")
                
                return {'saved': 0, 'errors': len(candles_data)}

    
    # –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π –º–µ—Ç–æ–¥ async_save_candles –¥–ª—è core/database/database.py

    async def async_save_candles(self, candles_data, figi: str = None, interval: str = None) -> Dict:
        """
        –ú–∞—Å—Å–æ–≤–æ–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Å–≤–µ—á–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö (–∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ, –¥–ª—è –≤–µ–±—Å–æ–∫–µ—Ç–æ–≤)
        
        Args:
            candles_data: —Å–ø–∏—Å–æ–∫ –∫–æ—Ä—Ç–µ–∂–µ–π (figi, interval, time, open, high, low, close, volume)
                        –ò–õ–ò —Å–ø–∏—Å–æ–∫ —Å–ª–æ–≤–∞—Ä–µ–π {'time': ..., 'open': ..., ...} + figi –∏ interval –æ—Ç–¥–µ–ª—å–Ω–æ
            figi: FIGI –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞ (–µ—Å–ª–∏ candles_data —ç—Ç–æ —Å–ø–∏—Å–æ–∫ —Å–ª–æ–≤–∞—Ä–µ–π)
            interval: –∏–Ω—Ç–µ—Ä–≤–∞–ª (–µ—Å–ª–∏ candles_data —ç—Ç–æ —Å–ø–∏—Å–æ–∫ —Å–ª–æ–≤–∞—Ä–µ–π)
            
        Returns:
            Dict: —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è
        """
        if not candles_data:
            return {'saved': 0, 'errors': 0}
        
        # üîç –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ñ–æ—Ä–º–∞—Ç –¥–∞–Ω–Ω—ã—Ö
        first_item = candles_data[0]
        is_dict_format = isinstance(first_item, dict)
        
        if is_dict_format and (not figi or not interval):
            logger.error("‚ùå Dict format requires figi and interval parameters")
            return {'saved': 0, 'errors': len(candles_data)}
        
        async with self.async_session() as session:
            try:
                candles_dicts = []
                errors = 0
                seen_times = set()  # üÜï –û—Ç—Å–ª–µ–∂–∏–≤–∞–µ–º –¥—É–±–ª–∏–∫–∞—Ç—ã –ø–æ –≤—Ä–µ–º–µ–Ω–∏
                
                for i, candle in enumerate(candles_data):
                    try:
                        if is_dict_format:
                            # üÜï –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ñ–æ—Ä–º–∞—Ç–∞ —Å–ª–æ–≤–∞—Ä–µ–π (–æ—Ç Tinkoff API)
                            candle_time = candle['time']
                            
                            # üÜï –ü–†–û–í–ï–†–Ø–ï–ú –î–£–ë–õ–ò–ö–ê–¢–´ –ü–û –í–†–ï–ú–ï–ù–ò
                            time_key = (figi, interval, candle_time)
                            if time_key in seen_times:
                                logger.warning(f"‚ö†Ô∏è Skipping duplicate async candle at {candle_time}")
                                continue
                            seen_times.add(time_key)
                            
                            candle_dict = {
                                'instrument_id': figi,
                                'interval': interval,
                                'time': candle_time,
                                'open': float(candle['open']),
                                'high': float(candle['high']),
                                'low': float(candle['low']),
                                'close': float(candle['close']),
                                'volume': int(candle.get('volume', 0))
                            }
                        else:
                            # üìÑ –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ñ–æ—Ä–º–∞—Ç–∞ –∫–æ—Ä—Ç–µ–∂–µ–π (—Å—Ç–∞—Ä—ã–π —Ñ–æ—Ä–º–∞—Ç)
                            if len(candle) < 7:
                                errors += 1
                                continue
                            
                            # üÜï –ü–†–û–í–ï–†–Ø–ï–ú –î–£–ë–õ–ò–ö–ê–¢–´ –ü–û –í–†–ï–ú–ï–ù–ò
                            time_key = (candle[0], candle[1], candle[2])
                            if time_key in seen_times:
                                logger.warning(f"‚ö†Ô∏è Skipping duplicate async candle at {candle[2]}")
                                continue
                            seen_times.add(time_key)
                            
                            candle_dict = {
                                'instrument_id': candle[0],
                                'interval': candle[1],
                                'time': candle[2],
                                'open': float(candle[3]),
                                'high': float(candle[4]),
                                'low': float(candle[5]),
                                'close': float(candle[6]),
                                'volume': int(candle[7]) if len(candle) > 7 else 0
                            }
                        
                        candles_dicts.append(candle_dict)
                        
                    except (ValueError, IndexError, TypeError, KeyError) as e:
                        logger.error(f"‚ùå Error processing async candle at index {i}: {e}")
                        errors += 1
                        continue
                
                if not candles_dicts:
                    return {'saved': 0, 'errors': len(candles_data)}
                
                logger.info(f"‚úÖ Processed {len(candles_dicts)} valid async candles (removed {len(candles_data) - len(candles_dicts)} duplicates)")
                
                # üÜï –ë–ê–¢–ß–ò–ù–ì –î–õ–Ø –ê–°–ò–ù–•–†–û–ù–ù–û–ì–û –ú–ï–¢–û–î–ê
                from sqlalchemy.dialects.postgresql import insert
                
                BATCH_SIZE = 250  # –ú–µ–Ω—å—à–µ –¥–ª—è –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏–π
                total_saved = 0
                
                for i in range(0, len(candles_dicts), BATCH_SIZE):
                    batch = candles_dicts[i:i + BATCH_SIZE]
                    
                    try:
                        stmt = insert(Candle).values(batch)
                        stmt = stmt.on_conflict_do_update(
                            index_elements=['instrument_id', 'interval', 'time'],
                            set_={
                                'open': stmt.excluded.open,
                                'high': stmt.excluded.high,
                                'low': stmt.excluded.low,
                                'close': stmt.excluded.close,
                                'volume': stmt.excluded.volume
                            }
                        )
                        
                        await session.execute(stmt)
                        await session.commit()  # üÜï –ö–æ–º–º–∏—Ç–∏–º –∫–∞–∂–¥—ã–π –±–∞—Ç—á
                        total_saved += len(batch)
                        
                    except Exception as batch_error:
                        await session.rollback()
                        logger.error(f"‚ùå Error saving async batch: {batch_error}")
                        continue
                
                return {'saved': total_saved, 'errors': errors}
                
            except Exception as e:
                await session.rollback()
                logger.error(f"‚ùå Error saving candles async: {e}")
                return {'saved': 0, 'errors': len(candles_data)}

    def get_candles(self, figi: str, interval: str, 
                    from_time: datetime = None, to_time: datetime = None,
                    limit: int = None) -> List[Dict]:  # ‚úÖ limit —Ç–µ–ø–µ—Ä—å –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π
            """
            –ü–æ–ª—É—á–∏—Ç—å —Å–≤–µ—á–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ (—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ) - –ë–ï–ó –û–ë–Ø–ó–ê–¢–ï–õ–¨–ù–û–ì–û –õ–ò–ú–ò–¢–ê
            
            Returns:
                List[Dict]: —Å–ø–∏—Å–æ–∫ —Å–≤–µ—á–µ–π (–í–°–ï –¥–æ—Å—Ç—É–ø–Ω—ã–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é)
            """
            with self.session() as session:
                query = session.query(Candle).filter(
                    Candle.instrument_id == figi,
                    Candle.interval == interval
                )
                
                if from_time:
                    query = query.filter(Candle.time >= from_time)
                
                if to_time:
                    query = query.filter(Candle.time <= to_time)
                
                query = query.order_by(asc(Candle.time))
                
                # ‚úÖ –ü—Ä–∏–º–µ–Ω—è–µ–º –ª–∏–º–∏—Ç —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –æ–Ω —è–≤–Ω–æ —É–∫–∞–∑–∞–Ω
                if limit is not None and limit > 0:
                    query = query.limit(limit)
                
                candles = query.all()
                
                return [
                    {
                        'time': candle.time,
                        'open': float(candle.open),
                        'high': float(candle.high),
                        'low': float(candle.low),
                        'close': float(candle.close),
                        'volume': candle.volume
                    }
                    for candle in candles
                ]
    
    async def async_get_candles(self, figi: str, interval: str, 
                                from_time: datetime = None, to_time: datetime = None,
                                limit: int = None) -> List[Dict]:  # ‚úÖ limit –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π
            """
            –ü–æ–ª—É—á–∏—Ç—å —Å–≤–µ—á–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ (–∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ) - –ë–ï–ó –û–ë–Ø–ó–ê–¢–ï–õ–¨–ù–û–ì–û –õ–ò–ú–ò–¢–ê
            
            Returns:
                List[Dict]: —Å–ø–∏—Å–æ–∫ —Å–≤–µ—á–µ–π (–í–°–ï –¥–æ—Å—Ç—É–ø–Ω—ã–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é)
            """
            async with self.async_session() as session:
                from sqlalchemy import select
                
                query = select(Candle).filter(
                    Candle.instrument_id == figi,
                    Candle.interval == interval
                )
                
                if from_time:
                    query = query.filter(Candle.time >= from_time)
                
                if to_time:
                    query = query.filter(Candle.time <= to_time)
                
                query = query.order_by(asc(Candle.time))
                
                if limit is not None and limit > 0:
                    query = query.limit(limit)
                
                result = await session.execute(query)
                candles = result.scalars().all()
                
                return [
                    {
                        'time': candle.time,
                        'open': float(candle.open),
                        'high': float(candle.high),
                        'low': float(candle.low),
                        'close': float(candle.close),
                        'volume': candle.volume
                    }
                    for candle in candles
                ]

    
    # ===== –°–¢–ê–¢–ò–°–¢–ò–ö–ê =====
    
    def get_statistics(self) -> Dict[str, Any]:
        """
        –ü–æ–ª—É—á–∏—Ç—å –æ–±—â—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É —Å–∏—Å—Ç–µ–º—ã
        
        Returns:
            Dict: —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ –≤—Å–µ–º —Ç–∞–±–ª–∏—Ü–∞–º
        """
        with self.session() as session:
            stats = {
                'messages': {
                    'total': session.query(RawMessage).count(),
                    'processed': session.query(RawMessage).filter(RawMessage.is_processed == True).count(),
                    'unprocessed': session.query(RawMessage).filter(RawMessage.is_processed == False).count()
                },
                'signals': {
                    'total': session.query(ParsedSignal).count(),
                    'unique_tickers': session.query(ParsedSignal.ticker).distinct().count(),
                    'last_24h': session.query(ParsedSignal).filter(
                        ParsedSignal.timestamp >= datetime.now() - timedelta(hours=24)
                    ).count()
                },
                'traders': {
                    'total': session.query(Trader).count(),
                    'active': session.query(Trader).filter(Trader.is_active == True).count()
                },
                'results': {
                    'total': session.query(SignalResult).count(),
                    'active': session.query(SignalResult).filter(SignalResult.status == 'active').count(),
                    'closed': session.query(SignalResult).filter(SignalResult.status == 'closed').count()
                },
                'instruments': session.query(Instrument).count(),
                'candles': session.query(Candle).count()
            }
            
            return stats
    
    def health_check(self) -> Dict[str, Any]:
        """
        –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–¥–æ—Ä–æ–≤—å—è –ë–î
        
        Returns:
            Dict: —Å—Ç–∞—Ç—É—Å –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∏ –æ—Å–Ω–æ–≤–Ω—ã–µ –º–µ—Ç—Ä–∏–∫–∏
        """
        try:
            with self.session() as session:
                session.execute("SELECT 1")
                
                return {
                    'status': 'healthy',
                    'database_url': self._mask_url(self.database_url),
                    'connection': 'ok',
                    'timestamp': datetime.now()
                }
                
        except Exception as e:
            return {
                'status': 'unhealthy',
                'error': str(e),
                'timestamp': datetime.now()
            }

# core/database/models.py  
"""
SQLAlchemy –º–æ–¥–µ–ª–∏ –¥–ª—è –≤—Å–µ—Ö —Ç–∞–±–ª–∏—Ü
"""
import uuid
from datetime import datetime
from sqlalchemy import (
    Column, Integer, BigInteger, String, Text, Boolean, DateTime,
    Numeric, ForeignKey, Index, UniqueConstraint, func
)
from sqlalchemy.dialects.postgresql import UUID, JSONB
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship

Base = declarative_base()

class RawMessage(Base):
    """–°—ã—Ä—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è –∏–∑ Telegram –∫–∞–Ω–∞–ª–æ–≤"""
    __tablename__ = 'raw_messages'
    
    id = Column(BigInteger, primary_key=True, autoincrement=True)
    channel_id = Column(BigInteger, nullable=False)
    message_id = Column(BigInteger, nullable=False)
    
    timestamp = Column(DateTime(timezone=True), nullable=False, index=True)
    text = Column(Text, nullable=False)
    author = Column(String(100))
    
    is_processed = Column(Boolean, default=False, index=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    
    # Relationships
    parsed_signals = relationship("ParsedSignal", back_populates="raw_message")
    
    __table_args__ = (
        UniqueConstraint('channel_id', 'message_id', name='unique_channel_message'),
        Index('idx_raw_messages_channel_timestamp', 'channel_id', 'timestamp'),
        Index('idx_raw_messages_unprocessed', 'is_processed', 'timestamp'),
    )

class ParsedSignal(Base):
    """–†–∞—Å–ø–æ–∑–Ω–∞–Ω–Ω—ã–µ —Ç–æ—Ä–≥–æ–≤—ã–µ —Å–∏–≥–Ω–∞–ª—ã"""
    __tablename__ = 'parsed_signals'
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    raw_message_id = Column(BigInteger, ForeignKey('raw_messages.id'), nullable=True)
    
    timestamp = Column(DateTime(timezone=True), nullable=False, index=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    
    # –ú–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ –ø–∞—Ä—Å–∏–Ω–≥–∞
    parser_version = Column(String(20), nullable=False)
    confidence_score = Column(Numeric(3, 2))  # 0.00 - 1.00
    
    # –ö–∞–Ω–∞–ª –∏ –∞–≤—Ç–æ—Ä
    channel_id = Column(BigInteger, nullable=False)
    trader_id = Column(Integer, ForeignKey('traders.id'), nullable=True)
    author = Column(String(100))
    
    # –ò—Å—Ö–æ–¥–Ω—ã–π —Ç–µ–∫—Å—Ç
    original_text = Column(Text, nullable=False)
    
    # –û—Å–Ω–æ–≤–Ω—ã–µ —Ç–æ—Ä–≥–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ
    ticker = Column(String(10), nullable=False, index=True)
    figi = Column(String(12), nullable=True)
    direction = Column(String(10))  # long, short, exit
    signal_type = Column(String(10))  # entry, exit, update
    
    # –¶–µ–Ω—ã
    target_price = Column(Numeric(12, 4))
    stop_loss = Column(Numeric(12, 4))
    take_profit = Column(Numeric(12, 4))
    entry_condition = Column(String(20))  # market, limit, not_above, not_below
    
    # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
    confidence_level = Column(String(10))  # high, medium, low
    timeframe = Column(String(10))  # 1h, 1d, 1w
    views = Column(Integer, default=0)
    
    # –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø–∞—Ä—Å–∏–Ω–≥–∞
    extracted_data = Column(JSONB)
    
    # Relationships
    raw_message = relationship("RawMessage", back_populates="parsed_signals")
    trader = relationship("Trader", back_populates="signals")
    signal_result = relationship("SignalResult", back_populates="signal", uselist=False)
    
    __table_args__ = (
        Index('idx_parsed_signals_ticker_timestamp', 'ticker', 'timestamp'),
        Index('idx_parsed_signals_author', 'author'),
        Index('idx_parsed_signals_direction', 'direction'),
        Index('idx_parsed_signals_channel_timestamp', 'channel_id', 'timestamp'),
    )

class Trader(Base):
    """–ü—Ä–æ—Ñ–∏–ª–∏ —Ç—Ä–µ–π–¥–µ—Ä–æ–≤ –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏"""
    __tablename__ = 'traders'
    
    id = Column(Integer, primary_key=True)
    name = Column(String(100), unique=True, nullable=False)
    telegram_username = Column(String(100))
    channel_id = Column(BigInteger, nullable=False)
    
    # –ú–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ
    is_active = Column(Boolean, default=True)
    first_signal_at = Column(DateTime(timezone=True))
    last_signal_at = Column(DateTime(timezone=True))
    total_signals = Column(Integer, default=0)
    
    # –ö–µ—à–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
    win_rate = Column(Numeric(5, 2))
    avg_profit_pct = Column(Numeric(8, 4))
    max_drawdown_pct = Column(Numeric(8, 4))
    sharpe_ratio = Column(Numeric(6, 3))
    
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    
    # Relationships
    signals = relationship("ParsedSignal", back_populates="trader")
    
    __table_args__ = (
        Index('idx_traders_name', 'name'),
        Index('idx_traders_active', 'is_active'),
    )

class SignalResult(Base):
    """–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è —Å–∏–≥–Ω–∞–ª–æ–≤"""
    __tablename__ = 'signal_results'
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    signal_id = Column(UUID(as_uuid=True), ForeignKey('parsed_signals.id'), nullable=False)
    
    # –¶–µ–Ω—ã –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è
    planned_entry_price = Column(Numeric(12, 4))
    actual_entry_price = Column(Numeric(12, 4))
    exit_price = Column(Numeric(12, 4))
    
    # –†–µ–∑—É–ª—å—Ç–∞—Ç—ã
    profit_loss_pct = Column(Numeric(8, 4))
    profit_loss_abs = Column(Numeric(12, 4))
    
    # –í—Ä–µ–º–µ–Ω–Ω—ã–µ –º–µ—Ç–∫–∏
    entry_time = Column(DateTime(timezone=True))
    exit_time = Column(DateTime(timezone=True))
    duration_minutes = Column(Integer)
    
    # –°—Ç–∞—Ç—É—Å –ø–æ–∑–∏—Ü–∏–∏
    status = Column(String(20), default='active')  # active, closed, stopped, expired
    exit_reason = Column(String(50))  # take_profit, stop_loss, manual, timeout
    
    # –ú–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è
    tracking_started_at = Column(DateTime(timezone=True), server_default=func.now())
    last_updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    
    # Relationships
    signal = relationship("ParsedSignal", back_populates="signal_result")
    
    __table_args__ = (
        Index('idx_signal_results_status', 'status'),
        Index('idx_signal_results_profit', 'profit_loss_pct'),
        Index('idx_signal_results_duration', 'duration_minutes'),
    )

class Instrument(Base):
    """–¢–æ—Ä–≥–æ–≤—ã–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã"""
    __tablename__ = 'instruments'
    
    figi = Column(String(12), primary_key=True)
    ticker = Column(String(10), unique=True, nullable=False)
    name = Column(String(200))
    type = Column(String(20))  # share, etf, bond, future, currency
    currency = Column(String(3))
    lot = Column(Integer, default=1)
    
    # –ú–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ
    is_active = Column(Boolean, default=True)
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    
    __table_args__ = (
        Index('idx_instruments_ticker', 'ticker'),
        Index('idx_instruments_type', 'type'),
    )

class Candle(Base):
    """–°–≤–µ—á–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ"""
    __tablename__ = 'candles'
    
    id = Column(BigInteger, primary_key=True, autoincrement=True)
    instrument_id = Column(String(12), ForeignKey('instruments.figi'), nullable=False)
    interval = Column(String(10), nullable=False)  # 1min, 5min, hour, day
    time = Column(DateTime(timezone=True), nullable=False)
    
    open = Column(Numeric(12, 4), nullable=False)
    high = Column(Numeric(12, 4), nullable=False)
    low = Column(Numeric(12, 4), nullable=False)
    close = Column(Numeric(12, 4), nullable=False)
    volume = Column(BigInteger, default=0)
    
    __table_args__ = (
        UniqueConstraint('instrument_id', 'interval', 'time', name='unique_candle'),
        Index('idx_candles_instrument_time', 'instrument_id', 'time'),
        Index('idx_candles_interval_time', 'interval', 'time'),
    )

================================================================================
File: tbot/core/database/migrations.py
================================================================================
# core/database/migrations.py
"""
–§—É–Ω–∫—Ü–∏–∏ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å—Ö–µ–º—ã –ë–î
"""
import logging
from sqlalchemy import MetaData
from .models import Base

logger = logging.getLogger(__name__)

def create_tables(engine):
    """
    –°–æ–∑–¥–∞—Ç—å –≤—Å–µ —Ç–∞–±–ª–∏—Ü—ã –≤ –ë–î
    
    Args:
        engine: SQLAlchemy engine
    """
    try:
        Base.metadata.create_all(engine)
        logger.info("‚úÖ All database tables created successfully")
        return True
        
    except Exception as e:
        logger.error(f"‚ùå Failed to create tables: {e}")
        return False

def drop_tables(engine):
    """
    –£–¥–∞–ª–∏—Ç—å –≤—Å–µ —Ç–∞–±–ª–∏—Ü—ã –∏–∑ –ë–î (–û–°–¢–û–†–û–ñ–ù–û!)
    
    Args:
        engine: SQLAlchemy engine
    """
    try:
        Base.metadata.drop_all(engine)
        logger.warning("‚ö†Ô∏è All database tables dropped")
        return True
        
    except Exception as e:
        logger.error(f"‚ùå Failed to drop tables: {e}")
        return False

def get_table_info(engine) -> dict:
    """
    –ü–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö —Ç–∞–±–ª–∏—Ü–∞—Ö
    
    Args:
        engine: SQLAlchemy engine
        
    Returns:
        dict: –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Ç–∞–±–ª–∏—Ü–∞—Ö
    """
    try:
        metadata = MetaData()
        metadata.reflect(bind=engine)
        
        tables_info = {}
        for table_name, table in metadata.tables.items():
            tables_info[table_name] = {
                'columns': len(table.columns),
                'indexes': len(table.indexes),
                'foreign_keys': len([fk for col in table.columns for fk in col.foreign_keys])
            }
        
        return tables_info
        
    except Exception as e:
        logger.error(f"‚ùå Failed to get table info: {e}")
        return {}

================================================================================
File: tbot/core/database/models.py
================================================================================
# core/models.py - –ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø –í–ï–†–°–ò–Ø
from sqlalchemy import (
    Column, String, BigInteger, Integer, Numeric, Text, 
    Boolean, DateTime, UniqueConstraint, Index, ForeignKey
)
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.dialects.postgresql import UUID, JSONB
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
import uuid
from datetime import datetime
from typing import Optional, Dict, Any
from dataclasses import dataclass
from enum import Enum

Base = declarative_base()

class SignalDirection(str, Enum):
    LONG = "long"
    SHORT = "short"
    EXIT = "exit"

class SignalStatus(str, Enum):
    ACTIVE = "active"
    CLOSED = "closed"
    STOPPED = "stopped"
    EXPIRED = "expired"

# ===== TELEGRAM DATA MODELS =====

class RawMessage(Base):
    """–°—ã—Ä—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è –∏–∑ Telegram"""
    __tablename__ = 'raw_messages'
    
    id = Column(BigInteger, primary_key=True, autoincrement=True)
    timestamp = Column(DateTime(timezone=True), nullable=False, index=True)
    channel_id = Column(BigInteger, nullable=False)  # –ë–µ–∑ foreign key - –ø—Ä–æ—Å—Ç–æ ID
    message_id = Column(BigInteger, nullable=False)
    
    # –ê–≤—Ç–æ—Ä —Å–æ–æ–±—â–µ–Ω–∏—è
    author_id = Column(BigInteger)
    author_username = Column(String(100))
    author_first_name = Column(String(100))
    
    # –°–æ–¥–µ—Ä–∂–∏–º–æ–µ —Å–æ–æ–±—â–µ–Ω–∏—è
    text = Column(Text)
    views = Column(Integer, default=0)
    forwards = Column(Integer, default=0)
    
    # –ú–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ
    edit_date = Column(DateTime(timezone=True))
    media_type = Column(String(50))
    reply_to_message_id = Column(BigInteger)
    raw_data = Column(JSONB)
    collected_at = Column(DateTime(timezone=True), server_default=func.now())
    
    # –°—Ç–∞—Ç—É—Å –æ–±—Ä–∞–±–æ—Ç–∫–∏
    is_processed = Column(Boolean, default=False)
    processing_attempts = Column(Integer, default=0)
    
    # Relationships - –¢–û–õ–¨–ö–û —Å parsed_signals
    parsed_signals = relationship("ParsedSignal", back_populates="raw_message")
    
    __table_args__ = (
        UniqueConstraint('channel_id', 'message_id', name='unique_channel_message'),
        Index('idx_raw_messages_channel_timestamp', 'channel_id', 'timestamp'),
        Index('idx_raw_messages_unprocessed', 'is_processed', 'timestamp'),
    )

class ParsedSignal(Base):
    """–†–∞—Å–ø–æ–∑–Ω–∞–Ω–Ω—ã–µ —Ç–æ—Ä–≥–æ–≤—ã–µ —Å–∏–≥–Ω–∞–ª—ã"""
    __tablename__ = 'parsed_signals'
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    raw_message_id = Column(BigInteger, ForeignKey('raw_messages.id'), nullable=True)
    
    # –í—Ä–µ–º–µ–Ω–Ω—ã–µ –º–µ—Ç–∫–∏
    timestamp = Column(DateTime(timezone=True), nullable=False, index=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    
    # –ú–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ –ø–∞—Ä—Å–∏–Ω–≥–∞
    parser_version = Column(String(20), nullable=False)
    confidence_score = Column(Numeric(3, 2))  # 0.00 - 1.00
    
    # –ö–∞–Ω–∞–ª –∏ –∞–≤—Ç–æ—Ä
    channel_id = Column(BigInteger, nullable=False)  # –ë–µ–∑ foreign key - –ø—Ä–æ—Å—Ç–æ ID
    trader_id = Column(Integer, ForeignKey('traders.id'), nullable=True)
    author = Column(String(100))  # –ò–º—è –∞–≤—Ç–æ—Ä–∞ –∏–∑ —Å–æ–æ–±—â–µ–Ω–∏—è
    
    # –ò—Å—Ö–æ–¥–Ω—ã–π —Ç–µ–∫—Å—Ç
    original_text = Column(Text, nullable=False)
    
    # –û—Å–Ω–æ–≤–Ω—ã–µ —Ç–æ—Ä–≥–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ
    ticker = Column(String(10), nullable=False, index=True)
    figi = Column(String(12), nullable=True)  # FIGI –¥–ª—è Tinkoff API
    direction = Column(String(10))  # long, short, exit
    signal_type = Column(String(10))  # entry, exit, update
    
    # –¶–µ–Ω—ã
    target_price = Column(Numeric(12, 4))
    stop_loss = Column(Numeric(12, 4))
    take_profit = Column(Numeric(12, 4))
    entry_condition = Column(String(20))  # market, limit, not_above, not_below
    
    # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
    confidence_level = Column(String(10))  # high, medium, low
    timeframe = Column(String(10))  # 1h, 1d, 1w
    views = Column(Integer, default=0)
    
    # –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø–∞—Ä—Å–∏–Ω–≥–∞
    extracted_data = Column(JSONB)
    
    # Relationships
    raw_message = relationship("RawMessage", back_populates="parsed_signals")
    trader = relationship("Trader", back_populates="signals")
    signal_result = relationship("SignalResult", back_populates="signal", uselist=False)
    
    __table_args__ = (
        Index('idx_parsed_signals_ticker_timestamp', 'ticker', 'timestamp'),
        Index('idx_parsed_signals_author', 'author'),
        Index('idx_parsed_signals_direction', 'direction'),
        Index('idx_parsed_signals_channel_timestamp', 'channel_id', 'timestamp'),
    )

# ===== TRADER TRACKING MODELS =====

class Trader(Base):
    """–ü—Ä–æ—Ñ–∏–ª–∏ —Ç—Ä–µ–π–¥–µ—Ä–æ–≤ –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏"""
    __tablename__ = 'traders'
    
    id = Column(Integer, primary_key=True)
    name = Column(String(100), unique=True, nullable=False)
    telegram_username = Column(String(100))
    channel_id = Column(BigInteger, nullable=False)  # –ë–µ–∑ foreign key - –ø—Ä–æ—Å—Ç–æ ID
    
    # –ú–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ
    is_active = Column(Boolean, default=True)
    first_signal_at = Column(DateTime(timezone=True))
    last_signal_at = Column(DateTime(timezone=True))
    total_signals = Column(Integer, default=0)
    
    # –ö–µ—à–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ (–æ–±–Ω–æ–≤–ª—è–µ—Ç—Å—è –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏)
    win_rate = Column(Numeric(5, 2))  # –ü—Ä–æ—Ü–µ–Ω—Ç –ø—Ä–∏–±—ã–ª—å–Ω—ã—Ö —Å–¥–µ–ª–æ–∫
    avg_profit_pct = Column(Numeric(8, 4))  # –°—Ä–µ–¥–Ω—è—è –ø—Ä–∏–±—ã–ª—å –≤ %
    max_drawdown_pct = Column(Numeric(8, 4))  # –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –ø—Ä–æ—Å–∞–¥–∫–∞ –≤ %
    sharpe_ratio = Column(Numeric(6, 3))
    
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    
    # Relationships - –ë–ï–ó channel
    signals = relationship("ParsedSignal", back_populates="trader")
    
    __table_args__ = (
        Index('idx_traders_name', 'name'),
        Index('idx_traders_active', 'is_active'),
    )

class SignalResult(Base):
    """–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è —Å–∏–≥–Ω–∞–ª–æ–≤"""
    __tablename__ = 'signal_results'
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    signal_id = Column(UUID(as_uuid=True), ForeignKey('parsed_signals.id'), nullable=False)
    
    # –¶–µ–Ω—ã –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è (—Ñ–∞–∫—Ç vs –ø–ª–∞–Ω)
    planned_entry_price = Column(Numeric(12, 4))  # –ó–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —Ü–µ–Ω–∞ –≤—Ö–æ–¥–∞
    actual_entry_price = Column(Numeric(12, 4))   # –§–∞–∫—Ç–∏—á–µ—Å–∫–∞—è —Ü–µ–Ω–∞ –≤—Ö–æ–¥–∞
    exit_price = Column(Numeric(12, 4))           # –¶–µ–Ω–∞ –≤—ã—Ö–æ–¥–∞
    
    # –†–µ–∑—É–ª—å—Ç–∞—Ç—ã
    profit_loss_pct = Column(Numeric(8, 4))       # P&L –≤ –ø—Ä–æ—Ü–µ–Ω—Ç–∞—Ö
    profit_loss_abs = Column(Numeric(12, 4))      # P&L –≤ –∞–±—Å–æ–ª—é—Ç–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏—è—Ö
    
    # –í—Ä–µ–º–µ–Ω–Ω—ã–µ –º–µ—Ç–∫–∏
    entry_time = Column(DateTime(timezone=True))   # –í—Ä–µ–º—è –≤—Ö–æ–¥–∞
    exit_time = Column(DateTime(timezone=True))    # –í—Ä–µ–º—è –≤—ã—Ö–æ–¥–∞
    duration_minutes = Column(Integer)             # –í—Ä–µ–º—è –≤ –ø–æ–∑–∏—Ü–∏–∏
    
    # –°—Ç–∞—Ç—É—Å –ø–æ–∑–∏—Ü–∏–∏
    status = Column(String(20), default='active') # active, closed, stopped, expired
    exit_reason = Column(String(50))               # take_profit, stop_loss, manual, timeout
    
    # –ú–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è
    tracking_started_at = Column(DateTime(timezone=True), server_default=func.now())
    last_updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    
    # Relationships
    signal = relationship("ParsedSignal", back_populates="signal_result")
    
    __table_args__ = (
        Index('idx_signal_results_status', 'status'),
        Index('idx_signal_results_profit', 'profit_loss_pct'),
        Index('idx_signal_results_duration', 'duration_minutes'),
    )

# ===== MARKET DATA MODELS =====

class Instrument(Base):
    """–ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã –¥–ª—è —Ç–æ—Ä–≥–æ–≤–ª–∏"""
    __tablename__ = 'instruments'
    
    figi = Column(String(12), primary_key=True)
    ticker = Column(String(10), unique=True, nullable=False)
    name = Column(String(200))
    type = Column(String(20))  # share, etf, bond, future, currency
    currency = Column(String(3))
    lot = Column(Integer, default=1)
    
    # –ú–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ
    is_active = Column(Boolean, default=True)
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    
    __table_args__ = (
        Index('idx_instruments_ticker', 'ticker'),
        Index('idx_instruments_type', 'type'),
    )

class Candle(Base):
    """–°–≤–µ—á–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ"""
    __tablename__ = 'candles'
    
    id = Column(BigInteger, primary_key=True, autoincrement=True)
    instrument_id = Column(String(12), ForeignKey('instruments.figi'), nullable=False)
    interval = Column(String(10), nullable=False)  # 1min, 5min, hour, day
    time = Column(DateTime(timezone=True), nullable=False)
    
    open = Column(Numeric(12, 4), nullable=False)
    high = Column(Numeric(12, 4), nullable=False)
    low = Column(Numeric(12, 4), nullable=False)
    close = Column(Numeric(12, 4), nullable=False)
    volume = Column(BigInteger, default=0)
    
    __table_args__ = (
        UniqueConstraint('instrument_id', 'interval', 'time', name='unique_candle'),
        Index('idx_candles_instrument_time', 'instrument_id', 'time'),
        Index('idx_candles_interval_time', 'interval', 'time'),
    )

# ===== DATACLASSES FOR API RESPONSES =====

@dataclass
class TraderStatsResponse:
    """–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Ç—Ä–µ–π–¥–µ—Ä–∞ –¥–ª—è API"""
    trader_name: str
    total_signals: int
    active_signals: int
    closed_signals: int
    win_rate: float
    avg_profit_pct: float
    max_drawdown_pct: float
    sharpe_ratio: Optional[float]
    first_signal: Optional[datetime]
    last_signal: Optional[datetime]

@dataclass
class SignalWithResult:
    """–°–∏–≥–Ω–∞–ª —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–º –¥–ª—è API"""
    signal_id: str
    timestamp: datetime
    trader: str
    ticker: str
    direction: str
    target_price: Optional[float]
    stop_loss: Optional[float]
    take_profit: Optional[float]
    
    # –†–µ–∑—É–ª—å—Ç–∞—Ç—ã (–µ—Å–ª–∏ –µ—Å—Ç—å)
    actual_entry_price: Optional[float] = None
    exit_price: Optional[float] = None
    profit_loss_pct: Optional[float] = None
    duration_minutes: Optional[int] = None
    status: str = 'active'
    exit_reason: Optional[str] = None

@dataclass
class ChartDataPoint:
    """–¢–æ—á–∫–∞ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –≥—Ä–∞—Ñ–∏–∫–∞"""
    timestamp: datetime
    price: float
    signal_type: Optional[str] = None  # 'entry_long', 'entry_short', 'exit'
    signal_id: Optional[str] = None
    trader: Optional[str] = None

================================================================================
File: tbot/api/app.py
================================================================================
# api/app.py
from fastapi import FastAPI, BackgroundTasks, HTTPException, Query, WebSocket, WebSocketDisconnect
from fastapi.middleware.cors import CORSMiddleware
from contextlib import asynccontextmanager
import logging
from typing import Optional, List, Dict
from datetime import datetime, timedelta
import asyncio
import os
from analysis.message_parser import MessageParser, MessageParsingService
from core.database import Database
from core.database.models import *
from analysis.signal_matcher import SignalMatcher
from integrations.tinkoff_integration import TinkoffIntegration
from integrations.historical_data_loader import HistoricalDataLoader
from utils.datetime_utils import now_utc, utc_from_days_ago, ensure_timezone_aware, days_between_utc
from sqlalchemy import func

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(name)s: %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S",
)
logger = logging.getLogger("trader_tracker_api")

# –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
db_manager: Database = None
message_parsing_service: MessageParsingService = None
signal_matcher: SignalMatcher = None
tinkoff_client: TinkoffIntegration = None
background_tasks_running = False
historical_data_loader: HistoricalDataLoader = None

def get_db_manager() -> Database:
    """–ü–æ–ª—É—á–µ–Ω–∏–µ —ç–∫–∑–µ–º–ø–ª—è—Ä–∞ Database"""
    if db_manager is None:
        raise HTTPException(status_code=503, detail="Database not initialized")
    return db_manager

@asynccontextmanager
async def lifespan(app: FastAPI):
    global signal_matcher, tinkoff_client, background_tasks_running, message_parsing_service, db_manager, historical_data_loader
    
    try:
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –ë–î
        database_url = os.getenv("DATABASE_URL", "postgresql://user:pass@localhost/trader_tracker")
        db_manager = Database(database_url)
        message_parsing_service = MessageParsingService(db_manager)
        logger.info("Database initialized successfully")
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º Tinkoff (–Ω–µ –∫—Ä–∏—Ç–∏—á–Ω–æ)
        tinkoff_token = os.getenv("TINKOFF_TOKEN")
        if tinkoff_token:
            try:
                tinkoff_client = TinkoffIntegration(tinkoff_token)
                await tinkoff_client.initialize()
                logger.info("Tinkoff client initialized")
            except Exception as e:
                logger.warning(f"Tinkoff integration failed (will work in mock mode): {e}")
                tinkoff_client = None
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è matcher'–∞
        signal_matcher = SignalMatcher(db_manager, tinkoff_client)
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è historical data loader
        if tinkoff_client:
            historical_data_loader = HistoricalDataLoader(db_manager, tinkoff_client)
        
        # –ó–∞–ø—É—Å–∫ —Ñ–æ–Ω–æ–≤—ã—Ö –∑–∞–¥–∞—á
        background_tasks_running = True
        asyncio.create_task(background_signal_processing())
        
        logger.info("Application initialized successfully")
        yield
        
    except Exception as e:
        logger.error(f"Failed to initialize application: {e}")
        raise
    finally:
        # –û—á–∏—Å—Ç–∫–∞ –ø—Ä–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏
        background_tasks_running = False
        if tinkoff_client:
            await tinkoff_client.close()
        logger.info("Application shutdown completed")
        
# –°–æ–∑–¥–∞–Ω–∏–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
app = FastAPI(
    title="Trader Tracker Demo",
    description="API for tracking telegram trading signals performance",
    version="1.0.0",
    lifespan=lifespan
)

# CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# WebSocket connections
websocket_connections: Dict[str, WebSocket] = {}

# ===== BACKGROUND TASKS =====

async def background_signal_processing():
    """–§–æ–Ω–æ–≤–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ —Å–∏–≥–Ω–∞–ª–æ–≤"""
    global background_tasks_running, signal_matcher
    
    while background_tasks_running:
        try:
            if signal_matcher:
                # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –Ω–æ–≤—ã–µ —Å–∏–≥–Ω–∞–ª—ã
                new_tracked = await signal_matcher.process_untracked_signals(limit=20)
                if new_tracked > 0:
                    logger.info(f"Started tracking {new_tracked} new signals")
                
                # –û–±–Ω–æ–≤–ª—è–µ–º –∞–∫—Ç–∏–≤–Ω—ã–µ –ø–æ–∑–∏—Ü–∏–∏
                updated = await signal_matcher.update_active_positions()
                if updated > 0:
                    logger.info(f"Updated {updated} active positions")
            
            # –ü–∞—É–∑–∞ –º–µ–∂–¥—É –æ–±—Ä–∞–±–æ—Ç–∫–∞–º–∏
            await asyncio.sleep(60)  # –ö–∞–∂–¥—É—é –º–∏–Ω—É—Ç—É
            
        except Exception as e:
            logger.error(f"Error in background processing: {e}")
            await asyncio.sleep(300)  # –ü—Ä–∏ –æ—à–∏–±–∫–µ –∂–¥–µ–º 5 –º–∏–Ω—É—Ç

# ===== API ENDPOINTS =====

@app.get("/")
async def root():
    """–ö–æ—Ä–Ω–µ–≤–æ–π endpoint"""
    return {
        "service": "Trader Tracker Demo",
        "version": "1.0.0",
        "status": "running",
        "timestamp": datetime.now().isoformat()
    }

@app.get("/api/health")
async def health_check():
    """–ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–¥–æ—Ä–æ–≤—å—è —Å–µ—Ä–≤–∏—Å–∞"""
    try:
        db = get_db_manager()
        health = db.health_check()
        
        return {
            "status": "healthy",
            "database": health.get('status', 'unknown'),
            "tinkoff": "connected" if tinkoff_client else "not_configured",
            "timestamp": datetime.now().isoformat()
        }
    except Exception as e:
        logger.error(f"Health check failed: {e}")
        raise HTTPException(status_code=503, detail="Service unavailable")

@app.get("/api/statistics")
async def get_system_statistics():
    """–û–±—â–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Å–∏—Å—Ç–µ–º—ã"""
    try:
        db = get_db_manager()
        stats = db.get_statistics()
        return stats
    except Exception as e:
        logger.error(f"Failed to get statistics: {e}")
        raise HTTPException(status_code=500, detail=str(e))

# ===== TRADER ENDPOINTS =====

@app.get("/api/traders")
async def get_all_traders():
    """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –≤—Å–µ—Ö —Ç—Ä–µ–π–¥–µ—Ä–æ–≤"""
    try:
        db = get_db_manager()
        traders = db.get_all_traders()
        return traders
    except Exception as e:
        logger.error(f"Failed to get traders: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/traders/{trader_id}")
async def get_trader_stats(trader_id: int):
    """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ —Ç—Ä–µ–π–¥–µ—Ä–∞"""
    try:
        db = get_db_manager()
        stats = db.get_trader_stats(trader_id)
        
        if not stats:
            raise HTTPException(status_code=404, detail="Trader not found")
        
        return stats
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to get trader stats: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/traders/{trader_id}/signals")
async def get_trader_signals(
    trader_id: int,
    ticker: Optional[str] = Query(None, description="Filter by ticker"),
    limit: int = Query(100, description="Maximum number of signals")
):
    """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å–∏–≥–Ω–∞–ª–æ–≤ —Ç—Ä–µ–π–¥–µ—Ä–∞"""
    try:
        db = get_db_manager()
        signals = db.get_signals(trader_id=trader_id, ticker=ticker, limit=limit)
        return signals
    except Exception as e:
        logger.error(f"Failed to get trader signals: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/tickers")
async def get_available_tickers():
    """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Ç–∏–∫–µ—Ä–æ–≤"""
    try:
        db = get_db_manager()
        
        with db.session() as session:
            tickers = session.query(ParsedSignal.ticker).distinct().all()
            
            # –ü–æ–¥—Å—á–∏—Ç—ã–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–∏–≥–Ω–∞–ª–æ–≤ –ø–æ –∫–∞–∂–¥–æ–º—É —Ç–∏–∫–µ—Ä—É
            ticker_stats = []
            for (ticker,) in tickers:
                signal_count = session.query(ParsedSignal).filter(
                    ParsedSignal.ticker == ticker
                ).count()
                
                ticker_stats.append({
                    'ticker': ticker,
                    'signal_count': signal_count
                })
            
            # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤—É —Å–∏–≥–Ω–∞–ª–æ–≤
            ticker_stats.sort(key=lambda x: x['signal_count'], reverse=True)
            
            return ticker_stats
    except Exception as e:
        logger.error(f"Failed to get tickers: {e}")
        raise HTTPException(status_code=500, detail=str(e))

# ===== SIGNAL PROCESSING ENDPOINTS =====

@app.post("/api/signals/process")
async def trigger_signal_processing(background_tasks: BackgroundTasks):
    """–†—É—á–Ω–æ–π –∑–∞–ø—É—Å–∫ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–∏–≥–Ω–∞–ª–æ–≤"""
    try:
        if not signal_matcher:
            raise HTTPException(status_code=503, detail="Signal matcher not initialized")
        
        background_tasks.add_task(manual_signal_processing)
        
        return {
            "status": "processing_started",
            "message": "Signal processing started in background",
            "timestamp": datetime.now().isoformat()
        }
    except Exception as e:
        logger.error(f"Failed to trigger signal processing: {e}")
        raise HTTPException(status_code=500, detail=str(e))

async def manual_signal_processing():
    """–†—É—á–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ —Å–∏–≥–Ω–∞–ª–æ–≤"""
    global signal_matcher
    try:
        # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –Ω–æ–≤—ã–µ —Å–∏–≥–Ω–∞–ª—ã
        new_tracked = await signal_matcher.process_untracked_signals(limit=50)
        
        # –û–±–Ω–æ–≤–ª—è–µ–º –∞–∫—Ç–∏–≤–Ω—ã–µ –ø–æ–∑–∏—Ü–∏–∏
        updated = await signal_matcher.update_active_positions()
        
        logger.info(f"Manual processing completed: {new_tracked} new, {updated} updated")
        
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —á–µ—Ä–µ–∑ WebSocket
        await broadcast_processing_update({
            'type': 'processing_complete',
            'new_tracked': new_tracked,
            'updated': updated,
            'timestamp': datetime.now().isoformat()
        })
        
    except Exception as e:
        logger.error(f"Manual signal processing failed: {e}")

@app.get("/api/signals/active")
async def get_active_signals():
    """–ü–æ–ª—É—á–µ–Ω–∏–µ –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤"""
    try:
        db = get_db_manager()
        active_signals = db.get_active_signals()
        
        return {
            'count': len(active_signals),
            'signals': active_signals
        }
            
    except Exception as e:
        logger.error(f"Failed to get active signals: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/signals/recent")
async def get_recent_signals(
    hours: int = Query(24, description="Hours to look back"),
    limit: int = Query(50, description="Maximum number of signals")
):
    """–ü–æ–ª—É—á–µ–Ω–∏–µ –Ω–µ–¥–∞–≤–Ω–∏—Ö —Å–∏–≥–Ω–∞–ª–æ–≤"""
    try:
        db = get_db_manager()
        
        since_time = datetime.now() - timedelta(hours=hours)
        signals = db.get_signals(from_date=since_time, limit=limit)
        
        return {
            'period_hours': hours,
            'count': len(signals),
            'signals': signals
        }
            
    except Exception as e:
        logger.error(f"Failed to get recent signals: {e}")
        raise HTTPException(status_code=500, detail=str(e))

# ===== WEBSOCKET ENDPOINTS =====

@app.websocket("/ws/updates")
async def websocket_endpoint(websocket: WebSocket):
    """WebSocket –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏"""
    await websocket.accept()
    
    client_id = f"client_{len(websocket_connections)}"
    websocket_connections[client_id] = websocket
    
    try:
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–µ
        await websocket.send_json({
            'type': 'connection_established',
            'client_id': client_id,
            'timestamp': datetime.now().isoformat()
        })
        
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ç–µ–∫—É—â—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
        db = get_db_manager()
        stats = db.get_statistics()
        await websocket.send_json({
            'type': 'statistics_update',
            'data': stats,
            'timestamp': datetime.now().isoformat()
        })
        
        # –û–∂–∏–¥–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏—è –æ—Ç –∫–ª–∏–µ–Ω—Ç–∞
        while True:
            data = await websocket.receive_text()
            # –≠—Ö–æ –¥–ª—è –ø–æ–¥–¥–µ—Ä–∂–∞–Ω–∏—è —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
            await websocket.send_json({
                'type': 'echo',
                'message': data,
                'timestamp': datetime.now().isoformat()
            })
            
    except WebSocketDisconnect:
        logger.info(f"WebSocket client {client_id} disconnected")
    except Exception as e:
        logger.error(f"WebSocket error for {client_id}: {e}")
    finally:
        if client_id in websocket_connections:
            del websocket_connections[client_id]

async def broadcast_processing_update(data: Dict):
    """–†–∞—Å—Å—ã–ª–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π –≤—Å–µ–º –ø–æ–¥–∫–ª—é—á–µ–Ω–Ω—ã–º WebSocket –∫–ª–∏–µ–Ω—Ç–∞–º"""
    if not websocket_connections:
        return
    
    disconnected = []
    for client_id, websocket in websocket_connections.items():
        try:
            await websocket.send_json(data)
        except Exception as e:
            logger.error(f"Failed to send update to {client_id}: {e}")
            disconnected.append(client_id)
    
    # –£–¥–∞–ª—è–µ–º –æ—Ç–∫–ª—é—á–µ–Ω–Ω—ã—Ö –∫–ª–∏–µ–Ω—Ç–æ–≤
    for client_id in disconnected:
        del websocket_connections[client_id]

# ===== MARKET DATA ENDPOINTS =====

@app.get("/api/market/{ticker}/price")
async def get_current_price(ticker: str):
    """–ü–æ–ª—É—á–µ–Ω–∏–µ —Ç–µ–∫—É—â–µ–π —Ü–µ–Ω—ã –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞"""
    try:
        if not tinkoff_client:
            raise HTTPException(status_code=503, detail="Tinkoff client not configured")
        
        price_data = await tinkoff_client.get_current_price(ticker)
        
        if not price_data:
            raise HTTPException(status_code=404, detail=f"Price not found for {ticker}")
        
        return price_data
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to get current price: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/market/{ticker}/candles")
async def get_candles(
    ticker: str,
    interval: str = Query("hour", description="Candle interval"),
    days: int = Query(7, description="Number of days")
):
    """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å–≤–µ—á–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö"""
    try:
        db = get_db_manager()
        
        # –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç
        instrument = db.get_instrument_by_ticker(ticker)
        if not instrument:
            raise HTTPException(status_code=404, detail=f"Instrument not found: {ticker}")
        
        # –ü–æ–ª—É—á–∞–µ–º —Å–≤–µ—á–∏
        end_time = datetime.now()
        start_time = end_time - timedelta(days=days)
        
        candles = db.get_candles(
            figi=instrument['figi'],
            interval=interval,
            from_time=start_time,
            to_time=end_time,
            limit=days * 24 if interval == 'hour' else days * 1440
        )
        
        return {
            'ticker': ticker,
            'interval': interval,
            'period_days': days,
            'count': len(candles),
            'candles': candles
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to get candles: {e}")
        raise HTTPException(status_code=500, detail=str(e))

# ===== MESSAGE PARSING ENDPOINTS =====

@app.post("/api/messages/parse")
async def parse_raw_messages(
    background_tasks: BackgroundTasks,
    limit: Optional[int] = Query(None, description="Limit number of messages to process")
):
    """–ó–∞–ø—É—Å–∫ –ø–∞—Ä—Å–∏–Ω–≥–∞ raw —Å–æ–æ–±—â–µ–Ω–∏–π –≤ parsed_signals"""
    try:
        if not message_parsing_service:
            raise HTTPException(status_code=503, detail="Message parsing service not initialized")
        
        # –ó–∞–ø—É—Å–∫–∞–µ–º –ø–∞—Ä—Å–∏–Ω–≥ –≤ —Ñ–æ–Ω–µ
        background_tasks.add_task(run_message_parsing, limit)
        
        return {
            "status": "parsing_started",
            "message": f"Message parsing started in background{f' (limit: {limit})' if limit else ''}",
            "timestamp": datetime.now().isoformat()
        }
        
    except Exception as e:
        logger.error(f"Failed to start message parsing: {e}")
        raise HTTPException(status_code=500, detail=str(e))

async def run_message_parsing(limit: Optional[int] = None):
    """–§–æ–Ω–æ–≤–∞—è –∑–∞–¥–∞—á–∞ –¥–ª—è –ø–∞—Ä—Å–∏–Ω–≥–∞ —Å–æ–æ–±—â–µ–Ω–∏–π"""
    global message_parsing_service
    try:
        logger.info(f"Starting message parsing with limit: {limit}")
        stats = message_parsing_service.parse_all_unprocessed_messages(limit)
        
        logger.info(f"Message parsing completed: {stats}")
        
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —á–µ—Ä–µ–∑ WebSocket
        await broadcast_processing_update({
            'type': 'message_parsing_complete',
            'stats': stats,
            'timestamp': datetime.now().isoformat()
        })
        
    except Exception as e:
        logger.error(f"Message parsing failed: {e}")

@app.get("/api/messages/parsing-status")
async def get_parsing_status():
    """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ —Å–æ–æ–±—â–µ–Ω–∏–π"""
    try:
        db = get_db_manager()
        
        with db.session() as session:
            # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ raw —Å–æ–æ–±—â–µ–Ω–∏–π
            total_raw = session.query(RawMessage).count()
            processed_raw = session.query(RawMessage).filter(
                RawMessage.is_processed == True
            ).count()
            unprocessed_raw = total_raw - processed_raw
            
            # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ parsed —Å–∏–≥–Ω–∞–ª–æ–≤
            total_parsed = session.query(ParsedSignal).count()
            
            # –ü–æ—Å–ª–µ–¥–Ω–∏–µ –ø–∞—Ä—Å–∏–Ω–≥–∏
            recent_parsed = session.query(ParsedSignal).order_by(
                ParsedSignal.created_at.desc()
            ).limit(5).all()
            
            recent_signals = [
                {
                    'id': str(signal.id),
                    'ticker': signal.ticker,
                    'direction': signal.direction,
                    'author': signal.author,
                    'confidence': float(signal.confidence_score) if signal.confidence_score else 0.0,
                    'created_at': signal.created_at.isoformat()
                }
                for signal in recent_parsed
            ]
            
            return {
                'raw_messages': {
                    'total': total_raw,
                    'processed': processed_raw,
                    'unprocessed': unprocessed_raw,
                    'processing_rate': round((processed_raw / total_raw * 100), 2) if total_raw > 0 else 0
                },
                'parsed_signals': {
                    'total': total_parsed,
                    'recent': recent_signals
                },
                'timestamp': datetime.now().isoformat()
            }
            
    except Exception as e:
        logger.error(f"Failed to get parsing status: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/messages/sample/{message_id}")
async def parse_single_message(message_id: int):
    """–¢–µ—Å—Ç–æ–≤—ã–π –ø–∞—Ä—Å–∏–Ω–≥ –æ–¥–Ω–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è"""
    try:
        db = get_db_manager()
        
        with db.session() as session:
            raw_message = session.query(RawMessage).filter(
                RawMessage.id == message_id
            ).first()
            
            if not raw_message:
                raise HTTPException(status_code=404, detail="Message not found")
            
            # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ –Ω—É–∂–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç
            message_dict = {
                'id': raw_message.id,
                'text': raw_message.text,
                'timestamp': raw_message.timestamp,
                'channel_id': raw_message.channel_id,
                'author': raw_message.author,
                'message_id': raw_message.message_id
            }
            
            # –ü–∞—Ä—Å–∏–º —Å–æ–æ–±—â–µ–Ω–∏–µ
            parser = MessageParser()
            result = parser.parse_raw_message(message_dict)
            
            response = {
                'message_id': message_id,
                'original_text': raw_message.text,
                'parsing_result': {
                    'success': result.success,
                    'confidence': result.confidence,
                    'error': result.error
                }
            }
            
            if result.success and result.signal_data:
                response['extracted_data'] = {
                    'ticker': result.signal_data.get('ticker'),
                    'direction': result.signal_data.get('direction'),
                    'author': result.signal_data.get('author'),
                    'target_price': result.signal_data.get('target_price'),
                    'signal_type': result.signal_data.get('signal_type'),
                    'extracted_details': result.signal_data.get('extracted_data')
                }
            
            return response
            
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to parse single message: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/messages/unparsed")
async def get_unparsed_messages(
    limit: int = Query(20, description="Maximum number of messages"),
    sample_text_length: int = Query(200, description="Max length of text sample")
):
    """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –Ω–µ—Ä–∞–∑–æ–±—Ä–∞–Ω–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π"""
    try:
        db = get_db_manager()
        
        messages = db.get_messages(is_processed=False, limit=limit)
        
        # –û–±—Ä–µ–∑–∞–µ–º —Ç–µ–∫—Å—Ç –¥–ª—è –ø—Ä–µ–≤—å—é
        for msg in messages:
            if len(msg['text']) > sample_text_length:
                msg['text_sample'] = msg['text'][:sample_text_length] + '...'
            else:
                msg['text_sample'] = msg['text']
            msg['text_length'] = len(msg['text'])
        
        return {
            'count': len(messages),
            'messages': messages
        }
            
    except Exception as e:
        logger.error(f"Failed to get unparsed messages: {e}")
        raise HTTPException(status_code=500, detail=str(e))

# ===== TINKOFF ENDPOINTS =====

@app.get("/api/tinkoff/test-connection")
async def test_tinkoff_connection():
    """–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ Tinkoff API"""
    try:
        if not tinkoff_client:
            raise HTTPException(status_code=503, detail="Tinkoff client not initialized")
        
        result = await tinkoff_client.test_connection()
        
        if result["success"]:
            return {
                **result,
                "message": "Tinkoff API connection successful"
            }
        else:
            raise HTTPException(status_code=503, detail=f"Tinkoff API connection failed: {result['error']}")
            
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Tinkoff connection test failed: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/tinkoff/search/{ticker}")
async def search_instrument(ticker: str):
    """–ü–æ–∏—Å–∫ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞ –ø–æ —Ç–∏–∫–µ—Ä—É"""
    try:
        if not tinkoff_client:
            raise HTTPException(status_code=503, detail="Tinkoff client not initialized")
        
        instrument = await tinkoff_client.find_instrument_by_ticker(ticker)
        
        if instrument:
            return {
                "found": True,
                "instrument": instrument,
                "timestamp": now_utc().isoformat()  # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û
            }
        else:
            raise HTTPException(status_code=404, detail=f"Instrument {ticker} not found")
            
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Instrument search failed for {ticker}: {e}")
        raise HTTPException(status_code=500, detail=str(e))
# ===== HISTORICAL DATA ENDPOINTS =====

@app.post("/api/data/sync-instruments")
async def sync_instruments_to_database():
    """–°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤ –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö"""
    try:
        if not historical_data_loader:
            raise HTTPException(status_code=503, detail="Historical data loader not initialized")
        
        synced_count = await historical_data_loader.sync_instruments_to_database()
        
        return {
            "success": True,
            "synced_instruments": synced_count,
            "message": f"Synced {synced_count} instruments to database",
            "timestamp": now_utc().isoformat()  # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û
        }
        
    except Exception as e:
        logger.error(f"Instruments sync failed: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/api/data/load-historical/{ticker}")
async def load_historical_candles(
    ticker: str,
    interval: str = Query("5min", description="Candle interval"),
    days_back: int = Query(30, description="Days back to load"),
    force_reload: bool = Query(False, description="Force reload existing data")
):
    """–ó–∞–≥—Ä—É–∑–∫–∞ –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏—Ö —Å–≤–µ—á–µ–π –¥–ª—è —Ç–∏–∫–µ—Ä–∞"""
    try:
        if not historical_data_loader:
            raise HTTPException(status_code=503, detail="Historical data loader not initialized")
        
        if interval not in ["1min", "5min", "hour", "day"]:
            raise HTTPException(status_code=400, detail="Invalid interval. Use: 1min, 5min, hour, day")
        
        if days_back < 1 or days_back > 365:
            raise HTTPException(status_code=400, detail="days_back must be between 1 and 365")
        
        result = await historical_data_loader.load_historical_candles(
            ticker=ticker,
            interval=interval,
            days_back=days_back,
            force_reload=force_reload
        )
        
        if result["success"]:
            return result
        else:
            raise HTTPException(status_code=400, detail=result["error"])
            
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Historical data loading failed: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/data/status")
async def get_data_status():
    """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏—Ö –¥–∞–Ω–Ω—ã—Ö"""
    try:
        if not historical_data_loader:
            raise HTTPException(status_code=503, detail="Historical data loader not initialized")
        
        status = await historical_data_loader.get_data_status()
        
        if "error" in status:
            raise HTTPException(status_code=500, detail=status["error"])
        
        return status
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Data status request failed: {e}")
        raise HTTPException(status_code=500, detail=str(e))

# ===== UTILITY ENDPOINTS =====

@app.get("/api/debug/raw_messages")
async def get_raw_messages_sample(limit: int = Query(10, description="Number of messages")):
    """Debug endpoint –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ —Å—ã—Ä—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π"""
    try:
        db = get_db_manager()
        messages = db.get_messages(limit=limit)
        
        return [
            {
                'id': msg['id'],
                'timestamp': msg['timestamp'].isoformat() if isinstance(msg['timestamp'], datetime) else msg['timestamp'],
                'channel_id': msg['channel_id'],
                'author': msg['author'],
                'text': msg['text'][:200] + '...' if len(msg['text']) > 200 else msg['text'],
                'is_processed': msg['is_processed']
            }
            for msg in messages
        ]
            
    except Exception as e:
        logger.error(f"Failed to get raw messages: {e}")
        raise HTTPException(status_code=500, detail=str(e))

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(
        "app:app",
        host="0.0.0.0",
        port=8000,
        reload=True,
        log_level="info"
    )

@app.get("/api/candles/{ticker}")
async def get_candles_data(
    ticker: str,
    days: int = Query(30, description="Number of days back (1-365)"),
    # ‚úÖ –£–ë–†–ê–õ–ò limit –ø–∞—Ä–∞–º–µ—Ç—Ä –ø–æ–ª–Ω–æ—Å—Ç—å—é! –í–æ–∑–≤—Ä–∞—â–∞–µ–º –í–°–ï —Å–≤–µ—á–∏
):
    """–ü–æ–ª—É—á–µ–Ω–∏–µ 5-–º–∏–Ω—É—Ç–Ω—ã—Ö —Å–≤–µ—á–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —Ç–∏–∫–µ—Ä–∞ - –ë–ï–ó –õ–ò–ú–ò–¢–û–í!"""
    try:
        # –í–∞–ª–∏–¥–∞—Ü–∏—è –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
        if days < 1 or days > 365:
            raise HTTPException(
                status_code=400, 
                detail="Days must be between 1 and 365"
            )
        
        # üîç –î–ò–ê–ì–ù–û–°–¢–ò–ö–ê: –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç
        db = get_db_manager()
        instrument = db.get_instrument_by_ticker(ticker.upper())
        
        if not instrument:
            raise HTTPException(
                status_code=404,
                detail=f"Instrument {ticker} not found. Available instruments: {[t['ticker'] for t in db.get_available_tickers()]}"
            )
        
        logger.info(f"üìä Found instrument: {instrument['figi']} for {ticker}")
        
        # –ü–æ–ª—É—á–∞–µ–º —Å–≤–µ—á–∏ - –ë–ï–ó –õ–ò–ú–ò–¢–ê!
        end_time = datetime.now()
        start_time = end_time - timedelta(days=days)
        
        # ‚úÖ –£–ë–†–ê–õ–ò limit –ø–∞—Ä–∞–º–µ—Ç—Ä - –ø–æ–ª—É—á–∞–µ–º –í–°–ï –¥–æ—Å—Ç—É–ø–Ω—ã–µ —Å–≤–µ—á–∏!
        candles = db.get_candles(
            figi=instrument['figi'],
            interval='5min',
            from_time=start_time,
            to_time=end_time
            # limit=–ù–ï–¢! –£–±—Ä–∞–ª–∏ –ª–∏–º–∏—Ç
        )
        
        logger.info(f"üìà Found {len(candles)} candles in database for {ticker}")
        
        return {
            'ticker': ticker,
            'interval': '5min',
            'period_days': days,
            'count': len(candles),
            'candles': candles,
            'instrument': {
                'figi': instrument['figi'],
                'name': instrument['name'],
                'currency': instrument['currency']
            }
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to get candles: {e}")
        raise HTTPException(status_code=500, detail=str(e))
# ===== –≠–ù–î–ü–û–ò–ù–¢–´ –î–õ–Ø –°–ò–ì–ù–ê–õ–û–í =====

@app.get("/api/signals/trader/{trader}")
async def get_signals_by_trader(
    trader: str,
    days: int = Query(30, description="Days back to search"),
    limit: int = Query(100, description="Maximum signals to return")
):
    """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å–∏–≥–Ω–∞–ª–æ–≤ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ —Ç—Ä–µ–π–¥–µ—Ä–∞"""
    try:
        if days < 1 or days > 365:
            raise HTTPException(status_code=400, detail="Days must be between 1 and 365")
        
        db = get_db_manager()
        from_date = datetime.now() - timedelta(days=days)
        
        # –ü–æ–ª—É—á–∞–µ–º —Å–∏–≥–Ω–∞–ª—ã –ø–æ –∞–≤—Ç–æ—Ä—É (trader name)
        signals = db.get_signals(
            trader_id=None,  # –ü–æ ID –Ω–µ —Ñ–∏–ª—å—Ç—Ä—É–µ–º
            from_date=from_date,
            limit=limit * 2  # –ë–µ—Ä–µ–º –±–æ–ª—å—à–µ –¥–ª—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏
        )
        
        # –§–∏–ª—å—Ç—Ä—É–µ–º –ø–æ –∏–º–µ–Ω–∏ —Ç—Ä–µ–π–¥–µ—Ä–∞
        trader_signals = [
            s for s in signals 
            if s.get('author', '').lower() == trader.lower()
        ][:limit]
        
        return {
            "trader": trader,
            "period_days": days,
            "count": len(trader_signals),
            "signals": [
                {
                    "id": signal["id"],
                    "timestamp": signal["timestamp"].isoformat() if hasattr(signal["timestamp"], 'isoformat') else signal["timestamp"],
                    "ticker": signal["ticker"],
                    "direction": signal["direction"],  # long/short (–ø–æ–∫—É–ø–∫–∞/–ø—Ä–æ–¥–∞–∂–∞)
                    "signal_type": signal.get("signal_type"),
                    "target_price": signal.get("target_price"),
                    "confidence_score": signal.get("confidence_score"),
                    "original_text": signal.get("original_text", "")[:200] + "..." if len(signal.get("original_text", "")) > 200 else signal.get("original_text", "")
                }
                for signal in trader_signals
            ]
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error getting signals for trader {trader}: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/api/signals/ticker/{ticker}")
async def get_signals_by_ticker(
    ticker: str,
    days: int = Query(30, description="Days back"),
    limit: int = Query(50, description="Max signals")
):
    """–ü–æ–ª—É—á–µ–Ω–∏–µ –≤—Å–µ—Ö —Å–∏–≥–Ω–∞–ª–æ–≤ –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ —Ç–∏–∫–µ—Ä–∞"""
    try:
        if days < 1 or days > 365:
            raise HTTPException(status_code=400, detail="Days must be between 1 and 365")
            
        db = get_db_manager()
        from_date = datetime.now() - timedelta(days=days)
        
        signals = db.get_signals(
            ticker=ticker.upper(),
            from_date=from_date,
            limit=limit
        )
        
        return {
            "ticker": ticker.upper(),
            "period_days": days,
            "count": len(signals),
            "signals": [
                {
                    "id": signal["id"],
                    "timestamp": signal["timestamp"].isoformat() if hasattr(signal["timestamp"], 'isoformat') else signal["timestamp"],
                    "trader": signal.get("author"),
                    "direction": signal["direction"],  # long/short (–ø–æ–∫—É–ø–∫–∞/–ø—Ä–æ–¥–∞–∂–∞)
                    "signal_type": signal.get("signal_type"),
                    "target_price": signal.get("target_price"),
                    "confidence_score": signal.get("confidence_score"),
                    "original_text": signal.get("original_text", "")[:200] + "..." if len(signal.get("original_text", "")) > 200 else signal.get("original_text", "")
                }
                for signal in signals
            ]
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error getting signals for ticker {ticker}: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/api/signals/trader-ticker")
async def get_signals_by_trader_and_ticker(
    trader: str = Query(..., description="Trader name"),
    ticker: str = Query(..., description="Ticker symbol"),
    days: int = Query(30, description="Days back"),
    limit: int = Query(50, description="Max signals")
):
    """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å–∏–≥–Ω–∞–ª–æ–≤ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ —Ç—Ä–µ–π–¥–µ—Ä–∞ –ø–æ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–º—É —Ç–∏–∫–µ—Ä—É"""
    try:
        if days < 1 or days > 365:
            raise HTTPException(status_code=400, detail="Days must be between 1 and 365")
            
        db = get_db_manager()
        from_date = datetime.now() - timedelta(days=days)
        
        # –ü–æ–ª—É—á–∞–µ–º —Å–∏–≥–Ω–∞–ª—ã –ø–æ —Ç–∏–∫–µ—Ä—É
        signals = db.get_signals(
            ticker=ticker.upper(),
            from_date=from_date,
            limit=limit * 3  # –ë–µ—Ä–µ–º –±–æ–ª—å—à–µ –¥–ª—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ –ø–æ —Ç—Ä–µ–π–¥–µ—Ä—É
        )
        
        # –§–∏–ª—å—Ç—Ä—É–µ–º –ø–æ —Ç—Ä–µ–π–¥–µ—Ä—É
        filtered_signals = [
            s for s in signals 
            if s.get('author', '').lower() == trader.lower()
        ][:limit]
        
        return {
            "trader": trader,
            "ticker": ticker.upper(),
            "period_days": days,
            "count": len(filtered_signals),
            "signals": [
                {
                    "id": signal["id"],
                    "timestamp": signal["timestamp"].isoformat() if hasattr(signal["timestamp"], 'isoformat') else signal["timestamp"],
                    "direction": signal["direction"],  # long/short (–ø–æ–∫—É–ø–∫–∞/–ø—Ä–æ–¥–∞–∂–∞)
                    "signal_type": signal.get("signal_type"),
                    "target_price": signal.get("target_price"),
                    "confidence_score": signal.get("confidence_score"),
                    "original_text": signal.get("original_text", "")[:200] + "..." if len(signal.get("original_text", "")) > 200 else signal.get("original_text", "")
                }
                for signal in filtered_signals
            ]
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error getting signals for trader {trader} and ticker {ticker}: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/debug/database-content")
async def debug_database_content():
    """–î–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞ —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö"""
    try:
        db = get_db_manager()
        
        with db.session() as session:
            from core.database.models import Instrument, Candle
            from sqlalchemy import func, desc
            
            # 1. –ü—Ä–æ–≤–µ—Ä—è–µ–º –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã
            instruments = session.query(Instrument).all()
            instruments_info = [
                {
                    "figi": inst.figi,
                    "ticker": inst.ticker, 
                    "name": inst.name,
                    "type": inst.type
                }
                for inst in instruments[:10]  # –ü–µ—Ä–≤—ã–µ 10
            ]
            
            # 2. –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–≤–µ—á–∏ - –æ–±—â–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
            candles_stats = session.query(
                Candle.instrument_id,
                Candle.interval,
                func.count(Candle.id).label('count'),
                func.min(Candle.time).label('first_time'),
                func.max(Candle.time).label('last_time')
            ).group_by(
                Candle.instrument_id, Candle.interval
            ).all()
            
            candles_info = [
                {
                    "instrument_id": stat.instrument_id,
                    "interval": stat.interval,
                    "count": stat.count,
                    "first_time": stat.first_time.isoformat() if stat.first_time else None,
                    "last_time": stat.last_time.isoformat() if stat.last_time else None
                }
                for stat in candles_stats
            ]
            
            # 3. –°–ø–µ—Ü–∏–∞–ª—å–Ω–æ –¥–ª—è SBER
            sber_instrument = session.query(Instrument).filter(
                Instrument.ticker == 'SBER'
            ).first()
            
            sber_info = None
            sber_candles_sample = []
            
            if sber_instrument:
                sber_info = {
                    "figi": sber_instrument.figi,
                    "ticker": sber_instrument.ticker,
                    "name": sber_instrument.name
                }
                
                # –ü–æ–ª—É—á–∞–µ–º –æ–±—Ä–∞–∑—Ü—ã —Å–≤–µ—á–µ–π –¥–ª—è SBER
                sber_candles = session.query(Candle).filter(
                    Candle.instrument_id == sber_instrument.figi
                ).order_by(desc(Candle.time)).limit(5).all()
                
                sber_candles_sample = [
                    {
                        "time": candle.time.isoformat(),
                        "interval": candle.interval,
                        "open": float(candle.open),
                        "close": float(candle.close),
                        "volume": candle.volume
                    }
                    for candle in sber_candles
                ]
            
            # 4. –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤—Å–µ –¥–æ—Å—Ç—É–ø–Ω—ã–µ –∏–Ω—Ç–µ—Ä–≤–∞–ª—ã
            intervals = session.query(Candle.interval).distinct().all()
            available_intervals = [interval[0] for interval in intervals]
            
            return {
                "total_instruments": len(instruments),
                "sample_instruments": instruments_info,
                "candles_by_instrument": candles_info,
                "available_intervals": available_intervals,
                "sber_instrument": sber_info,
                "sber_candles_sample": sber_candles_sample,
                "total_candles": session.query(Candle).count()
            }
            
    except Exception as e:
        logger.error(f"‚ùå Error in debug endpoint: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/data/coverage/{ticker}")
async def check_data_coverage(
    ticker: str,
    days: int = Query(365, description="Days to check coverage for"),
    interval: str = Query("5min", description="Candle interval")
):
    """–ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–∫—Ä—ã—Ç–∏—è –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —Ç–∏–∫–µ—Ä–∞"""
    try:
        if not historical_data_loader:
            raise HTTPException(status_code=503, detail="Historical data loader not initialized")
        
        db = get_db_manager()
        
        # –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç
        instrument = db.get_instrument_by_ticker(ticker)
        if not instrument:
            return {
                "ticker": ticker,
                "has_instrument": False,
                "coverage": {
                    "start_date": None,
                    "end_date": None,
                    "total_days": 0,
                    "missing_days": days,
                    "coverage_percentage": 0.0
                },
                "recommendations": ["Load instrument data first"]
            }
        
        # ‚úÖ –ö–†–ò–¢–ò–ß–ï–°–ö–û–ï –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º interval –≤ —Å—Ç—Ä–æ–∫—É
        interval_str = str(interval)
        logger.info(f"üîç Checking coverage for {ticker}, interval: {interval_str}")
        
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º timezone-aware –¥–∞—Ç—ã
        end_date = now_utc()
        start_date = utc_from_days_ago(days)
        
        existing_candles = db.get_candles(
            figi=instrument['figi'],
            interval=interval_str,  # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û: –ø–µ—Ä–µ–¥–∞–µ–º —Å—Ç—Ä–æ–∫—É, –∞ –Ω–µ Query –æ–±—ä–µ–∫—Ç
            from_time=start_date,
            to_time=end_date,
            limit=10000
        )
        
        # –û—Å—Ç–∞–ª—å–Ω–∞—è –ª–æ–≥–∏–∫–∞ –æ—Å—Ç–∞–µ—Ç—Å—è –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π...
        if not existing_candles:
            coverage_info = {
                "start_date": None,
                "end_date": None,
                "total_days": 0,
                "missing_days": days,
                "coverage_percentage": 0.0
            }
            recommendations = [f"Load {days} days of historical data for {ticker}"]
        else:
            candle_dates = [candle['time'].date() for candle in existing_candles]
            actual_start = min(candle_dates)
            actual_end = max(candle_dates)
            
            total_possible_days = (end_date.date() - start_date.date()).days
            actual_days = len(set(candle_dates))
            missing_days = total_possible_days - actual_days
            coverage_percentage = (actual_days / total_possible_days) * 100
            
            coverage_info = {
                "start_date": actual_start.isoformat(),
                "end_date": actual_end.isoformat(),
                "total_days": actual_days,
                "missing_days": missing_days,
                "coverage_percentage": round(coverage_percentage, 2)
            }
            
            recommendations = []
            if coverage_percentage < 80:
                recommendations.append(f"Load missing data - only {coverage_percentage:.1f}% coverage")
            if missing_days > 7:
                recommendations.append(f"Missing {missing_days} days of data")
        
        return {
            "ticker": ticker,
            "has_instrument": True,
            "figi": instrument['figi'],
            "coverage": coverage_info,
            "recommendations": recommendations,
            "can_auto_load": True
        }
        
    except Exception as e:
        logger.error(f"Error checking data coverage for {ticker}: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/api/data/smart-load/{ticker}")
async def smart_load_data(
    ticker: str,
    interval: str = Query("5min", description="Interval for candles"),
    max_days: int = Query(365, description="Maximum days to load"),
    ensure_signals_coverage: bool = Query(True, description="Ensure coverage for all signals period")
):
    """–£–º–Ω–∞—è –∑–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö —Å —É—á–µ—Ç–æ–º –ø–µ—Ä–∏–æ–¥–∞ —Å–∏–≥–Ω–∞–ª–æ–≤"""
    try:
        if not historical_data_loader:
            raise HTTPException(status_code=503, detail="Historical data loader not initialized")
        
        db = get_db_manager()
        
        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –Ω—É–∂–Ω—ã–π –ø–µ—Ä–∏–æ–¥
        required_days = max_days
        
        if ensure_signals_coverage:
            # –ù–∞—Ö–æ–¥–∏–º —Å–∞–º—ã–π —Å—Ç–∞—Ä—ã–π —Å–∏–≥–Ω–∞–ª –¥–ª—è —ç—Ç–æ–≥–æ —Ç–∏–∫–µ—Ä–∞
            oldest_signal = db.get_signals(
                ticker=ticker,
                limit=1,
                from_date=utc_from_days_ago(max_days * 2)
            )
            
            if oldest_signal:
                oldest_date = oldest_signal[0]['timestamp']
                oldest_date = ensure_timezone_aware(oldest_date)
                
                days_to_cover = days_between_utc(oldest_date, now_utc()) + 7
                required_days = min(max(days_to_cover, 30), max_days)
                
                logger.info(f"üìä Oldest signal for {ticker}: {oldest_date.date()}, will load {required_days} days")
        
        interval_str = str(interval)
        
        # –ó–∞–≥—Ä—É–∂–∞–µ–º –¥–∞–Ω–Ω—ã–µ
        result = await historical_data_loader.load_historical_candles(
            ticker=ticker,
            interval=interval_str,
            days_back=required_days,
            force_reload=False
        )
        
        # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û: –ü–µ—Ä–µ–¥–∞–µ–º –ø—Ä–∞–≤–∏–ª—å–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –≤ coverage –ø—Ä–æ–≤–µ—Ä–∫—É
        coverage_response = await check_data_coverage(ticker, required_days, interval_str)
        
        return {
            "ticker": ticker,
            "load_result": result,
            "coverage_after_load": coverage_response.get("coverage"),
            "days_loaded": required_days,
            "recommendations": coverage_response.get("recommendations")
        }
        
    except Exception as e:
        logger.error(f"Error in smart load for {ticker}: {e}")
        raise HTTPException(status_code=500, detail=str(e))

# ===== –ò–°–ü–†–ê–í–õ–ï–ù–ò–Ø –í –î–†–£–ì–ò–• –ú–ï–°–¢–ê–• =====

# –í —Ñ—É–Ω–∫—Ü–∏–∏ get_candles —Ç–æ–∂–µ –Ω—É–∂–Ω–æ –∏—Å–ø—Ä–∞–≤–∏—Ç—å:
@app.get("/api/candles/{ticker}")
async def get_candles(
    ticker: str,
    days: int = Query(30, description="Days of data to fetch"),
):
    """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å–≤–µ—á–µ–π –¥–ª—è —Ç–∏–∫–µ—Ä–∞ - –¢–û–õ–¨–ö–û –ß–¢–ï–ù–ò–ï, –±–µ–∑ –∞–≤—Ç–æ-–∑–∞–≥—Ä—É–∑–∫–∏"""
    try:
        db = get_db_manager()
        
        # –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç
        instrument = db.get_instrument_by_ticker(ticker)
        if not instrument:
            raise HTTPException(
                status_code=404,
                detail=f"Instrument {ticker} not found in database"
            )
        
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º timezone-aware –¥–∞—Ç—ã
        end_time = now_utc()
        start_time = utc_from_days_ago(days)
        
        # –¢–û–õ–¨–ö–û —á–∏—Ç–∞–µ–º –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö, –ë–ï–ó –∞–≤—Ç–æ-–∑–∞–≥—Ä—É–∑–∫–∏
        candles = db.get_candles(
            figi=instrument['figi'],
            interval="5min",
            from_time=start_time,
            to_time=end_time,
        )
        
        logger.info(f"üìà Found {len(candles)} candles in database for {ticker}")
        
        if not candles:
            raise HTTPException(
                status_code=404,
                detail={
                    "error": f"No candle data available for {ticker}",
                    "suggestion": "Use POST /api/data/smart-load/{ticker} to load historical data first",
                    "ticker": ticker,
                    "period_requested": {
                        "start": start_time.isoformat(),
                        "end": end_time.isoformat(),
                        "days": days
                    }
                }
            )
        
        return {
            "ticker": ticker,
            "candles": candles,
            "count": len(candles),
            "period": {
                "start": start_time.isoformat(),
                "end": end_time.isoformat(),
                "days": days
            }
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error fetching candles for {ticker}: {e}")
        raise HTTPException(status_code=500, detail=str(e))
    
@app.post("/api/data/bulk-smart-load")
async def bulk_smart_load():
    """–ú–∞—Å—Å–æ–≤–∞—è —É–º–Ω–∞—è –∑–∞–≥—Ä—É–∑–∫–∞ –¥–ª—è –≤—Å–µ—Ö —Ç–∏–∫–µ—Ä–æ–≤ —Å —Å–∏–≥–Ω–∞–ª–∞–º–∏"""
    try:
        if not historical_data_loader:
            raise HTTPException(status_code=503, detail="Historical data loader not initialized")
        
        db = get_db_manager()
        
        # –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ —Ç–∏–∫–µ—Ä—ã —Å —Å–∏–≥–Ω–∞–ª–∞–º–∏
        tickers_response = await get_available_tickers()
        tickers_with_signals = [t['ticker'] for t in tickers_response if t.get('signal_count', 0) > 0]
        
        logger.info(f"üöÄ Starting bulk smart load for {len(tickers_with_signals)} tickers")
        
        results = {
            "processed": [],
            "failed": [],
            "total_tickers": len(tickers_with_signals)
        }
        
        # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º concurrent –∑–∞–≥—Ä—É–∑–∫–∏
        semaphore = asyncio.Semaphore(2)
        
        async def load_single_ticker(ticker):
            async with semaphore:
                try:
                    result = await smart_load_data(ticker, max_days=365)
                    results["processed"].append(result)
                    logger.info(f"‚úÖ Completed smart load for {ticker}")
                except Exception as e:
                    error_info = {"ticker": ticker, "error": str(e)}
                    results["failed"].append(error_info)
                    logger.error(f"‚ùå Failed smart load for {ticker}: {e}")
                
                # –ü–∞—É–∑–∞ –º–µ–∂–¥—É –∑–∞–≥—Ä—É–∑–∫–∞–º–∏
                await asyncio.sleep(1)
        
        # –ó–∞–ø—É—Å–∫–∞–µ–º –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω—É—é –∑–∞–≥—Ä—É–∑–∫—É
        tasks = [load_single_ticker(ticker) for ticker in tickers_with_signals]
        await asyncio.gather(*tasks, return_exceptions=True)
        
        logger.info(f"üìä Bulk smart load completed: {len(results['processed'])}/{results['total_tickers']} successful")
        
        return results
        
    except Exception as e:
        logger.error(f"Error in bulk smart load: {e}")
        raise HTTPException(status_code=500, detail=str(e))

================================================================================
File: tbot/integrations/historical_data_loader.py
================================================================================
# integrations/historical_data_loader.py
import logging
import json
import asyncio
from datetime import datetime, timedelta
from typing import List, Dict, Optional
from pathlib import Path
from core.database.database import Instrument,Candle
from utils.datetime_utils import now_utc, utc_from_days_ago, utc_from_minutes_ago, ensure_timezone_aware, days_between_utc
from .tinkoff_integration import TinkoffIntegration
from core.database import Database
from sqlalchemy import func

logger = logging.getLogger(__name__)

class HistoricalDataLoader:
    """–ó–∞–≥—Ä—É–∑—á–∏–∫ –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏—Ö –¥–∞–Ω–Ω—ã—Ö –∏–∑ Tinkoff API –≤ –±–∞–∑—É"""
    
    def __init__(self, db: Database, tinkoff_client: TinkoffIntegration):
        self.db = db
        self.tinkoff = tinkoff_client
        self.mapping_file = Path("instruments_mapping.json")
        
    async def load_instruments_mapping(self) -> Dict:
        """–ó–∞–≥—Ä—É–∑–∫–∞ –º–∞–ø–ø–∏–Ω–≥–∞ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤"""
        try:
            if self.mapping_file.exists():
                with open(self.mapping_file, 'r', encoding='utf-8') as f:
                    mapping = json.load(f)
                    logger.info(f"üìã Loaded {len(mapping['instruments'])} instruments from mapping")
                    return mapping
            else:
                logger.warning("‚ö†Ô∏è Instruments mapping file not found, creating from API...")
                return await self.create_instruments_mapping()
                
        except Exception as e:
            logger.error(f"‚ùå Error loading instruments mapping: {e}")
            return {"instruments": {}}
    
    async def create_instruments_mapping(self) -> Dict:
        """–°–æ–∑–¥–∞–Ω–∏–µ –º–∞–ø–ø–∏–Ω–≥–∞ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤ —á–µ—Ä–µ–∑ API"""
        popular_instruments = await self.tinkoff.get_popular_instruments()
        
        mapping = {
            "description": "Auto-generated mapping from Tinkoff API",
            "last_updated": datetime.now().isoformat(),
            "instruments": {}
        }
        
        for instrument in popular_instruments:
            mapping["instruments"][instrument["ticker"]] = {
                "figi": instrument["figi"],
                "name": instrument["name"],
                "type": instrument["type"],
                "currency": instrument["currency"]
            }
        
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –º–∞–ø–ø–∏–Ω–≥
        try:
            with open(self.mapping_file, 'w', encoding='utf-8') as f:
                json.dump(mapping, f, indent=2, ensure_ascii=False)
            logger.info(f"üíæ Saved instruments mapping to {self.mapping_file}")
        except Exception as e:
            logger.error(f"‚ùå Error saving mapping: {e}")
        
        return mapping
    
    async def sync_instruments_to_database(self) -> int:
        """–°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤ –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö"""
        try:
            mapping = await self.load_instruments_mapping()
            synced_count = 0
            
            for ticker, info in mapping.get("instruments", {}).items():
                try:
                    # –ò—Å–ø–æ–ª—å–∑—É–µ–º –≥–æ—Ç–æ–≤—ã–π –º–µ—Ç–æ–¥ Database
                    figi = self.db.save_instrument(
                        figi=info["figi"],
                        ticker=ticker,
                        name=info["name"],
                        instrument_type=info.get("type", "share")
                    )
                    
                    if figi:
                        synced_count += 1
                        logger.info(f"‚úÖ Synced instrument: {ticker} ({info['name']})")
                    else:
                        logger.warning(f"‚ö†Ô∏è Failed to sync instrument: {ticker}")
                        
                except Exception as e:
                    logger.error(f"‚ùå Error syncing {ticker}: {e}")
            
            logger.info(f"üìä Synced {synced_count} instruments to database")
            return synced_count
            
        except Exception as e:
            logger.error(f"‚ùå Error syncing instruments: {e}")
            return 0

    async def load_historical_candles(
        self,
        ticker: str,
        interval: str = "5min", 
        days_back: int = 30,
        force_reload: bool = False
    ) -> Dict:
        """
        –ó–∞–≥—Ä—É–∑–∫–∞ –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏—Ö —Å–≤–µ—á–µ–π –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ —Ç–∏–∫–µ—Ä–∞
        
        Args:
            ticker: –¢–∏–∫–µ—Ä –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, "SBER")
            interval: –ò–Ω—Ç–µ—Ä–≤–∞–ª —Å–≤–µ—á–µ–π ("1min", "5min", "hour", "day")  
            days_back: –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–Ω–µ–π –Ω–∞–∑–∞–¥ –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏
            force_reload: –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–∞—è –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∫–∞ (–æ—á–∏—Å—Ç–∏—Ç—å —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ)
            
        Returns:
            Dict —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º–∏ –∑–∞–≥—Ä—É–∑–∫–∏
        """
        try:
            # –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–µ —á–µ—Ä–µ–∑ –≥–æ—Ç–æ–≤—ã–π –º–µ—Ç–æ–¥
            instrument = self.db.get_instrument_by_ticker(ticker)
            if not instrument:
                # –ü—ã—Ç–∞–µ–º—Å—è –Ω–∞–π—Ç–∏ —á–µ—Ä–µ–∑ API –∏ –¥–æ–±–∞–≤–∏—Ç—å –≤ –±–∞–∑—É
                api_instrument = await self.tinkoff.find_instrument_by_ticker(ticker)
                if not api_instrument:
                    return {
                        "success": False,
                        "error": f"Instrument {ticker} not found",
                        "loaded_candles": 0
                    }
                
                # –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç –≤ –±–∞–∑—É
                self.db.save_instrument(
                    figi=api_instrument["figi"],
                    ticker=ticker,
                    name=api_instrument["name"],
                    instrument_type=api_instrument.get("type", "share")
                )
                
                instrument = {"figi": api_instrument["figi"]}
            
            figi = instrument["figi"]
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –¥–∞–Ω–Ω—ã–µ —á–µ—Ä–µ–∑ –≥–æ—Ç–æ–≤—ã–π –º–µ—Ç–æ–¥
            if not force_reload:
                existing_candles = self.db.get_candles(
                    figi=figi,
                    interval=interval,
                    limit=10
                )
                
                if existing_candles:
                    logger.info(f"üìä Found {len(existing_candles)} existing candles for {ticker}")
                    
                    # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û: –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Å –∫–∞–∫–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏ –∑–∞–≥—Ä—É–∂–∞—Ç—å
                    # –í—Å–µ –¥–∞—Ç—ã –∏–∑ –ë–î —É–∂–µ timezone-aware (UTC)
                    last_candle_time = max(candle['time'] for candle in existing_candles)
                    last_candle_time = ensure_timezone_aware(last_candle_time)  # –ù–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π
                    
                    from_time = last_candle_time + timedelta(minutes=1)
                    to_time = now_utc()  # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û: timezone-aware
                    
                    # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û: –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ timezone-aware –¥–∞—Ç
                    if from_time >= to_time:
                        return {
                            "success": True,
                            "message": "Data is up to date",
                            "loaded_candles": 0,
                            "existing_candles": len(existing_candles)
                        }
                else:
                    # –ó–∞–≥—Ä—É–∂–∞–µ–º –ø–æ–ª–Ω—ã–π –ø–µ—Ä–∏–æ–¥
                    from_time = utc_from_days_ago(days_back)  # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û
                    to_time = now_utc()  # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û
            else:
                # –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–∞—è –∑–∞–≥—Ä—É–∑–∫–∞ - –∑–∞–≥—Ä—É–∂–∞–µ–º –≤–µ—Å—å –ø–µ—Ä–∏–æ–¥
                from_time = utc_from_days_ago(days_back)  # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û
                to_time = now_utc()  # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û
            
            # –ó–∞–≥—Ä—É–∂–∞–µ–º —Å–≤–µ—á–∏ —á–µ—Ä–µ–∑ API
            logger.info(f"üìà Loading {interval} candles for {ticker} from {from_time.date()} to {to_time.date()}")
            
            candles_data = await self.tinkoff.get_candles(
                figi=figi,
                interval=interval,
                from_time=from_time,
                to_time=to_time
            )
            
            if not candles_data:
                return {
                    "success": False,
                    "error": "No candles received from API",
                    "loaded_candles": 0
                }
            
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–≤–µ—á–∏ –≤ –±–∞–∑—É —á–µ—Ä–µ–∑ –≥–æ—Ç–æ–≤—ã–π –º–µ—Ç–æ–¥
            result = self.db.save_candles(candles_data, figi=figi, interval=interval)
            
            if result.get('saved', 0) > 0:
                logger.info(f"‚úÖ Successfully loaded {len(candles_data)} candles for {ticker}")
                return {
                    "success": True,
                    "ticker": ticker,
                    "interval": interval,
                    "loaded_candles": len(candles_data),
                    "period": f"{from_time.date()} - {to_time.date()}"
                }
            else:
                return {
                    "success": False,
                    "error": "Failed to save candles to database",
                    "loaded_candles": 0
                }
                
        except Exception as e:
            logger.error(f"‚ùå Error loading historical candles for {ticker}: {e}")
            return {
                "success": False,
                "error": str(e),
                "loaded_candles": 0
            }

    async def bulk_load_popular_instruments(
        self,
        interval: str = "5min",
        days_back: int = 30,
        max_concurrent: int = 3
    ) -> Dict:
        """
        –ú–∞—Å—Å–æ–≤–∞—è –∑–∞–≥—Ä—É–∑–∫–∞ –ø–æ–ø—É–ª—è—Ä–Ω—ã—Ö –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤
        
        Args:
            interval: –ò–Ω—Ç–µ—Ä–≤–∞–ª —Å–≤–µ—á–µ–π
            days_back: –î–Ω–µ–π –Ω–∞–∑–∞–¥
            max_concurrent: –ú–∞–∫—Å–∏–º—É–º –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω—ã—Ö –∑–∞–≥—Ä—É–∑–æ–∫
        """
        try:
            mapping = await self.load_instruments_mapping()
            popular_tickers = list(mapping.get("demo_signals", {}).get("most_traded", []))
            
            if not popular_tickers:
                popular_tickers = ["SBER", "GAZP", "LKOH", "YNDX", "VTBR"]
            
            logger.info(f"üöÄ Starting bulk load for {len(popular_tickers)} instruments")
            
            results = {
                "completed": [],
                "failed": [],
                "total_candles": 0,
                "total_requested": len(popular_tickers),
                "start_time": now_utc().isoformat(),  # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û
            }
            
            # –°–æ–∑–¥–∞–µ–º —Å–µ–º–∞—Ñ–æ—Ä –¥–ª—è –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è concurrent –∑–∞–ø—Ä–æ—Å–æ–≤
            semaphore = asyncio.Semaphore(max_concurrent)
            
            async def load_single_ticker(ticker):
                async with semaphore:
                    result = await self.load_historical_candles(
                        ticker=ticker,
                        interval=interval,
                        days_back=days_back
                    )
                    
                    if result["success"]:
                        results["completed"].append(result)
                        results["total_candles"] += result["loaded_candles"]
                    else:
                        results["failed"].append({
                            "ticker": ticker,
                            "error": result["error"]
                        })
                    
                    # –ü–∞—É–∑–∞ –º–µ–∂–¥—É –∑–∞–≥—Ä—É–∑–∫–∞–º–∏
                    await asyncio.sleep(1)
            
            # –ó–∞–ø—É—Å–∫–∞–µ–º –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω—É—é –∑–∞–≥—Ä—É–∑–∫—É
            tasks = [load_single_ticker(ticker) for ticker in popular_tickers]
            await asyncio.gather(*tasks, return_exceptions=True)
            
            results["end_time"] = now_utc().isoformat()  # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û
            results["duration_minutes"] = (
                datetime.fromisoformat(results["end_time"].replace('Z', '+00:00')) - 
                datetime.fromisoformat(results["start_time"].replace('Z', '+00:00'))
            ).total_seconds() / 60
            
            logger.info(f"üìä Bulk load completed: {len(results['completed'])}/{len(popular_tickers)} successful")
            
            return results
            
        except Exception as e:
            logger.error(f"‚ùå Error in bulk load: {e}")
            return {
                "error": str(e),
                "completed": [],
                "failed": [],
                "total_candles": 0,
                "end_time": now_utc().isoformat()  # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û
            }
    
    async def get_data_status(self) -> Dict:
        """
        –ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏—Ö –¥–∞–Ω–Ω—ã—Ö
        
        Returns:
            Dict —Å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –æ —Å–æ—Å—Ç–æ—è–Ω–∏–∏ –¥–∞–Ω–Ω—ã—Ö
        """
        try:
            with self.db.get_session() as session:
                # –û—Å–Ω–æ–≤–Ω–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
                total_instruments = session.query(Instrument).count()
                total_candles = session.query(Candle).count()
                
                # –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –ø–æ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞–º
                instruments = session.query(Instrument).limit(10).all()
                instruments_info = []
                
                for instrument in instruments:
                    candles_count = session.query(Candle).filter(
                        Candle.figi == instrument.figi
                    ).count()
                    
                    # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û: –ü–æ–ª—É—á–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω—é—é —Å–≤–µ—á—É —Å timezone-aware —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ–º
                    latest_candle = session.query(Candle).filter(
                        Candle.figi == instrument.figi
                    ).order_by(Candle.time.desc()).first()
                    
                    latest_time = None
                    if latest_candle:
                        latest_time = ensure_timezone_aware(latest_candle.time).isoformat()
                    
                    instruments_info.append({
                        "ticker": instrument.ticker,
                        "figi": instrument.figi,
                        "name": instrument.name,
                        "candles_count": candles_count,
                        "latest_candle": latest_time
                    })
                
                # –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –ø–æ —Å–≤–µ—á–∞–º
                candles_info = []
                candles_by_figi = session.query(
                    Candle.figi, 
                    func.count(Candle.id).label('count')
                ).group_by(Candle.figi).limit(10).all()
                
                for figi, count in candles_by_figi:
                    instrument = session.query(Instrument).filter(
                        Instrument.figi == figi
                    ).first()
                    
                    candles_info.append({
                        "figi": figi,
                        "ticker": instrument.ticker if instrument else "Unknown",
                        "candles_count": count
                    })
                
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤—Å–µ –¥–æ—Å—Ç—É–ø–Ω—ã–µ –∏–Ω—Ç–µ—Ä–≤–∞–ª—ã
                intervals = session.query(Candle.interval).distinct().all()
                available_intervals = [interval[0] for interval in intervals]
                
                return {
                    "total_instruments": total_instruments,
                    "total_candles": total_candles,
                    "sample_instruments": instruments_info,
                    "candles_by_instrument": candles_info,
                    "available_intervals": available_intervals,
                    "status_timestamp": now_utc().isoformat(),  # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û
                    "status": "operational"
                }
                
        except Exception as e:
            logger.error(f"‚ùå Error getting data status: {e}")
            return {
                "error": str(e),
                "status": "error",
                "status_timestamp": now_utc().isoformat()  # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û
            }
    
    def _get_instruments_detailed_stats(self) -> List[Dict]:
        """–ü–æ–ª—É—á–∏—Ç—å –¥–µ—Ç–∞–ª—å–Ω—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞–º"""
        instruments_info = []
        
        try:
            with self.db.session() as session:
                from core.database import Instrument, Candle
                from sqlalchemy import func
                
                # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞–º
                instruments_stats = session.query(
                    Instrument.ticker,
                    Instrument.name,
                    func.count(Candle.id).label('candles_count'),
                    func.max(Candle.time).label('last_candle'),
                    func.min(Candle.time).label('first_candle')
                ).outerjoin(
                    Candle, Instrument.figi == Candle.instrument_id
                ).group_by(
                    Instrument.ticker, Instrument.name
                ).all()
                
                for stat in instruments_stats:
                    instruments_info.append({
                        "ticker": stat.ticker,
                        "name": stat.name,
                        "candles_count": stat.candles_count,
                        "last_candle": stat.last_candle.isoformat() if stat.last_candle else None,
                        "first_candle": stat.first_candle.isoformat() if stat.first_candle else None,
                        "has_data": stat.candles_count > 0
                    })
        except Exception as e:
            logger.error(f"‚ùå Error getting instruments stats: {e}")
        
        return instruments_info
    
    async def cleanup_old_data(self, days_to_keep: int = 90) -> Dict:
        """–û—á–∏—Å—Ç–∫–∞ —Å—Ç–∞—Ä—ã—Ö –¥–∞–Ω–Ω—ã—Ö"""
        try:
            cutoff_date = datetime.now() - timedelta(days=days_to_keep)
            
            with self.db.session() as session:
                from core.database import Candle
                
                # –°—á–∏—Ç–∞–µ–º —Å–∫–æ–ª—å–∫–æ –∑–∞–ø–∏—Å–µ–π –±—É–¥–µ—Ç —É–¥–∞–ª–µ–Ω–æ
                old_records = session.query(Candle).filter(
                    Candle.time < cutoff_date
                ).count()
                
                # –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ –∑–∞–ø–∏—Å–∏
                deleted = session.query(Candle).filter(
                    Candle.time < cutoff_date
                ).delete()
                
                logger.info(f"üóëÔ∏è Cleaned up {deleted} old candle records (older than {cutoff_date.date()})")
                
                return {
                    "success": True,
                    "deleted_records": deleted,
                    "cutoff_date": cutoff_date.isoformat(),
                    "days_kept": days_to_keep
                }
                
        except Exception as e:
            logger.error(f"‚ùå Error cleaning up old data: {e}")
            return {
                "success": False,
                "error": str(e)
            }
        
    def _deduplicate_candles_data(self, candles_data: List[Dict], figi: str, interval: str) -> List[Dict]:
        """
        –£–¥–∞–ª—è–µ—Ç –¥—É–±–ª–∏–∫–∞—Ç—ã –∏–∑ –¥–∞–Ω–Ω—ã—Ö —Å–≤–µ—á–µ–π –ø–µ—Ä–µ–¥ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ–º
        
        Args:
            candles_data: –¥–∞–Ω–Ω—ã–µ —Å–≤–µ—á–µ–π –æ—Ç Tinkoff API
            figi: FIGI –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞
            interval: –∏–Ω—Ç–µ—Ä–≤–∞–ª —Å–≤–µ—á–µ–π
            
        Returns:
            List[Dict]: –æ—á–∏—â–µ–Ω–Ω—ã–µ –æ—Ç –¥—É–±–ª–∏–∫–∞—Ç–æ–≤ –¥–∞–Ω–Ω—ã–µ
        """
        if not candles_data:
            return candles_data
        
        seen_times = set()
        deduplicated = []
        duplicates_count = 0
        
        for candle in candles_data:
            candle_time = candle['time']
            
            # –°–æ–∑–¥–∞–µ–º —É–Ω–∏–∫–∞–ª—å–Ω—ã–π –∫–ª—é—á
            time_key = (figi, interval, candle_time)
            
            if time_key not in seen_times:
                seen_times.add(time_key)
                deduplicated.append(candle)
            else:
                duplicates_count += 1
                logger.warning(f"‚ö†Ô∏è Removing duplicate candle for {figi} at {candle_time}")
        
        if duplicates_count > 0:
            logger.info(f"üßπ Removed {duplicates_count} duplicate candles from {len(candles_data)} total")
        
        return deduplicated

    # –î–æ–±–∞–≤–∏—Ç—å –≤ integrations/tinkoff_integration.py

    def _validate_candles_data(self, candles: List[Dict]) -> List[Dict]:
        """
        –í–∞–ª–∏–¥–∏—Ä—É–µ—Ç –∏ –æ—á–∏—â–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ —Å–≤–µ—á–µ–π –æ—Ç API
        
        Args:
            candles: —Å—ã—Ä—ã–µ –¥–∞–Ω–Ω—ã–µ –æ—Ç Tinkoff API
            
        Returns:
            List[Dict]: –≤–∞–ª–∏–¥–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
        """
        valid_candles = []
        
        for i, candle in enumerate(candles):
            try:
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è
                required_fields = ['time', 'open', 'high', 'low', 'close']
                if not all(field in candle for field in required_fields):
                    logger.warning(f"‚ö†Ô∏è Skipping candle {i}: missing required fields")
                    continue
                
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ª–æ–≥–∏—á–Ω–æ—Å—Ç—å —Ü–µ–Ω
                open_price = float(candle['open'])
                high_price = float(candle['high'])
                low_price = float(candle['low'])
                close_price = float(candle['close'])
                
                if not (low_price <= open_price <= high_price and 
                    low_price <= close_price <= high_price):
                    logger.warning(f"‚ö†Ô∏è Skipping candle {i}: invalid OHLC values")
                    continue
                
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ —Ü–µ–Ω—ã –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–µ
                if any(price <= 0 for price in [open_price, high_price, low_price, close_price]):
                    logger.warning(f"‚ö†Ô∏è Skipping candle {i}: negative or zero prices")
                    continue
                
                valid_candles.append(candle)
                
            except (ValueError, TypeError) as e:
                logger.warning(f"‚ö†Ô∏è Skipping candle {i}: validation error {e}")
                continue
        
        logger.info(f"‚úÖ Validated {len(valid_candles)}/{len(candles)} candles")
        return valid_candles

================================================================================
File: tbot/integrations/tinkoff_integration.py
================================================================================
# integrations/tinkoff_integration.py
import logging
import asyncio
from datetime import datetime, timedelta
from typing import Optional, List, Dict, Tuple
import pytz
import os

logger = logging.getLogger(__name__)

class TinkoffIntegration:
    """–ü–û–õ–ù–ê–Ø –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å Tinkoff API —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º target + –≤—Å–µ –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–µ –º–µ—Ç–æ–¥—ã"""
    
    def __init__(self, token: str, sandbox: bool = True):
        self.token = token
        self.sandbox = sandbox
        self.client = None
        self.instruments_cache = {}
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏
        try:
            global AsyncClient, CandleInterval, InstrumentIdType
            from tinkoff.invest import AsyncClient, CandleInterval, InstrumentIdType
            
            # üî• –ö–õ–Æ–ß–ï–í–û–ï –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –∏–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º –∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã –¥–ª—è target
            from tinkoff.invest.constants import INVEST_GRPC_API, INVEST_GRPC_API_SANDBOX
            self.target = INVEST_GRPC_API_SANDBOX if sandbox else INVEST_GRPC_API
            
            logger.info(f"üéØ Target set to: {'SANDBOX' if sandbox else 'PRODUCTION'}")
            
        except ImportError:
            logger.error("‚ùå Tinkoff Invest library not found. Install: pip install tinkoff-invest")
            raise ImportError("tinkoff-invest library required")
        
    async def initialize(self) -> bool:
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–ª–∏–µ–Ω—Ç–∞ —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º target"""
        try:
            if not self.token or self.token == "your_tinkoff_token_here":
                logger.error("‚ùå Tinkoff token not configured")
                return False
                
            logger.info(f"üîó Initializing Tinkoff API (sandbox={self.sandbox})")
            
            # üî• –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –∏—Å–ø–æ–ª—å–∑—É–µ–º target –¥–ª—è –≤—ã–±–æ—Ä–∞ –∫–æ–Ω—Ç—É—Ä–∞
            async with AsyncClient(self.token, target=self.target) as client:
                # –ü—Ä–æ—Å—Ç–æ–π —Ç–µ—Å—Ç - –ø–æ–ª—É—á–∞–µ–º –∞–∫–∫–∞—É–Ω—Ç—ã
                accounts = await client.users.get_accounts()
                logger.info(f"‚úÖ Tinkoff client initialized successfully")
                logger.info(f"üìä Found {len(accounts.accounts)} accounts")
                logger.info(f"üéØ Using {'SANDBOX' if self.sandbox else 'PRODUCTION'} environment")
                
                # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ - –ø–æ–∏—Å–∫ –ø—Ä–æ—Å—Ç–æ–≥–æ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞
                try:
                    test_response = await client.instruments.shares()
                    logger.info(f"üîç Found {len(test_response.instruments)} shares available")
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è Could not fetch shares list: {e}")
                
                return True
                
        except Exception as e:
            logger.error(f"‚ùå Failed to initialize Tinkoff client: {e}")
            logger.error(f"üîß Debug info: token length={len(self.token)}, sandbox={self.sandbox}, target={getattr(self, 'target', 'NOT_SET')}")
            return False
    
    async def close(self):
        """–ó–∞–∫—Ä—ã—Ç–∏–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è"""
        logger.info("üîÑ Tinkoff client closed")
    
    async def find_instrument_by_ticker(self, ticker: str) -> Optional[Dict]:
        """–ü–æ–∏—Å–∫ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞ –ø–æ —Ç–∏–∫–µ—Ä—É —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º target"""
        async with AsyncClient(self.token, target=self.target) as client:
            try:
                logger.info(f"üîç Searching for instrument: {ticker}")
                
                # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å—Ç–∞—Ä—ã–π –ø–æ–¥—Ö–æ–¥
                instrument_types = [
                    ("shares", client.instruments.shares),
                    ("etfs", client.instruments.etfs),
                    ("bonds", client.instruments.bonds),
                    ("futures", client.instruments.futures),
                    ("currencies", client.instruments.currencies)
                ]
                
                for type_name, instrument_method in instrument_types:
                    try:
                        response = await instrument_method()
                        for instrument in response.instruments:
                            if instrument.ticker.upper() == ticker.upper():
                                result = {
                                    "figi": instrument.figi,
                                    "ticker": instrument.ticker,
                                    "name": instrument.name,
                                    "type": type_name,
                                    "currency": instrument.currency,
                                    "lot": instrument.lot,
                                    "trading_status": str(instrument.trading_status) if hasattr(instrument, 'trading_status') else 'unknown'
                                }
                                logger.info(f"‚úÖ Found {ticker}: {result['name']} ({result['figi']})")
                                return result
                    except Exception as e:
                        logger.warning(f"‚ö†Ô∏è Error searching in {type_name}: {e}")
                        continue
                
                logger.warning(f"‚ùå Instrument {ticker} not found")
                return None
                
            except Exception as e:
                logger.error(f"‚ùå Error searching for {ticker}: {e}")
                return None

    async def get_current_price(self, ticker: str) -> Optional[Dict]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Ç–µ–∫—É—â–µ–π —Ü–µ–Ω—ã –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞ —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º target"""
        try:
            # –°–Ω–∞—á–∞–ª–∞ –Ω–∞—Ö–æ–¥–∏–º –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç
            instrument = await self.find_instrument_by_ticker(ticker)
            if not instrument:
                return None
            
            async with AsyncClient(self.token, target=self.target) as client:
                # –ü–æ–ª—É—á–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω—é—é —Ü–µ–Ω—É
                response = await client.market_data.get_last_prices(
                    figi=[instrument['figi']]
                )
                
                if response.last_prices:
                    last_price = response.last_prices[0]
                    price_value = float(last_price.price.units) + float(last_price.price.nano) / 1e9
                    
                    return {
                        "ticker": ticker,
                        "figi": instrument['figi'],
                        "price": price_value,
                        "currency": instrument['currency'],
                        "timestamp": datetime.now().isoformat(),
                        "source": f"tinkoff_api_{'sandbox' if self.sandbox else 'production'}"
                    }
                
                return None
                
        except Exception as e:
            logger.error(f"‚ùå Error getting price for {ticker}: {e}")
            return None

    async def get_candles(self, figi: str, interval: str, from_time: datetime, to_time: Optional[datetime] = None) -> List[Dict]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å–≤–µ—á–µ–π –¥–ª—è –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞ —Å –≤–∞–ª–∏–¥–∞—Ü–∏–µ–π –∏ –¥–µ–¥—É–ø–ª–∏–∫–∞—Ü–∏–µ–π"""
        try:
            if to_time is None:
                to_time = datetime.now(pytz.UTC)
            
            # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –∏–Ω—Ç–µ—Ä–≤–∞–ª
            interval_map = {
                "1min": CandleInterval.CANDLE_INTERVAL_1_MIN,
                "5min": CandleInterval.CANDLE_INTERVAL_5_MIN,
                "hour": CandleInterval.CANDLE_INTERVAL_HOUR,
                "day": CandleInterval.CANDLE_INTERVAL_DAY
            }
            
            if interval not in interval_map:
                logger.error(f"‚ùå Unsupported interval: {interval}")
                return []
            
            candles = []
            async with AsyncClient(self.token, target=self.target) as client:
                async for candle in client.get_all_candles(
                    figi=figi,
                    from_=from_time,
                    to=to_time,
                    interval=interval_map[interval]
                ):
                    candles.append({
                        "time": candle.time,
                        "open": float(candle.open.units) + float(candle.open.nano) / 1e9,
                        "high": float(candle.high.units) + float(candle.high.nano) / 1e9,
                        "low": float(candle.low.units) + float(candle.low.nano) / 1e9,
                        "close": float(candle.close.units) + float(candle.close.nano) / 1e9,
                        "volume": candle.volume
                    })
            
            logger.info(f"üìä Received {len(candles)} raw candles from Tinkoff API")
            
            # üÜï –í–ê–õ–ò–î–ò–†–£–ï–ú –ò –û–ß–ò–©–ê–ï–ú –î–ê–ù–ù–´–ï
            validated_candles = self._validate_candles_data(candles)
            
            # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –≤—Ä–µ–º–µ–Ω–∏ –¥–ª—è –Ω–∞–¥–µ–∂–Ω–æ—Å—Ç–∏
            validated_candles.sort(key=lambda x: x['time'])
            
            logger.info(f"‚úÖ Returning {len(validated_candles)} validated candles")
            return validated_candles
            
        except Exception as e:
            logger.error(f"‚ùå Error getting candles for {figi}: {e}")
            return []


    async def test_connection(self) -> Dict:
        """–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ API —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º target"""
        try:
            async with AsyncClient(self.token, target=self.target) as client:
                # –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± –∞–∫–∫–∞—É–Ω—Ç–µ
                accounts = await client.users.get_accounts()
                
                # –ü—Ä–æ–±—É–µ–º –Ω–∞–π—Ç–∏ –ø–æ–ø—É–ª—è—Ä–Ω—ã–π –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç
                test_instrument = await self.find_instrument_by_ticker("SBER")
                
                return {
                    "success": True,
                    "sandbox": self.sandbox,
                    "target": "SANDBOX" if self.sandbox else "PRODUCTION",
                    "accounts_count": len(accounts.accounts),
                    "test_instrument": test_instrument is not None,
                    "test_ticker": "SBER",
                    "timestamp": datetime.now().isoformat()
                }
                
        except Exception as e:
            return {
                "success": False,
                "error": str(e),
                "sandbox": self.sandbox,
                "target": "SANDBOX" if self.sandbox else "PRODUCTION",
                "timestamp": datetime.now().isoformat()
            }

    def _validate_candles_data(self, candles: List[Dict]) -> List[Dict]:
        """
        –í–∞–ª–∏–¥–∏—Ä—É–µ—Ç –∏ –æ—á–∏—â–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ —Å–≤–µ—á–µ–π –æ—Ç API
        
        Args:
            candles: —Å—ã—Ä—ã–µ –¥–∞–Ω–Ω—ã–µ –æ—Ç Tinkoff API
            
        Returns:
            List[Dict]: –≤–∞–ª–∏–¥–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
        """
        valid_candles = []
        
        for i, candle in enumerate(candles):
            try:
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è
                required_fields = ['time', 'open', 'high', 'low', 'close']
                if not all(field in candle for field in required_fields):
                    logger.warning(f"‚ö†Ô∏è Skipping candle {i}: missing required fields")
                    continue
                
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ª–æ–≥–∏—á–Ω–æ—Å—Ç—å —Ü–µ–Ω
                open_price = float(candle['open'])
                high_price = float(candle['high'])
                low_price = float(candle['low'])
                close_price = float(candle['close'])
                
                if not (low_price <= open_price <= high_price and 
                    low_price <= close_price <= high_price):
                    logger.warning(f"‚ö†Ô∏è Skipping candle {i}: invalid OHLC values")
                    continue
                
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ —Ü–µ–Ω—ã –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–µ
                if any(price <= 0 for price in [open_price, high_price, low_price, close_price]):
                    logger.warning(f"‚ö†Ô∏è Skipping candle {i}: negative or zero prices")
                    continue
                
                valid_candles.append(candle)
                
            except (ValueError, TypeError) as e:
                logger.warning(f"‚ö†Ô∏è Skipping candle {i}: validation error {e}")
                continue
        
        logger.info(f"‚úÖ Validated {len(valid_candles)}/{len(candles)} candles")
        return valid_candles

    async def get_popular_instruments(self, limit: int = 50) -> List[Dict]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –ø–æ–ø—É–ª—è—Ä–Ω—ã—Ö –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤ —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º target"""
        try:
            async with AsyncClient(self.token, target=self.target) as client:
                shares_response = await client.instruments.shares()
                
                # –ë–µ—Ä–µ–º –ø–µ—Ä–≤—ã–µ limit –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤
                instruments = []
                for instrument in shares_response.instruments[:limit]:
                    instruments.append({
                        "figi": instrument.figi,
                        "ticker": instrument.ticker,
                        "name": instrument.name,
                        "currency": instrument.currency,
                        "lot": instrument.lot,
                        "type": "share"
                    })
                
                logger.info(f"üìä Loaded {len(instruments)} popular instruments")
                return instruments
                
        except Exception as e:
            logger.error(f"‚ùå Error loading popular instruments: {e}")
            return []

    async def bulk_load_instruments(self, tickers: List[str]) -> Dict:
        """üîÑ –í–û–°–°–¢–ê–ù–û–í–õ–ï–ù–ù–´–ô –ú–ï–¢–û–î: –ú–∞—Å—Å–æ–≤–∞—è –∑–∞–≥—Ä—É–∑–∫–∞ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤ —Å –ø—Ä–æ–≥—Ä–µ—Å—Å–æ–º"""
        results = {
            "loaded": [],
            "failed": [],
            "total_requested": len(tickers),
            "total_loaded": 0
        }
        
        for i, ticker in enumerate(tickers):
            try:
                logger.info(f"üîç Loading {i+1}/{len(tickers)}: {ticker}")
                instrument = await self.find_instrument_by_ticker(ticker)
                
                if instrument:
                    results["loaded"].append(instrument)
                    results["total_loaded"] += 1
                else:
                    results["failed"].append({"ticker": ticker, "error": "Not found"})
                    
                # –ü–∞—É–∑–∞ –º–µ–∂–¥—É –∑–∞–ø—Ä–æ—Å–∞–º–∏
                await asyncio.sleep(0.1)
                
            except Exception as e:
                results["failed"].append({"ticker": ticker, "error": str(e)})
                logger.error(f"‚ùå Error loading {ticker}: {e}")
        
        logger.info(f"üìä Bulk load completed: {results['total_loaded']}/{results['total_requested']}")
        return results

    async def get_account_info(self) -> Dict:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ–± –∞–∫–∫–∞—É–Ω—Ç–µ"""
        try:
            async with AsyncClient(self.token, target=self.target) as client:
                accounts = await client.users.get_accounts()
                
                account_info = []
                for account in accounts.accounts:
                    account_info.append({
                        "id": account.id,
                        "name": account.name,
                        "type": str(account.type),
                        "status": str(account.status),
                        "access_level": str(account.access_level)
                    })
                
                return {
                    "success": True,
                    "accounts": account_info,
                    "total_accounts": len(account_info)
                }
                
        except Exception as e:
            logger.error(f"‚ùå Error getting account info: {e}")
            return {
                "success": False,
                "error": str(e),
                "accounts": []
            }

    async def get_instrument_by_figi(self, figi: str) -> Optional[Dict]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞ –ø–æ FIGI"""
        try:
            async with AsyncClient(self.token, target=self.target) as client:
                response = await client.instruments.get_instrument_by(
                    id_type=InstrumentIdType.INSTRUMENT_ID_TYPE_FIGI,
                    id=figi
                )
                
                if response.instrument:
                    instrument = response.instrument
                    return {
                        "figi": instrument.figi,
                        "ticker": instrument.ticker,
                        "name": instrument.name,
                        "currency": instrument.currency,
                        "lot": instrument.lot,
                        "type": "unknown"  # –ù—É–∂–Ω–æ –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Ç–∏–ø –æ—Ç–¥–µ–ª—å–Ω–æ
                    }
                return None
                
        except Exception as e:
            logger.error(f"‚ùå Error getting instrument by FIGI {figi}: {e}")
            return None

    async def search_instruments(self, query: str, limit: int = 20) -> List[Dict]:
        """–ü–æ–∏—Å–∫ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤ –ø–æ –∑–∞–ø—Ä–æ—Å—É"""
        try:
            # –ü—Ä–æ—Å—Ç–æ–π –ø–æ–∏—Å–∫ - –ø—Ä–æ–±—É–µ–º –Ω–∞–π—Ç–∏ –∫–∞–∫ —Ç–∏–∫–µ—Ä
            if len(query) <= 6 and query.isupper():
                instrument = await self.find_instrument_by_ticker(query)
                if instrument:
                    return [instrument]
            
            # –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π –ø–æ–∏—Å–∫ –ø–æ –≤—Å–µ–º –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞–º
            results = []
            async with AsyncClient(self.token, target=self.target) as client:
                instrument_types = [
                    ("shares", client.instruments.shares),
                    ("etfs", client.instruments.etfs),
                    ("bonds", client.instruments.bonds),
                ]
                
                for type_name, instrument_method in instrument_types:
                    try:
                        response = await instrument_method()
                        for instrument in response.instruments:
                            if (query.upper() in instrument.ticker.upper() or 
                                query.upper() in instrument.name.upper()):
                                results.append({
                                    "figi": instrument.figi,
                                    "ticker": instrument.ticker,
                                    "name": instrument.name,
                                    "type": type_name,
                                    "currency": instrument.currency,
                                    "lot": instrument.lot
                                })
                                
                                if len(results) >= limit:
                                    break
                    except Exception as e:
                        logger.warning(f"‚ö†Ô∏è Error searching in {type_name}: {e}")
                        continue
                        
                    if len(results) >= limit:
                        break
            
            logger.info(f"üîç Found {len(results)} instruments for query '{query}'")
            return results
            
        except Exception as e:
            logger.error(f"‚ùå Error searching instruments: {e}")

            return []

# –û–±–Ω–æ–≤–ª—è–µ–º –≥–ª–æ–±–∞–ª—å–Ω—É—é –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—é
async def create_tinkoff_client() -> TinkoffIntegration:
    """–°–æ–∑–¥–∞–Ω–∏–µ –∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Tinkoff –∫–ª–∏–µ–Ω—Ç–∞ —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º target"""
    token = os.getenv("TINKOFF_TOKEN")
    sandbox = os.getenv("TINKOFF_SANDBOX", "false").lower() == "true"
    
    if not token:
        raise ValueError("TINKOFF_TOKEN environment variable not set")
    
    client = TinkoffIntegration(token, sandbox)
    success = await client.initialize()
    
    if not success:
        raise Exception("Failed to initialize Tinkoff client")
    
    return client


# üîÑ –í–û–°–°–¢–ê–ù–û–í–õ–ï–ù–ù–´–ï –§–£–ù–ö–¶–ò–ò –°–û–í–ú–ï–°–¢–ò–ú–û–°–¢–ò –∏–∑ —Å—Ç–∞—Ä–æ–≥–æ –∫–æ–¥–∞
async def sync_instruments_from_tinkoff(tinkoff_client, instrument_type="shares"):
    """–°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤ (–æ–±–Ω–æ–≤–ª–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è)"""
    if instrument_type == "shares":
        instruments = await tinkoff_client.get_popular_instruments()
        return len(instruments)
    return 0

async def get_missing_candles_for_signals(tinkoff_client):
    """–ó–∞–≥—Ä—É–∑–∫–∞ –Ω–µ–¥–æ—Å—Ç–∞—é—â–∏—Ö —Å–≤–µ—á–µ–π –¥–ª—è —Å–∏–≥–Ω–∞–ª–æ–≤"""
    # –≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –±—É–¥–µ—Ç —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω–∞ –ø–æ–∑–∂–µ –ø—Ä–∏ –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏ —Å SignalMatcher
    logger.info("üïØÔ∏è Getting missing candles for signals...")
    return 0



================================================================================
File: tbot/analysis/message_parser.py
================================================================================
# analysis/message_parser.py
import re
import logging
from datetime import datetime
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass

logger = logging.getLogger(__name__)

@dataclass
class ParseResult:
    """–†–µ–∑—É–ª—å—Ç–∞—Ç –ø–∞—Ä—Å–∏–Ω–≥–∞ —Å–æ–æ–±—â–µ–Ω–∏—è"""
    success: bool
    signal_data: Optional[Dict] = None
    error: Optional[str] = None
    confidence: float = 0.0

class MessageParser:
    """–ü—Ä–æ—Å—Ç–æ–π –∏ —á–µ—Ç–∫–∏–π –ø–∞—Ä—Å–µ—Ä —Ç–æ—Ä–≥–æ–≤—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤"""
    
    VERSION = "2.0.0"
    
    def __init__(self):
        # –ü–∞—Ç—Ç–µ—Ä–Ω—ã –¥–ª—è —Ç–∏–∫–µ—Ä–æ–≤ - –ø—Ä–æ—Å—Ç—ã–µ –∏ —á–µ—Ç–∫–∏–µ
        self.ticker_patterns = [
            r':\s*([A-Z]{3,6})\b',         # ": SPBE" - –æ—Å–Ω–æ–≤–Ω–æ–π –ø–∞—Ç—Ç–µ—Ä–Ω
            r'\$([A-Z]{3,6})\b',           # "$SBER"
            r'\b([A-Z]{3,6})\b(?=\s|$)',   # "SBER " - –æ—Ç–¥–µ–ª—å–Ω–æ —Å—Ç–æ—è—â–∏–π
        ]
        
        # –ü–†–û–°–¢–´–ï –ø—Ä–∞–≤–∏–ª–∞ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è
        self.entry_patterns = {
            'long': [
                r'(?i)\b(–≤—Ö–æ–¥|–∫—É–ø–∏–ª|–ø–æ–∫—É–ø–∫|buy|–Ω–∞–±—Ä–∞–ª)\s+–ª–æ–Ω–≥\b',
                r'(?i)\b(–æ—Ç–∫—Ä—ã–ª|–≤–∑—è–ª)\s+–ª–æ–Ω–≥\b',
                r'(?i)\b(–ª–æ–Ω–≥|long)\s+(–ø–æ|–æ—Ç|–≤|@)',  # "–ª–æ–Ω–≥ –ø–æ —Ü–µ–Ω–µ"
            ],
            'short': [
                r'(?i)\b(–≤—Ö–æ–¥|–ø—Ä–æ–¥–∞–ª|–ø—Ä–æ–¥–∞–∂|sell|–Ω–∞–±—Ä–∞–ª)\s+—à–æ—Ä—Ç\b',
                r'(?i)\b(–æ—Ç–∫—Ä—ã–ª|–≤–∑—è–ª)\s+—à–æ—Ä—Ç\b',
                r'(?i)\b(—à–æ—Ä—Ç|short)\s+(–ø–æ|–æ—Ç|–≤|@)',  # "—à–æ—Ä—Ç –ø–æ —Ü–µ–Ω–µ"
            ]
        }
        
        # –ß–ï–¢–ö–ò–ï –ø—Ä–∞–≤–∏–ª–∞ –¥–ª—è –≤—ã—Ö–æ–¥–∞/–∏–∑–º–µ–Ω–µ–Ω–∏—è –ø–æ–∑–∏—Ü–∏–π
        self.exit_patterns = [
            r'(?i)\b(—Å–æ–∫—Ä–∞—Ç–∏–ª|—É–º–µ–Ω—å—à–∏–ª|reduce)\s+(–ª–æ–Ω–≥|—à–æ—Ä—Ç|long|short)\b',  # "—Å–æ–∫—Ä–∞—Ç–∏–ª –ª–æ–Ω–≥"
            r'(?i)\b(—É–≤–µ–ª–∏—á–∏–ª|–¥–æ–±–∞–≤–∏–ª|add)\s+(–ª–æ–Ω–≥|—à–æ—Ä—Ç|long|short)\b',      # "—É–≤–µ–ª–∏—á–∏–ª –ª–æ–Ω–≥"
            r'(?i)\b(–∑–∞–∫—Ä—ã–ª|—Ñ–∏–∫—Å|–≤–∑—è–ª|close)\s*(–ª–æ–Ω–≥|—à–æ—Ä—Ç|long|short)?\b',   # "–∑–∞–∫—Ä—ã–ª –ª–æ–Ω–≥"
            r'(?i)\b(–≤—ã—Ö–æ–¥|exit)\s*(–∏–∑)?\s*(–ª–æ–Ω–≥|—à–æ—Ä—Ç|long|short)?\b',       # "–≤—ã—Ö–æ–¥ –∏–∑ –ª–æ–Ω–≥–∞"
            r'(?i)\b(—Å—Ç–æ–ø|stop)\s*(–ø–æ)?\s*(–ª–æ–Ω–≥|—à–æ—Ä—Ç|long|short)?\b',        # "—Å—Ç–æ–ø –ø–æ –ª–æ–Ω–≥—É"
            r'(?i)(–ª–æ–Ω–≥|—à–æ—Ä—Ç|long|short)\s*üêÉ\s*:',                          # "–ª–æ–Ω–≥üêÉ:"
            r'(?i)(–ª–æ–Ω–≥|—à–æ—Ä—Ç|long|short)\s*üêª\s*:',                          # "—à–æ—Ä—Çüêª:"
        ]
        
        # –ü—Ä–æ—Å—Ç—ã–µ —Ç–æ—Ä–≥–æ–≤—ã–µ –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞
        self.trading_keywords = [
            r'(?i)\b(—Å–¥–µ–ª–∫–∞|–ø–æ–∑–∏—Ü–∏—è|—Å–∏–≥–Ω–∞–ª)\b',
            r'(?i)\b(–ª–æ–Ω–≥|—à–æ—Ä—Ç|long|short)\b',
            r'(?i)\b(—Å–æ–∫—Ä–∞—Ç–∏–ª|—É–≤–µ–ª–∏—á–∏–ª|–∑–∞–∫—Ä—ã–ª|–æ—Ç–∫—Ä—ã–ª)\b',
            r'(?i)\b(–∫—É–ø–∏–ª|–ø—Ä–æ–¥–∞–ª|buy|sell)\b',
        ]
        
        # –ü–∞—Ç—Ç–µ—Ä–Ω—ã –¥–ª—è –∞–≤—Ç–æ—Ä–∞
        self.author_patterns = [
            r'#([A-Za-z0-9_]+)\s*[-‚Äì]',    # "#ProfitKing -" –∏–ª–∏ "#ProfitKing ‚Äì"
            r'#([A-Za-z0-9_]+)\b',         # –ø—Ä–æ—Å—Ç–æ "#ProfitKing"
        ]
    
    def parse_raw_message(self, raw_message: Dict) -> ParseResult:
        """–û—Å–Ω–æ–≤–Ω–æ–π –º–µ—Ç–æ–¥ –ø–∞—Ä—Å–∏–Ω–≥–∞"""
        try:
            text = raw_message.get('text', '')
            if not text or not text.strip():
                return ParseResult(success=False, error="Empty message text")
            
            # –û—á–∏—â–∞–µ–º –º—É—Å–æ—Ä
            cleaned_text = self._clean_message_text(text)
            logger.debug(f"Cleaned text: {cleaned_text}")
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–æ—Ä–≥–æ–≤–æ–µ –ª–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ
            if not self._is_trading_message(cleaned_text):
                return ParseResult(success=False, error="Not a trading message")
            
            # –ò–∑–≤–ª–µ–∫–∞–µ–º –æ—Å–Ω–æ–≤–Ω—ã–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã
            ticker = self._extract_ticker(cleaned_text)
            if not ticker:
                return ParseResult(success=False, error="No ticker found")
            
            # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø –æ–ø–µ—Ä–∞—Ü–∏–∏ –∏ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
            operation_type, direction = self._analyze_operation(cleaned_text)
            
            author = self._extract_author(cleaned_text, raw_message.get('author_username'))
            prices = self._extract_prices(cleaned_text)
            confidence = self._calculate_confidence(cleaned_text, ticker, direction, operation_type)
            
            # –§–æ—Ä–º–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
            signal_data = {
                'raw_message_id': raw_message['id'],
                'parser_version': self.VERSION,
                'timestamp': raw_message['timestamp'],
                'channel_id': raw_message['channel_id'],
                'author': author,
                'original_text': text,
                'ticker': ticker,
                'direction': direction,
                'signal_type': operation_type,
                'target_price': prices.get('target'),
                'stop_loss': prices.get('stop_loss'),
                'take_profit': prices.get('take_profit'),
                'confidence_score': confidence,
                'extracted_data': {
                    'cleaned_text': cleaned_text,
                    'operation_analysis': self._debug_operation_analysis(cleaned_text),
                    'all_tickers': self._extract_all_tickers(cleaned_text),
                    'all_prices': self._extract_all_numbers(cleaned_text),
                    'raw_message_id': raw_message['id']
                }
            }
            
            logger.info(f"‚úÖ Parsed message {raw_message['id']}: "
                       f"ticker={ticker}, direction={direction}, operation={operation_type}, confidence={confidence}")
            
            return ParseResult(success=True, signal_data=signal_data, confidence=confidence)
            
        except Exception as e:
            logger.error(f"‚ùå Error parsing message {raw_message.get('id')}: {e}")
            return ParseResult(success=False, error=f"Exception: {str(e)}")
    
    def _clean_message_text(self, text: str) -> str:
        """–û—á–∏—Å—Ç–∫–∞ –º—É—Å–æ—Ä–∞ –∏–∑ —Å–æ–æ–±—â–µ–Ω–∏—è"""
        cleaned = text
        
        # –£–¥–∞–ª—è–µ–º –º—É—Å–æ—Ä–Ω—ã–µ —á–∞—Å—Ç–∏
        garbage_patterns = [
            r'–ë–æ–ª—å—à–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏.*?(?=\n|$)',          # "–ë–æ–ª—å—à–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏..."
            r'üëâ\[@–∫–æ–ø–∏–∏.*?\].*?(?=\n|$)',           # –°—Å—ã–ª–∫–∏ –Ω–∞ –∫–æ–ø–∏–∏
            r'\[.*?\]\(https://t\.me/.*?\)',         # Markdown —Å—Å—ã–ª–∫–∏
            r'https://t\.me/\S+',                    # –ü—Ä—è–º—ã–µ —Å—Å—ã–ª–∫–∏
            r'@\w+_?bot\S*',                         # –ë–æ—Ç—ã
        ]
        
        for pattern in garbage_patterns:
            cleaned = re.sub(pattern, '', cleaned, flags=re.IGNORECASE)
        
        # –£–±–∏—Ä–∞–µ–º –ª–∏—à–Ω–∏–µ –ø—Ä–æ–±–µ–ª—ã
        cleaned = re.sub(r'\n\s*\n', '\n', cleaned)
        cleaned = cleaned.strip()
        
        return cleaned
    
    def _is_trading_message(self, text: str) -> bool:
        """–ü—Ä–æ—Å—Ç–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —Ç–æ—Ä–≥–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ"""
        # –ï—Å—Ç—å —Ç–æ—Ä–≥–æ–≤—ã–µ –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞?
        has_keywords = any(re.search(pattern, text) for pattern in self.trading_keywords)
        
        # –ï—Å—Ç—å —Ç–∏–∫–µ—Ä?
        has_ticker = any(re.search(pattern, text) for pattern in self.ticker_patterns)
        
        # –ï—Å—Ç—å —Ç–æ—Ä–≥–æ–≤—ã–µ —ç–º–æ–¥–∑–∏?
        trading_emojis = ['üêÉ', 'üêª', 'üìà', 'üìâ', '‚≠êÔ∏è']
        has_emoji = any(emoji in text for emoji in trading_emojis)
        
        result = has_keywords or has_ticker or has_emoji
        
        logger.debug(f"Trading check: keywords={has_keywords}, ticker={has_ticker}, "
                    f"emoji={has_emoji} -> {result}")
        
        return result
    
    def _extract_ticker(self, text: str) -> Optional[str]:
        """–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ —Ç–∏–∫–µ—Ä–∞"""
        for pattern in self.ticker_patterns:
            match = re.search(pattern, text)
            if match:
                ticker = match.group(1).upper()
                if 3 <= len(ticker) <= 6 and ticker.isalpha():
                    # –ò—Å–∫–ª—é—á–∞–µ–º –ª–æ–∂–Ω—ã–µ —Å—Ä–∞–±–∞—Ç—ã–≤–∞–Ω–∏—è
                    if ticker not in ['VIP', 'BOT', 'NEW', 'TOP', 'WIN', 'BUY', 'SELL']:
                        logger.debug(f"Found ticker: {ticker}")
                        return ticker
        return None
    
    def _extract_all_tickers(self, text: str) -> List[str]:
        """–í—Å–µ –Ω–∞–π–¥–µ–Ω–Ω—ã–µ —Ç–∏–∫–µ—Ä—ã"""
        tickers = set()
        for pattern in self.ticker_patterns:
            matches = re.findall(pattern, text)
            for match in matches:
                ticker = match.upper()
                if 3 <= len(ticker) <= 6 and ticker.isalpha():
                    if ticker not in ['VIP', 'BOT', 'NEW', 'TOP', 'WIN', 'BUY', 'SELL']:
                        tickers.add(ticker)
        return list(tickers)
    
    def _analyze_operation(self, text: str) -> Tuple[str, str]:
        """
        –ê–Ω–∞–ª–∏–∑ –æ–ø–µ—Ä–∞—Ü–∏–∏ - –ö–õ–Æ–ß–ï–í–ê–Ø –õ–û–ì–ò–ö–ê
        
        Returns:
            Tuple[operation_type, direction] –≥–¥–µ:
            operation_type: 'entry' | 'exit' | 'update'
            direction: 'long' | 'short' | 'mixed'
        """
        
        # 1. –ü—Ä–æ–≤–µ—Ä—è–µ–º EXIT/UPDATE –æ–ø–µ—Ä–∞—Ü–∏–∏ (–ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç!)
        for pattern in self.exit_patterns:
            match = re.search(pattern, text)
            if match:
                logger.debug(f"Found exit pattern: {pattern} -> {match.group()}")
                
                # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∏–∑ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
                if re.search(r'(?i)(–ª–æ–Ω–≥|long)', match.group()):
                    return 'exit', 'long'  # –°–æ–∫—Ä–∞—Ç–∏–ª –ª–æ–Ω–≥ = –ø—Ä–æ–¥–∞–ª –¥–ª–∏–Ω–Ω—É—é –ø–æ–∑–∏—Ü–∏—é
                elif re.search(r'(?i)(—à–æ—Ä—Ç|short)', match.group()):
                    return 'exit', 'short'  # –°–æ–∫—Ä–∞—Ç–∏–ª —à–æ—Ä—Ç = –∑–∞–∫—Ä—ã–ª –∫–æ—Ä–æ—Ç–∫—É—é –ø–æ–∑–∏—Ü–∏—é
                else:
                    return 'exit', 'mixed'  # –ù–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
        
        # 2. –ü—Ä–æ–≤–µ—Ä—è–µ–º ENTRY –æ–ø–µ—Ä–∞—Ü–∏–∏
        for direction, patterns in self.entry_patterns.items():
            for pattern in patterns:
                if re.search(pattern, text):
                    logger.debug(f"Found entry pattern for {direction}: {pattern}")
                    return 'entry', direction
        
        # 3. –ï—Å–ª–∏ –Ω–∏—á–µ–≥–æ –Ω–µ –Ω–∞—à–ª–∏, –Ω–æ –µ—Å—Ç—å —É–ø–æ–º–∏–Ω–∞–Ω–∏—è –ª–æ–Ω–≥/—à–æ—Ä—Ç
        if re.search(r'(?i)\b(–ª–æ–Ω–≥|long)\b', text):
            return 'entry', 'long'  # –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é —Å—á–∏—Ç–∞–µ–º –≤—Ö–æ–¥–æ–º
        elif re.search(r'(?i)\b(—à–æ—Ä—Ç|short)\b', text):
            return 'entry', 'short'
        
        # 4. –°–æ–≤—Å–µ–º –Ω–∏—á–µ–≥–æ –Ω–µ –Ω–∞—à–ª–∏
        return 'entry', 'mixed'
    
    def _debug_operation_analysis(self, text: str) -> Dict:
        """–û—Ç–ª–∞–¥–æ—á–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ –æ–ø–µ—Ä–∞—Ü–∏–π"""
        debug_info = {
            'exit_matches': [],
            'entry_matches': [],
            'direction_words': []
        }
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º exit –ø–∞—Ç—Ç–µ—Ä–Ω—ã
        for pattern in self.exit_patterns:
            matches = re.findall(pattern, text, re.IGNORECASE)
            if matches:
                debug_info['exit_matches'].append({'pattern': pattern, 'matches': matches})
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º entry –ø–∞—Ç—Ç–µ—Ä–Ω—ã
        for direction, patterns in self.entry_patterns.items():
            for pattern in patterns:
                matches = re.findall(pattern, text, re.IGNORECASE)
                if matches:
                    debug_info['entry_matches'].append({
                        'direction': direction, 
                        'pattern': pattern, 
                        'matches': matches
                    })
        
        # –ò—â–µ–º —Å–ª–æ–≤–∞ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–π
        direction_words = re.findall(r'(?i)\b(–ª–æ–Ω–≥|—à–æ—Ä—Ç|long|short)\b', text)
        debug_info['direction_words'] = direction_words
        
        return debug_info
    
    def _extract_author(self, text: str, fallback: Optional[str] = None) -> str:
        """–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –∞–≤—Ç–æ—Ä–∞"""
        for pattern in self.author_patterns:
            match = re.search(pattern, text)
            if match:
                return match.group(1)
        return fallback or 'Unknown'
    
    def _extract_prices(self, text: str) -> Dict[str, Optional[float]]:
        """–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ —Ü–µ–Ω (–ø–æ–∫–∞ –ø—Ä–æ—Å—Ç–∞—è –≤–µ—Ä—Å–∏—è)"""
        prices = {'target': None, 'stop_loss': None, 'take_profit': None}
        
        # –ò—â–µ–º —á–∏—Å–ª–∞ —Å –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–º
        price_patterns = {
            'target': [
                r'(?:—Ü–µ–ª|target|—Ç–∞—Ä–≥–µ—Ç|@)\s*:?\s*(\d+(?:[.,]\d+)?)',
                r'(?:–ø–æ|–æ—Ç)\s+(\d+(?:[.,]\d+)?)',
            ],
            'stop_loss': [
                r'(?:—Å—Ç–æ–ø|stop)\s*:?\s*(\d+(?:[.,]\d+)?)',
            ],
            'take_profit': [
                r'(?:—Ç–µ–π–∫|take|–ø—Ä–æ—Ñ–∏—Ç)\s*:?\s*(\d+(?:[.,]\d+)?)',
            ]
        }
        
        for price_type, patterns in price_patterns.items():
            for pattern in patterns:
                match = re.search(pattern, text, re.IGNORECASE)
                if match:
                    try:
                        price = float(match.group(1).replace(',', '.'))
                        if 0.01 <= price <= 100000:
                            prices[price_type] = price
                            break
                    except ValueError:
                        continue
        
        return prices
    
    def _extract_all_numbers(self, text: str) -> List[float]:
        """–í—Å–µ —á–∏—Å–ª–∞ –∏–∑ —Ç–µ–∫—Å—Ç–∞"""
        numbers = []
        for match in re.finditer(r'\d+(?:[.,]\d+)?', text):
            try:
                number = float(match.group().replace(',', '.'))
                if 0.01 <= number <= 100000:
                    numbers.append(number)
            except ValueError:
                continue
        return numbers
    
    def _calculate_confidence(self, text: str, ticker: str, direction: str, operation: str) -> float:
        """–†–∞—Å—á–µ—Ç —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç–∏"""
        confidence = 0.0
        
        # –ë–∞–∑–æ–≤—ã–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã
        if ticker:
            confidence += 0.4
        if direction and direction != 'mixed':
            confidence += 0.3
        if operation:
            confidence += 0.2
        
        # –ë–æ–Ω—É—Å—ã
        if len(text.split()) > 3:
            confidence += 0.05
        if any(keyword in text.lower() for keyword in ['—Å–¥–µ–ª–∫–∞', '–ø–æ–∑–∏—Ü–∏—è', '—Å–∏–≥–Ω–∞–ª']):
            confidence += 0.05
        
        return min(confidence, 1.0)

class MessageParsingService:
    """–°–µ—Ä–≤–∏—Å –¥–ª—è –º–∞—Å—Å–æ–≤–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏–π"""
    
    def __init__(self, db_manager, parser: MessageParser = None):
        self.db = db_manager
        self.parser = parser or MessageParser()
    
    def parse_all_unprocessed_messages(self, limit: Optional[int] = None) -> Dict:
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—Å–µ—Ö –Ω–µ—Ä–∞–∑–æ–±—Ä–∞–Ω–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π"""
        try:
            unprocessed = self._get_unprocessed_messages(limit)
            
            stats = {
                'total_processed': 0,
                'successful_parses': 0,
                'failed_parses': 0,
                'trading_messages': 0,
                'non_trading_messages': 0,
                'errors': []
            }
            
            logger.info(f"Starting to parse {len(unprocessed)} messages...")
            
            for message in unprocessed:
                try:
                    stats['total_processed'] += 1
                    
                    result = self.parser.parse_raw_message(message)
                    
                    if result.success:
                        signal_id = self.db.save_signal(result.signal_data)
                        if signal_id:
                            stats['successful_parses'] += 1
                            stats['trading_messages'] += 1
                        else:
                            stats['failed_parses'] += 1
                    else:
                        stats['failed_parses'] += 1
                        if result.error != "Not a trading message":
                            stats['errors'].append(f"Message {message['id']}: {result.error}")
                        else:
                            stats['non_trading_messages'] += 1
                    
                    self._mark_message_processed(message['id'])
                    
                    if stats['total_processed'] % 50 == 0:
                        logger.info(f"Processed {stats['total_processed']}/{len(unprocessed)}...")
                
                except Exception as e:
                    stats['failed_parses'] += 1
                    stats['errors'].append(f"Message {message['id']}: {str(e)}")
                    logger.error(f"Error processing message {message['id']}: {e}")
            
            logger.info(f"Parsing completed: {stats}")
            return stats
            
        except Exception as e:
            logger.error(f"Error in parse_all_unprocessed_messages: {e}")
            return {'error': str(e)}
    
    def _get_unprocessed_messages(self, limit: Optional[int] = None) -> List[Dict]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –Ω–µ—Ä–∞–∑–æ–±—Ä–∞–Ω–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π"""
        try:
            with self.db.session() as session:
                from core.database import RawMessage
                
                query = session.query(RawMessage).filter(
                    RawMessage.is_processed == False,
                    RawMessage.text.isnot(None),
                    RawMessage.text != ''
                ).order_by(RawMessage.timestamp)
                
                if limit:
                    query = query.limit(limit)
                
                messages = query.all()
                
                return [
                    {
                        'id': msg.id,
                        'text': msg.text,
                        'timestamp': msg.timestamp,
                        'channel_id': msg.channel_id,
                        'author_username': msg.author_username,
                        'message_id': msg.message_id
                    }
                    for msg in messages
                ]
        except Exception as e:
            logger.error(f"Error getting unprocessed messages: {e}")
            return []
    
    def _mark_message_processed(self, message_id: int) -> bool:
        """–ü–æ–º–µ—Ç–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è –∫–∞–∫ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω–æ–≥–æ"""
        try:
            with self.db.session() as session:
                from core.database import RawMessage
                
                message = session.query(RawMessage).filter(
                    RawMessage.id == message_id
                ).first()
                
                if message:
                    message.is_processed = True
                    message.processing_attempts = (message.processing_attempts or 0) + 1
                    return True
                
                return False
        except Exception as e:
            logger.error(f"Error marking message as processed: {e}")
            return False

================================================================================
File: tbot/analysis/signal_matcher.py
================================================================================
# analysis/signal_matcher.py - –ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø –í–ï–†–°–ò–Ø
import logging
from typing import List, Dict, Optional, Tuple
from datetime import datetime, timedelta, timezone  # ‚úÖ –î–û–ë–ê–í–ò–õ–ò timezone
from dataclasses import dataclass
from utils.datetime_utils import now_utc, utc_from_minutes_ago, ensure_timezone_aware, days_between_utc
from core.database import Database
from core.database import ParsedSignal, SignalResult, ChartDataPoint

logger = logging.getLogger(__name__)

@dataclass
class PriceMatch:
    """–†–µ–∑—É–ª—å—Ç–∞—Ç —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏—è —Å–∏–≥–Ω–∞–ª–∞ —Å —Ü–µ–Ω–æ–π"""
    signal_id: str
    signal_time: datetime
    target_price: Optional[float]
    actual_price: float
    price_time: datetime
    slippage_pct: float
    delay_minutes: int

class SignalMatcher:
    """–ö–ª–∞—Å—Å –¥–ª—è —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏—è —Ç–æ—Ä–≥–æ–≤—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤ —Å —Ä—ã–Ω–æ—á–Ω—ã–º–∏ —Ü–µ–Ω–∞–º–∏ + Tinkoff API"""
    
    def __init__(self, db_manager: Database, tinkoff_client=None):
        self.db = db_manager
        self.tinkoff = tinkoff_client 
        self.tracking_timeout_hours = 24
        
    # ===== –û–ë–ù–û–í–õ–ï–ù–ù–´–ï –ú–ï–¢–û–î–´ –î–õ–Ø –†–ê–ë–û–¢–´ –° TINKOFF API =====

    async def _find_entry_price(self, signal: Dict, figi: str) -> Optional[PriceMatch]:
        """
        üîÑ –û–ë–ù–û–í–õ–ï–ù–û: –ü–æ–∏—Å–∫ —Ü–µ–Ω—ã –≤—Ö–æ–¥–∞ –¥–ª—è —Å–∏–≥–Ω–∞–ª–∞ (–±–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö + API)
        """
        try:
            signal_time = ensure_timezone_aware(signal['timestamp'])  # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û
            search_end = signal_time + timedelta(hours=1)
            
            # ‚ú® –°–ù–ê–ß–ê–õ–ê –ü–´–¢–ê–ï–ú–°–Ø –ù–ê–ô–¢–ò –í –ë–ê–ó–ï –î–ê–ù–ù–´–•
            candles = self.db.get_candles(
                figi,  # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û: —É–±—Ä–∞–ª–∏ instrument_id=
                interval='5min',  # üîÑ –ò–ó–ú–ï–ù–ï–ù–û: 5min –¥–ª—è –ª—É—á—à–µ–≥–æ –ø–æ–∫—Ä—ã—Ç–∏—è
                from_time=signal_time,
                to_time=search_end,
                limit=12  # 12 —Å–≤–µ—á–µ–π –ø–æ 5 –º–∏–Ω = 1 —á–∞—Å
            )
            
            if candles:
                # –ù–∞—à–ª–∏ –≤ –±–∞–∑–µ - –∏—Å–ø–æ–ª—å–∑—É–µ–º –∫–∞–∫ —Ä–∞–Ω—å—à–µ
                first_candle = candles[0]
                entry_price = first_candle['open']
                entry_time = ensure_timezone_aware(first_candle['time'])  # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û
                
                logger.info(f"üíæ Found entry price in database: {entry_price} for {signal['ticker']}")
                
            else:
                # ‚ú® –ù–ï–¢ –í –ë–ê–ó–ï - –ò–°–ü–û–õ–¨–ó–£–ï–ú API
                if not self.tinkoff:
                    logger.error("‚ùå No DB data and Tinkoff API not available")
                    return None
                
                logger.info(f"üåê Getting entry price via API for {signal['ticker']}")
                price_data = await self.tinkoff.get_current_price(signal['ticker'])
                
                if not price_data:
                    return None
                
                entry_price = price_data['price']
                entry_time = now_utc()  # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û: timezone-aware
                
                logger.info(f"üåê Entry price via API: {entry_price}")
            
            # –í—ã—á–∏—Å–ª—è–µ–º –ø—Ä–æ—Å–∫–∞–ª—å–∑—ã–≤–∞–Ω–∏–µ
            target_price = signal.get('target_price')
            slippage_pct = 0.0
            
            if target_price:
                slippage_pct = ((entry_price - target_price) / target_price) * 100
            
            # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û: –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –≤—ã—á–∏—Å–ª–µ–Ω–∏–µ —Ä–∞–∑–Ω–æ—Å—Ç–∏ –≤—Ä–µ–º–µ–Ω–∏
            delay_minutes = int((entry_time - signal_time).total_seconds() / 60)
            
            return PriceMatch(
                signal_id=signal['id'],
                signal_time=signal_time,
                target_price=target_price,
                actual_price=entry_price,
                price_time=entry_time,
                slippage_pct=slippage_pct,
                delay_minutes=delay_minutes
            )
            
        except Exception as e:
            logger.error(f"‚ùå Error finding entry price: {e}")
            return None

    async def _check_exit_conditions(self, position: Dict, signal: Dict, figi: str) -> Optional[Dict]:
        """
        üîÑ –û–ë–ù–û–í–õ–ï–ù–û: –ü—Ä–æ–≤–µ—Ä–∫–∞ —É—Å–ª–æ–≤–∏–π –≤—ã—Ö–æ–¥–∞ (–±–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö + API)
        """
        try:
            current_time = now_utc()  # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û: timezone-aware
            direction = signal['direction']
            
            # –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â—É—é —Ü–µ–Ω—É
            current_price = await self._get_current_price(figi, signal['ticker'])
            if not current_price:
                return None
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º stop-loss
            if signal.get('stop_loss'):
                stop_loss = float(signal['stop_loss'])
                if direction == 'long' and current_price <= stop_loss:
                    return {'price': current_price, 'time': current_time, 'reason': 'stop_loss'}
                elif direction == 'short' and current_price >= stop_loss:
                    return {'price': current_price, 'time': current_time, 'reason': 'stop_loss'}
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º take-profit
            if signal.get('take_profit'):
                take_profit = float(signal['take_profit'])
                if direction == 'long' and current_price >= take_profit:
                    return {'price': current_price, 'time': current_time, 'reason': 'take_profit'}
                elif direction == 'short' and current_price <= take_profit:
                    return {'price': current_price, 'time': current_time, 'reason': 'take_profit'}
            
            return None
            
        except Exception as e:
            logger.error(f"‚ùå Error checking exit conditions: {e}")
            return None

    async def _get_current_price(self, figi: str, ticker: str = None) -> Optional[float]:
        """
        üîÑ –û–ë–ù–û–í–õ–ï–ù–û: –ü–æ–ª—É—á–µ–Ω–∏–µ —Ç–µ–∫—É—â–µ–π —Ü–µ–Ω—ã (–±–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö + API)
        """
        try:
            # –ü—ã—Ç–∞–µ–º—Å—è –ø–æ–ª—É—á–∏—Ç—å –∏–∑ –±–∞–∑—ã
            candles = self.db.get_candles(
                figi,  # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û: —É–±—Ä–∞–ª–∏ instrument_id=
                interval='5min',  # üîÑ –ò–ó–ú–ï–ù–ï–ù–û: 5min
                from_time=utc_from_minutes_ago(25),  # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û: timezone-aware
                limit=1
            )
            
            if candles:
                price = candles[0]['close']
                logger.debug(f"üíæ Current price from DB: {price}")
                return float(price)
            
            # üÜï –ù–ï–¢ –í –ë–ê–ó–ï - –ü–´–¢–ê–ï–ú–°–Ø –ß–ï–†–ï–ó API
            if self.tinkoff:
                logger.debug(f"üåê Getting current price via API for {ticker or figi}")
                price_data = await self.tinkoff.get_current_price(ticker or figi)
                
                if price_data and 'price' in price_data:
                    price = float(price_data['price'])
                    logger.debug(f"üåê Current price from API: {price}")
                    return price
            
            logger.warning(f"‚ö†Ô∏è No price data available for {ticker or figi}")
            return None
            
        except Exception as e:
            logger.error(f"‚ùå Error getting current price: {e}")
            return None
    # ===== –ù–û–í–´–ï –ú–ï–¢–û–î–´ –î–õ–Ø –†–ê–ë–û–¢–´ –° TINKOFF =====
    
    async def ensure_instrument_in_database(self, ticker: str) -> Optional[str]:
        """
        ‚ú® –£–±–µ–∂–¥–∞–µ–º—Å—è —á—Ç–æ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç –µ—Å—Ç—å –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö
        """
        try:
            # –ò—â–µ–º –≤ –±–∞–∑–µ
            instrument = self.db.get_instrument_by_ticker(ticker)
            if instrument:
                return instrument['figi']
            
            # –ù–µ—Ç –≤ –±–∞–∑–µ - –ø–æ–ø—ã—Ç–∞–µ–º—Å—è –Ω–∞–π—Ç–∏ —á–µ—Ä–µ–∑ API
            if not self.tinkoff:
                logger.error(f"‚ùå Instrument {ticker} not in DB and no API available")
                return None
            
            logger.info(f"üîç Searching instrument {ticker} via API...")
            api_instrument = await self.tinkoff.find_instrument_by_ticker(ticker)
            
            if not api_instrument:
                logger.error(f"‚ùå Instrument {ticker} not found via API")
                return None
            
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –±–∞–∑—É
            self.db.save_instrument(
                figi=api_instrument["figi"],
                ticker=ticker,
                name=api_instrument["name"],
                instrument_type=api_instrument.get("type", "share")
            )
            
            logger.info(f"‚úÖ Added instrument {ticker} to database")
            return api_instrument["figi"]
            
        except Exception as e:
            logger.error(f"‚ùå Error ensuring instrument {ticker} in database: {e}")
            return None
    
    async def process_untracked_signals(self, limit: int = 50) -> int:
        """
        üîÑ –û–ë–ù–û–í–õ–ï–ù–û: –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–∏–≥–Ω–∞–ª–æ–≤ –±–µ–∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è
        """
        try:
            untracked_signals = self._get_untracked_signals(limit)
            processed = 0
            
            for signal in untracked_signals:
                try:
                    figi = await self.ensure_instrument_in_database(signal['ticker'])
                    if not figi:
                        logger.warning(f"‚ö†Ô∏è Cannot process signal - instrument {signal['ticker']} not available")
                        continue
                    
                    # –ù–∞—Ö–æ–¥–∏–º —Ü–µ–Ω—É –≤—Ö–æ–¥–∞ (—Ç–µ–ø–µ—Ä—å —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π API)
                    entry_match = await self._find_entry_price(signal, figi)
                    if entry_match:
                        result_data = {
                            'planned_entry_price': signal.get('target_price'),
                            'actual_entry_price': entry_match.actual_price,
                            'entry_time': entry_match.price_time,
                            'status': 'active'
                        }
                        result_id = self.db.save_signal_result(signal['id'], result_data)
                        
                        if result_id:
                            processed += 1
                            logger.info(f"‚úÖ Started tracking signal {signal['id']}: {signal['ticker']} "
                                      f"@ {entry_match.actual_price}")
                    
                except Exception as e:
                    logger.error(f"‚ùå Error processing signal {signal['id']}: {e}")
                    continue
            
            logger.info(f"üìä Started tracking {processed} new signals")
            return processed
            
        except Exception as e:
            logger.error(f"‚ùå Error in process_untracked_signals: {e}")
            return 0

    async def update_active_positions(self) -> int:
        """
        üîÑ –û–ë–ù–û–í–õ–ï–ù–û: –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∞–∫—Ç–∏–≤–Ω—ã—Ö –ø–æ–∑–∏—Ü–∏–π —Å –ø—Ä–æ–≤–µ—Ä–∫–æ–π –≤—ã—Ö–æ–¥–æ–≤
        """
        try:
            active_positions = self._get_active_positions()
            updated = 0
            
            logger.info(f"üìä Checking {len(active_positions)} active positions...")
            
            for position in active_positions:
                try:
                    # –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Å–∏–≥–Ω–∞–ª–µ
                    signal = self._get_signal_by_id(position['signal_id'])
                    if not signal:
                        continue
                    
                    # ‚ú® –£–ë–ï–ñ–î–ê–ï–ú–°–Ø –ß–¢–û –ò–ù–°–¢–†–£–ú–ï–ù–¢ –ï–°–¢–¨ –í –ë–ê–ó–ï
                    figi = await self.ensure_instrument_in_database(signal['ticker'])
                    if not figi:
                        continue
                    
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —É—Å–ª–æ–≤–∏—è –≤—ã—Ö–æ–¥–∞ (—Ç–µ–ø–µ—Ä—å —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π API)
                    exit_result = await self._check_exit_conditions(position, signal, figi)
                    
                    if exit_result:
                        # –ó–∞–∫—Ä—ã–≤–∞–µ–º –ø–æ–∑–∏—Ü–∏—é
                        self.db.update_signal_result(
                            position['id'],  # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û: result_id
                            {  # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û: updates –∫–∞–∫ —Å–ª–æ–≤–∞—Ä—å
                                'exit_price': exit_result['price'],
                                'exit_time': exit_result['time'],
                                'exit_reason': exit_result['reason'],
                                'status': 'closed'
                            }
                        )
                        updated += 1
                        logger.info(f"‚úÖ Closed position {position['signal_id']}: "
                                f"{exit_result['reason']} @ {exit_result['price']}")
                    
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–∞–π–º–∞—É—Ç
                    elif self._is_position_expired(position):
                        current_price = await self._get_current_price(figi, signal['ticker'])
                        if current_price:
                            self.db.update_signal_result(
                                position['id'],  # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û: result_id  
                                {  # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û: updates –∫–∞–∫ —Å–ª–æ–≤–∞—Ä—å
                                    'exit_price': current_price,
                                    'exit_time': now_utc(),  # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û
                                    'exit_reason': 'timeout',
                                    'status': 'closed'
                                }
                            )
                            updated += 1
                            logger.info(f"‚è∞ Closed expired position {position['signal_id']} @ {current_price}")
                
                except Exception as e:
                    logger.error(f"‚ùå Error updating position {position['signal_id']}: {e}")
                    continue
            
            logger.info(f"üìà Updated {updated} active positions")
            return updated
            
        except Exception as e:
            logger.error(f"‚ùå Error in update_active_positions: {e}")
            return 0    

    # ===== –û–°–¢–ê–õ–¨–ù–´–ï –ú–ï–¢–û–î–´ –û–°–¢–ê–Æ–¢–°–Ø –ë–ï–ó –ò–ó–ú–ï–ù–ï–ù–ò–ô =====
    
    def _get_untracked_signals(self, limit: int) -> List[Dict]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å–∏–≥–Ω–∞–ª–æ–≤ –±–µ–∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è (–±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π)"""
        try:
            with self.db.session() as session:
                # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û: –ò—Å–ø–æ–ª—å–∑—É–µ–º timezone-aware –¥–∞—Ç—É –¥–ª—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏
                from_date = now_utc() - timedelta(days=7)
                
                signals = session.query(ParsedSignal).outerjoin(SignalResult).filter(
                    SignalResult.id.is_(None),
                    ParsedSignal.direction.in_(['long', 'short']),
                    ParsedSignal.timestamp >= from_date
                ).order_by(ParsedSignal.timestamp).limit(limit).all()
                
                return [
                    {
                        'id': str(signal.id),
                        'ticker': signal.ticker,
                        'direction': signal.direction,
                        'target_price': float(signal.target_price) if signal.target_price else None,
                        'timestamp': signal.timestamp,
                        'trader': signal.author
                    }
                    for signal in signals
                ]
        except Exception as e:
            logger.error(f"‚ùå Error getting untracked signals: {e}")
        return []
    
    def _get_active_positions(self) -> List[Dict]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –∞–∫—Ç–∏–≤–Ω—ã—Ö –ø–æ–∑–∏—Ü–∏–π –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è (–±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π)"""
        try:
            with self.db.session() as session:
                results = session.query(SignalResult).filter(
                    SignalResult.status == 'active'
                ).all()
                
                return [
                    {
                        'id': str(result.id),
                        'signal_id': str(result.signal_id),
                        'entry_price': float(result.actual_entry_price),
                        'entry_time': result.entry_time,
                        'tracking_started_at': result.tracking_started_at
                    }
                    for result in results
                ]
        except Exception as e:
            logger.error(f"‚ùå Error getting active positions: {e}")
            return []
    
    def _get_signal_by_id(self, signal_id: str) -> Optional[Dict]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å–∏–≥–Ω–∞–ª–∞ –ø–æ ID (–±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π)"""
        try:
            with self.db.session() as session:
                signal = session.query(ParsedSignal).filter(
                    ParsedSignal.id == signal_id
                ).first()
                
                if not signal:
                    return None
                
                return {
                    'id': str(signal.id),
                    'ticker': signal.ticker,
                    'direction': signal.direction,
                    'target_price': float(signal.target_price) if signal.target_price else None,
                    'stop_loss': float(signal.stop_loss) if signal.stop_loss else None,
                    'take_profit': float(signal.take_profit) if signal.take_profit else None,
                    'timestamp': signal.timestamp,
                    'trader': signal.author
                }
        except Exception as e:
            logger.error(f"‚ùå Error getting signal {signal_id}: {e}")
            return None
    
    def _is_position_expired(self, position: Dict) -> bool:
        """
        –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –∏—Å—Ç–µ—á–µ–Ω–∏–µ —Å—Ä–æ–∫–∞ –ø–æ–∑–∏—Ü–∏–∏
        """
        try:
            tracking_started = ensure_timezone_aware(position['tracking_started_at'])  # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û
            current_time = now_utc()  # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û
            
            hours_tracked = (current_time - tracking_started).total_seconds() / 3600
            return hours_tracked >= self.tracking_timeout_hours
            
        except Exception as e:
            logger.error(f"‚ùå Error checking position expiry: {e}")
            return False

================================================================================
File: tbot/utils/datetime_utils.py
================================================================================
# utils/datetime_utils.py
"""
–£—Ç–∏–ª–∏—Ç—ã –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –¥–∞—Ç–∞–º–∏ –∏ –≤—Ä–µ–º–µ–Ω–Ω—ã–º–∏ –∑–æ–Ω–∞–º–∏
–í—Å–µ –¥–∞—Ç—ã –≤ —Å–∏—Å—Ç–µ–º–µ —Ö—Ä–∞–Ω—è—Ç—Å—è –≤ UTC –∫–∞–∫ –ø—Ä–∏—Ö–æ–¥—è—Ç –æ—Ç Tinkoff API
"""

from datetime import datetime, timezone, timedelta
from typing import Optional, Union
import logging

logger = logging.getLogger(__name__)

def now_utc() -> datetime:
    """
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–µ–∫—É—â–µ–µ –≤—Ä–µ–º—è –≤ UTC —Å timezone
    
    Returns:
        datetime: –¢–µ–∫—É—â–µ–µ –≤—Ä–µ–º—è –≤ UTC timezone-aware
    """
    return datetime.now(timezone.utc)

def ensure_timezone_aware(dt: Union[datetime, None]) -> Optional[datetime]:
    """
    –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ—Ç naive datetime –≤ UTC aware –∏–ª–∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç None
    
    Args:
        dt: datetime –æ–±—ä–µ–∫—Ç –∏–ª–∏ None
        
    Returns:
        datetime: timezone-aware datetime –≤ UTC –∏–ª–∏ None
    """
    if dt is None:
        return None
        
    if dt.tzinfo is None:
        # –ï—Å–ª–∏ timezone –Ω–µ —É–∫–∞–∑–∞–Ω, —Å—á–∏—Ç–∞–µ–º —á—Ç–æ —ç—Ç–æ UTC
        logger.debug(f"Converting naive datetime {dt} to UTC")
        return dt.replace(tzinfo=timezone.utc)
    
    return dt

def utc_from_days_ago(days: int) -> datetime:
    """
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –¥–∞—Ç—É N –¥–Ω–µ–π –Ω–∞–∑–∞–¥ –≤ UTC timezone-aware
    
    Args:
        days: –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–Ω–µ–π –Ω–∞–∑–∞–¥
        
    Returns:
        datetime: –î–∞—Ç–∞ –≤ UTC timezone-aware
    """
    return now_utc() - timedelta(days=days)

def utc_from_minutes_ago(minutes: int) -> datetime:
    """
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –¥–∞—Ç—É N –º–∏–Ω—É—Ç –Ω–∞–∑–∞–¥ –≤ UTC timezone-aware
    
    Args:
        minutes: –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –º–∏–Ω—É—Ç –Ω–∞–∑–∞–¥
        
    Returns:
        datetime: –î–∞—Ç–∞ –≤ UTC timezone-aware
    """
    return now_utc() - timedelta(minutes=minutes)

def days_between_utc(start_dt: datetime, end_dt: datetime) -> int:
    """
    –í—ã—á–∏—Å–ª—è–µ—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–Ω–µ–π –º–µ–∂–¥—É –¥–≤—É–º—è UTC –¥–∞—Ç–∞–º–∏
    
    Args:
        start_dt: –ù–∞—á–∞–ª—å–Ω–∞—è –¥–∞—Ç–∞ (–¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å timezone-aware)
        end_dt: –ö–æ–Ω–µ—á–Ω–∞—è –¥–∞—Ç–∞ (–¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å timezone-aware)
        
    Returns:
        int: –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–Ω–µ–π
    """
    # –û–±–µ—Å–ø–µ—á–∏–≤–∞–µ–º —á—Ç–æ –æ–±–µ –¥–∞—Ç—ã timezone-aware
    start_dt = ensure_timezone_aware(start_dt)
    end_dt = ensure_timezone_aware(end_dt)
    
    if start_dt is None or end_dt is None:
        return 0
        
    return (end_dt - start_dt).days

def is_timezone_aware(dt: datetime) -> bool:
    """
    –ü—Ä–æ–≤–µ—Ä—è–µ—Ç —è–≤–ª—è–µ—Ç—Å—è –ª–∏ datetime timezone-aware
    
    Args:
        dt: datetime –æ–±—ä–µ–∫—Ç
        
    Returns:
        bool: True –µ—Å–ª–∏ timezone-aware
    """
    return dt.tzinfo is not None and dt.tzinfo.utcoffset(dt) is not None

def safe_datetime_comparison(dt1: datetime, dt2: datetime) -> Optional[int]:
    """
    –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ datetime –æ–±—ä–µ–∫—Ç–æ–≤ —Å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–π –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–µ–π –≤ UTC
    
    Args:
        dt1: –ü–µ—Ä–≤–∞—è –¥–∞—Ç–∞
        dt2: –í—Ç–æ—Ä–∞—è –¥–∞—Ç–∞
        
    Returns:
        int: -1 –µ—Å–ª–∏ dt1 < dt2, 0 –µ—Å–ª–∏ —Ä–∞–≤–Ω—ã, 1 –µ—Å–ª–∏ dt1 > dt2, None –ø—Ä–∏ –æ—à–∏–±–∫–µ
    """
    try:
        dt1_utc = ensure_timezone_aware(dt1)
        dt2_utc = ensure_timezone_aware(dt2)
        
        if dt1_utc is None or dt2_utc is None:
            return None
            
        if dt1_utc < dt2_utc:
            return -1
        elif dt1_utc > dt2_utc:
            return 1
        else:
            return 0
            
    except Exception as e:
        logger.error(f"Error comparing datetimes: {e}")
        return None

def format_utc_for_display(dt: datetime, include_timezone: bool = True) -> str:
    """
    –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç UTC –¥–∞—Ç—É –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
    
    Args:
        dt: datetime –æ–±—ä–µ–∫—Ç
        include_timezone: –í–∫–ª—é—á–∞—Ç—å –ª–∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ timezone
        
    Returns:
        str: –û—Ç—Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —Å—Ç—Ä–æ–∫–∞
    """
    dt_utc = ensure_timezone_aware(dt)
    if dt_utc is None:
        return "Unknown"
        
    if include_timezone:
        return dt_utc.strftime("%Y-%m-%d %H:%M:%S UTC")
    else:
        return dt_utc.strftime("%Y-%m-%d %H:%M:%S")

def validate_datetime_range(start_dt: datetime, end_dt: datetime, max_days: int = 365) -> tuple[bool, str]:
    """
    –í–∞–ª–∏–¥–∏—Ä—É–µ—Ç –¥–∏–∞–ø–∞–∑–æ–Ω –¥–∞—Ç
    
    Args:
        start_dt: –ù–∞—á–∞–ª—å–Ω–∞—è –¥–∞—Ç–∞
        end_dt: –ö–æ–Ω–µ—á–Ω–∞—è –¥–∞—Ç–∞  
        max_days: –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–Ω–µ–π –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ
        
    Returns:
        tuple: (is_valid, error_message)
    """
    try:
        start_utc = ensure_timezone_aware(start_dt)
        end_utc = ensure_timezone_aware(end_dt)
        
        if start_utc is None or end_utc is None:
            return False, "Invalid datetime objects"
            
        if start_utc > end_utc:
            return False, "Start date cannot be after end date"
            
        days_diff = days_between_utc(start_utc, end_utc)
        if days_diff > max_days:
            return False, f"Date range too large: {days_diff} days (max {max_days})"
            
        return True, ""
        
    except Exception as e:
        return False, f"Validation error: {e}"

================================================================================
File: frontend/tailwind.config.js
================================================================================
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    "./index.html",
    "./src/**/*.{vue,js,ts,jsx,tsx}",  // ‚Üê –î–û–ë–ê–í–ò–¢–¨ –≠–¢–û!
  ],
  theme: {
    extend: {
      colors: {
        // –¶–≤–µ—Ç–∞ –¥–ª—è —Ç–æ—Ä–≥–æ–≤–æ–≥–æ —Ç–µ—Ä–º–∏–Ω–∞–ª–∞
        'trading': {
          'bg': '#1a1a1a',
          'card': '#2d2d2d', 
          'border': '#404040',
          'green': '#00d4aa',
          'red': '#ff4747',
          'yellow': '#ffb020'
        }
      }
    },
  },
  plugins: [],
}

================================================================================
File: frontend/vite.config.js
================================================================================
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'

export default defineConfig({
  plugins: [vue()],
  server: {
    port: 5173,
    host: true
  },
  define: {
    __VUE_PROD_DEVTOOLS__: false
  }
})

================================================================================
File: frontend/src/App.vue
================================================================================
<!-- frontend/src/App.vue -->
<template>
  <div id="app" class="app-container">
    <!-- –ì–ª–æ–±–∞–ª—å–Ω–∞—è –Ω–∞–≤–∏–≥–∞—Ü–∏—è -->
    <nav v-if="showNavigation" class="app-navigation">
      <div class="nav-content">
        <router-link to="/" class="nav-brand">
          üìä Trader Tracker
        </router-link>
        
        <div class="nav-links hidden md:flex">
          <router-link to="/" class="nav-link">
            üè† –î–∞—à–±–æ—Ä–¥
          </router-link>
          <router-link to="/signals-chart" class="nav-link">
            üìà –ì—Ä–∞—Ñ–∏–∫ —Å–∏–≥–Ω–∞–ª–æ–≤
          </router-link>
          <router-link to="/traders" class="nav-link">
            üë• –¢—Ä–µ–π–¥–µ—Ä—ã
          </router-link>
        </div>

        <!-- –ú–æ–±–∏–ª—å–Ω–æ–µ –º–µ–Ω—é -->
        <div class="md:hidden">
          <button 
            @click="isMobileMenuOpen = !isMobileMenuOpen"
            class="mobile-menu-btn"
          >
            <svg class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" />
            </svg>
          </button>
        </div>
      </div>

      <!-- –ú–æ–±–∏–ª—å–Ω–æ–µ –º–µ–Ω—é -->
      <div v-if="isMobileMenuOpen" class="mobile-menu md:hidden">
        <div class="mobile-menu-content">
          <router-link 
            to="/" 
            @click="isMobileMenuOpen = false"
            class="mobile-menu-link"
          >
            üè† –î–∞—à–±–æ—Ä–¥
          </router-link>
          
          <router-link 
            to="/signals-chart" 
            @click="isMobileMenuOpen = false"
            class="mobile-menu-link"
          >
            üìà –ì—Ä–∞—Ñ–∏–∫ —Å–∏–≥–Ω–∞–ª–æ–≤
          </router-link>
          
          <router-link 
            to="/traders" 
            @click="isMobileMenuOpen = false"
            class="mobile-menu-link"
          >
            üë• –¢—Ä–µ–π–¥–µ—Ä—ã
          </router-link>
        </div>
      </div>
    </nav>

    <!-- –û—Å–Ω–æ–≤–Ω–æ–π –∫–æ–Ω—Ç–µ–Ω—Ç -->
    <div class="app-main" :class="{ 'with-navigation': showNavigation }">
      <router-view v-slot="{ Component }">
        <transition name="page" mode="out-in">
          <component :is="Component" />
        </transition>
      </router-view>
    </div>

    <!-- –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –º–æ–¥–∞–ª—å–Ω—ã–µ –æ–∫–Ω–∞ –∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è -->
    <div id="modals"></div>
    <div id="notifications"></div>

    <!-- –ì–ª–æ–±–∞–ª—å–Ω—ã–π –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –∑–∞–≥—Ä—É–∑–∫–∏ (–µ—Å–ª–∏ –ø–æ–Ω–∞–¥–æ–±–∏—Ç—Å—è) -->
    <div v-if="isGlobalLoading" class="global-loading">
      <div class="loading-spinner"></div>
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted, watch } from 'vue'
import { useRoute } from 'vue-router'

// –†–µ–∞–∫—Ç–∏–≤–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
const route = useRoute()
const showNavigation = ref(true) // –í–∫–ª—é—á–∞–µ–º –Ω–∞–≤–∏–≥–∞—Ü–∏—é
const isMobileMenuOpen = ref(false)
const isGlobalLoading = ref(false)

// –ó–∞–∫—Ä—ã–≤–∞–µ–º –º–æ–±–∏–ª—å–Ω–æ–µ –º–µ–Ω—é –ø—Ä–∏ —Å–º–µ–Ω–µ —Ä–æ—É—Ç–∞
watch(() => route.path, () => {
  isMobileMenuOpen.value = false
})

// Lifecycle
onMounted(() => {
  console.log('üöÄ Trader Tracker App started')
  
  // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–¥–¥–µ—Ä–∂–∫—É —Å–æ–≤—Ä–µ–º–µ–Ω–Ω—ã—Ö –±—Ä–∞—É–∑–µ—Ä–Ω—ã—Ö API
  checkBrowserSupport()
  
  // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ
  initializeApp()
})

function checkBrowserSupport() {
  const features = {
    'WebSocket': typeof WebSocket !== 'undefined',
    'localStorage': typeof Storage !== 'undefined',
    'ResizeObserver': typeof ResizeObserver !== 'undefined',
    'IntersectionObserver': typeof IntersectionObserver !== 'undefined',
    'Fetch': typeof fetch !== 'undefined'
  }
  
  const unsupported = Object.entries(features)
    .filter(([_, supported]) => !supported)
    .map(([feature]) => feature)
  
  if (unsupported.length > 0) {
    console.warn('‚ö†Ô∏è Unsupported browser features:', unsupported)
    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
    showBrowserWarning(unsupported)
  } else {
    console.log('‚úÖ All browser features supported')
  }
}

function showBrowserWarning(unsupportedFeatures) {
  // –ü—Ä–æ—Å—Ç–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ –Ω–µ—Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
  const message = `–í–∞—à –±—Ä–∞—É–∑–µ—Ä –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏: ${unsupportedFeatures.join(', ')}. –†–µ–∫–æ–º–µ–Ω–¥—É–µ–º –æ–±–Ω–æ–≤–∏—Ç—å –±—Ä–∞—É–∑–µ—Ä.`
  console.warn(message)
  
  // –ú–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –±–æ–ª–µ–µ –∫—Ä–∞—Å–∏–≤–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –ø–æ–∑–∂–µ
  if (unsupportedFeatures.includes('Fetch')) {
    alert('–í–∞—à –±—Ä–∞—É–∑–µ—Ä —É—Å—Ç–∞—Ä–µ–ª. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ–±–Ω–æ–≤–∏—Ç–µ –µ–≥–æ –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–π —Ä–∞–±–æ—Ç—ã –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è.')
  }
}

async function initializeApp() {
  try {
    // –ó–¥–µ—Å—å –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –≥–ª–æ–±–∞–ª—å–Ω—É—é –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—é
    // –ù–∞–ø—Ä–∏–º–µ—Ä, –ø—Ä–æ–≤–µ—Ä–∫–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏, –∑–∞–≥—Ä—É–∑–∫–∞ –Ω–∞—Å—Ç—Ä–æ–µ–∫ –∏ —Ç.–¥.
    
    console.log('‚úÖ App initialized successfully')
  } catch (error) {
    console.error('‚ùå App initialization failed:', error)
  }
}

// –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –º–µ—Ç–æ–¥—ã –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∑–∞–≥—Ä—É–∑–∫–æ–π
function showGlobalLoading() {
  isGlobalLoading.value = true
}

function hideGlobalLoading() {
  isGlobalLoading.value = false
}

// –≠–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ–º –º–µ—Ç–æ–¥—ã –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ –¥—Ä—É–≥–∏—Ö –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞—Ö
defineExpose({
  showGlobalLoading,
  hideGlobalLoading
})
</script>

<style scoped>
.app-container {
  @apply min-h-screen bg-trading-bg text-white;
}

/* === –ù–ê–í–ò–ì–ê–¶–ò–Ø === */
.app-navigation {
  @apply bg-trading-card border-b border-trading-border sticky top-0 z-50;
}

.nav-content {
  @apply max-w-7xl mx-auto px-4 flex items-center justify-between h-16;
}

.nav-brand {
  @apply text-xl font-bold text-white hover:text-trading-green transition-colors;
  @apply no-underline;
}

.nav-links {
  @apply flex items-center space-x-6;
}

.nav-link {
  @apply text-gray-300 hover:text-white transition-colors;
  @apply no-underline font-medium px-3 py-2 rounded;
}

.nav-link:hover {
  @apply bg-trading-bg bg-opacity-50;
}

.nav-link.router-link-active {
  @apply text-trading-green bg-trading-green bg-opacity-10;
}

/* –ú–æ–±–∏–ª—å–Ω–æ–µ –º–µ–Ω—é */
.mobile-menu-btn {
  @apply text-gray-300 hover:text-white focus:outline-none focus:text-white;
  @apply p-2 rounded transition-colors;
}

.mobile-menu-btn:hover {
  @apply bg-trading-bg bg-opacity-50;
}

.mobile-menu {
  @apply border-t border-trading-border bg-trading-card;
}

.mobile-menu-content {
  @apply max-w-7xl mx-auto px-4 py-4 flex flex-col space-y-3;
}

.mobile-menu-link {
  @apply block text-gray-300 hover:text-white transition-colors;
  @apply no-underline font-medium px-3 py-2 rounded;
}

.mobile-menu-link:hover {
  @apply bg-trading-bg bg-opacity-50;
}

.mobile-menu-link.router-link-active {
  @apply text-trading-green bg-trading-green bg-opacity-10;
}

/* === –û–°–ù–û–í–ù–û–ô –ö–û–ù–¢–ï–ù–¢ === */
.app-main {
  @apply flex-1;
}

.app-main.with-navigation {
  /* –ö–æ–Ω—Ç–µ–Ω—Ç —Å –Ω–∞–≤–∏–≥–∞—Ü–∏–µ–π */
  @apply pt-0;
}

/* === –ì–õ–û–ë–ê–õ–¨–ù–ê–Ø –ó–ê–ì–†–£–ó–ö–ê === */
.global-loading {
  @apply fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50;
}

.loading-spinner {
  @apply animate-spin rounded-full h-12 w-12 border-b-2 border-trading-green;
}

/* === –ê–ù–ò–ú–ê–¶–ò–ò === */
.page-enter-active,
.page-leave-active {
  transition: all 0.3s cubic-bezier(0.55, 0, 0.1, 1);
}

.page-enter-from {
  opacity: 0;
  transform: translate(30px, 0);
}

.page-leave-to {
  opacity: 0;
  transform: translate(-30px, 0);
}

/* –ê–Ω–∏–º–∞—Ü–∏—è –ø–æ—è–≤–ª–µ–Ω–∏—è –º–æ–±–∏–ª—å–Ω–æ–≥–æ –º–µ–Ω—é */
.mobile-menu {
  animation: slideDown 0.3s ease-out;
}

@keyframes slideDown {
  from {
    opacity: 0;
    transform: translateY(-10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}
</style>

<style>
/* === –ì–õ–û–ë–ê–õ–¨–ù–´–ï –°–¢–ò–õ–ò === */

/* –ë–∞–∑–æ–≤—ã–µ —Å—Ç–∏–ª–∏ –¥–ª—è —Å—Å—ã–ª–æ–∫ */
a {
  text-decoration: none;
}

/* –£–±–∏—Ä–∞–µ–º —Å–∏–Ω–∏–µ outline'—ã –≤ Firefox */
button::-moz-focus-inner {
  border: 0;
}

/* –ö–∞—Å—Ç–æ–º–Ω—ã–µ —Å–∫—Ä–æ–ª–ª–±–∞—Ä—ã */
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

::-webkit-scrollbar-track {
  background: #1a1a1a;
}

::-webkit-scrollbar-thumb {
  background: #404040;
  border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
  background: #555555;
}

/* –°—Ç–∏–ª–∏ –¥–ª—è —Ñ–æ–∫—É—Å–∞ */
.router-link-active {
  color: #00d4aa !important;
}

/* –°–∫—Ä—ã–≤–∞–µ–º –∞–≤—Ç–æ–∑–∞–ø–æ–ª–Ω–µ–Ω–∏–µ –≤ Chrome */
input:-webkit-autofill,
input:-webkit-autofill:hover,
input:-webkit-autofill:focus,
input:-webkit-autofill:active {
  -webkit-box-shadow: 0 0 0 30px #1a1a1a inset !important;
  -webkit-text-fill-color: white !important;
}

/* –°—Ç–∏–ª–∏ –¥–ª—è –≤—ã–¥–µ–ª–µ–Ω–∏—è —Ç–µ–∫—Å—Ç–∞ */
::selection {
  background-color: #00d4aa;
  color: #000000;
}

::-moz-selection {
  background-color: #00d4aa;
  color: #000000;
}

/* –ë–∞–∑–æ–≤—ã–µ —Å—Ç–∏–ª–∏ –¥–ª—è —Ñ–æ—Ä–º */
input, textarea, select {
  @apply bg-trading-card border border-trading-border text-white;
  @apply focus:outline-none focus:border-trading-green transition-colors;
}

input::placeholder,
textarea::placeholder {
  @apply text-gray-400;
}

/* –ö–Ω–æ–ø–∫–∏ */
.btn-primary {
  @apply bg-trading-green text-black font-medium px-4 py-2 rounded;
  @apply hover:bg-opacity-80 transition-colors;
}

.btn-secondary {
  @apply bg-trading-card border border-trading-border text-white font-medium px-4 py-2 rounded;
  @apply hover:border-gray-500 transition-colors;
}

.btn-danger {
  @apply bg-trading-red text-white font-medium px-4 py-2 rounded;
  @apply hover:bg-opacity-80 transition-colors;
}

/* –£—Ç–∏–ª–∏—Ç—ã –¥–ª—è —Ç–µ–∫—Å—Ç–∞ */
.text-success {
  @apply text-trading-green;
}

.text-danger {
  @apply text-trading-red;
}

.text-warning {
  @apply text-trading-yellow;
}

/* –ê–Ω–∏–º–∞—Ü–∏–∏ –¥–ª—è —ç–ª–µ–º–µ–Ω—Ç–æ–≤ */
.fade-in {
  animation: fadeIn 0.5s ease-in;
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

.slide-up {
  animation: slideUp 0.3s ease-out;
}

@keyframes slideUp {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* –û—Ç–∑—ã–≤—á–∏–≤–æ—Å—Ç—å */
@media (max-width: 768px) {
  .app-main {
    @apply px-2;
  }
}

/* –í—ã—Å–æ–∫–∏–π DPI */
@media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
  /* –£–ª—É—á—à–µ–Ω–Ω–∞—è —á–µ—Ç–∫–æ—Å—Ç—å –¥–ª—è retina –¥–∏—Å–ø–ª–µ–µ–≤ */
  .loading-spinner {
    @apply border-2;
  }
}

/* –ü–µ—á–∞—Ç—å */
@media print {
  .app-navigation,
  .mobile-menu,
  .global-loading {
    display: none !important;
  }
  
  .app-main {
    @apply p-0;
  }
}

/* –¢–µ–º—ã –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π —Å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω—ã–º–∏ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—è–º–∏ */
@media (prefers-reduced-motion: reduce) {
  .page-enter-active,
  .page-leave-active,
  .loading-spinner,
  .fade-in,
  .slide-up {
    animation: none !important;
    transition: none !important;
  }
}

@media (prefers-high-contrast: high) {
  .nav-link,
  .mobile-menu-link {
    @apply border border-transparent;
  }
  
  .nav-link:focus,
  .mobile-menu-link:focus {
    @apply border-white;
  }
}
</style>

================================================================================
File: frontend/src/main.js
================================================================================
import { createApp } from 'vue'
import { createPinia } from 'pinia'
import router from './router'
import App from './App.vue'
import './style.css'

const app = createApp(App)
app.use(createPinia())
app.use(router)
app.mount('#app')

================================================================================
File: frontend/src/stores/tradingStore.js
================================================================================
// frontend/src/stores/tradingStore.js - –û–ë–ù–û–í–õ–ï–ù–ù–ê–Ø –í–ï–†–°–ò–Ø
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
import { tradingAPI } from '../services/api.js'

export const useTradingStore = defineStore('trading', () => {
  // ===== üéØ –û–°–ù–û–í–ù–û–ï –°–û–°–¢–û–Ø–ù–ò–ï =====
  const selectedTicker = ref('SBER')
  const candlesData = ref([])
  const signalsData = ref([])
  const availableTickers = ref([])
  const currentPrice = ref(null)
  
  // ‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö —Ä–∞–º–æ–∫
  const chartDays = ref(30)
  const signalsDays = ref(365)
  const autoLoadEnabled = ref(true) // –í–∫–ª—é—á–∏—Ç—å —É–º–Ω—É—é –∞–≤—Ç–æ-–∑–∞–≥—Ä—É–∑–∫—É
  
  // üìÑ –ó–∞–≥—Ä—É–∑–æ—á–Ω—ã–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è
  const isLoadingCandles = ref(false)
  const isLoadingSignals = ref(false)
  const isLoadingTickers = ref(false)
  const isAutoLoading = ref(false)
  
  // ‚ùå –û—à–∏–±–∫–∏
  const candlesError = ref(null)
  const signalsError = ref(null)
  const tickersError = ref(null)
  
  // üìä –°—Ç–∞—Ç—É—Å –¥–∞–Ω–Ω—ã—Ö
  const dataCoverage = ref(null)
  const lastAutoLoadTime = ref(null)
  
  // ===== üí´ –í–´–ß–ò–°–õ–Ø–ï–ú–´–ï –°–í–û–ô–°–¢–í–ê =====
  
  const formattedCandles = computed(() => {
    return candlesData.value.map(candle => ({
      time: new Date(candle.time).getTime() / 1000,
      open: candle.open,
      high: candle.high,
      low: candle.low,
      close: candle.close,
      volume: candle.volume
    }))
  })
  
  const hasData = computed(() => candlesData.value.length > 0)
  
  const isLoading = computed(() => 
    isLoadingCandles.value || isLoadingSignals.value || isAutoLoading.value
  )
  
  const dataQuality = computed(() => {
    if (!dataCoverage.value) return null
    
    const coverage = dataCoverage.value.coverage
    if (coverage.coverage_percentage >= 90) return 'excellent'
    if (coverage.coverage_percentage >= 70) return 'good'
    if (coverage.coverage_percentage >= 50) return 'fair'
    return 'poor'
  })
  
  // ===== üìã –ú–ï–¢–û–î–´ –ó–ê–ì–†–£–ó–ö–ò –¢–ò–ö–ï–†–û–í =====
  
  async function loadTickers() {
    isLoadingTickers.value = true
    tickersError.value = null
    
    try {
      const response = await tradingAPI.getTickers()
      availableTickers.value = response.sort((a, b) => b.signal_count - a.signal_count)
      console.log('üìä Loaded tickers:', availableTickers.value.length)
    } catch (error) {
      tickersError.value = error.message
      console.error('‚ùå Error loading tickers:', error)
    } finally {
      isLoadingTickers.value = false
    }
  }
  
  // ===== üïØÔ∏è –ú–ï–¢–û–î–´ –ó–ê–ì–†–£–ó–ö–ò –°–í–ï–ß–ï–ô =====
  
  async function loadCandles(ticker = selectedTicker.value, days = chartDays.value, forceLoad = false) {
    isLoadingCandles.value = true
    candlesError.value = null
    
    try {
      console.log(`üìà Loading candles for ${ticker} (${days} days)${forceLoad ? ' [FORCE]' : ''}...`)
      
      let response
      
      if (autoLoadEnabled.value || forceLoad) {
        // –ò—Å–ø–æ–ª—å–∑—É–µ–º —É–º–Ω—É—é –∑–∞–≥—Ä—É–∑–∫—É —Å –∞–≤—Ç–æ-–∑–∞–≥—Ä—É–∑–∫–æ–π –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏
        response = await tradingAPI.getCandlesWithSmartLoad(ticker, days, forceLoad)
      } else {
        // –¢–æ–ª—å–∫–æ —á—Ç–µ–Ω–∏–µ –∏–∑ –ë–î
        response = await tradingAPI.getCandles(ticker, days)
      }
      
      if (response.candles && response.candles.length > 0) {
        candlesData.value = response.candles
        console.log(`‚úÖ Loaded ${response.candles.length} candles for ${ticker}`)
        
        // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–∫—Ä—ã—Ç–∏–µ –¥–∞–Ω–Ω—ã—Ö –ø–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏
        if (autoLoadEnabled.value) {
          await checkDataCoverage(ticker)
        }
      } else {
        candlesData.value = []
        candlesError.value = `No candle data available for ${ticker}.`
      }
      
    } catch (error) {
      console.error('‚ùå Error loading candles:', error)
      candlesError.value = error.message
      candlesData.value = []
    } finally {
      isLoadingCandles.value = false
    }
  }
  
  // ===== üéØ –ú–ï–¢–û–î–´ –ó–ê–ì–†–£–ó–ö–ò –°–ò–ì–ù–ê–õ–û–í =====
  
  async function loadSignals(ticker = selectedTicker.value, days = signalsDays.value) {
    isLoadingSignals.value = true
    signalsError.value = null
    
    try {
      console.log(`üéØ Loading signals for ${ticker} (${days} days)...`)
      
      const response = await tradingAPI.getSignalsByTicker(ticker, days)
      
      if (response.signals) {
        signalsData.value = response.signals
        console.log(`‚úÖ Loaded ${response.signals.length} signals for ${ticker}`)
      } else {
        signalsData.value = []
      }
      
    } catch (error) {
      console.error('‚ùå Error loading signals:', error)
      signalsError.value = error.message
      signalsData.value = []
    } finally {
      isLoadingSignals.value = false
    }
  }
  
  // ===== üí∞ –ó–ê–ì–†–£–ó–ö–ê –¢–ï–ö–£–©–ï–ô –¶–ï–ù–´ =====
  
  async function loadCurrentPrice(ticker = selectedTicker.value) {
    try {
      const priceData = await tradingAPI.getCurrentPrice(ticker)
      if (priceData) {
        currentPrice.value = priceData.price
        console.log(`üí∞ Current price for ${ticker}: ${priceData.price}`)
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è Failed to load current price:', error.message)
    }
  }
  
  // ===== üìä –ü–†–û–í–ï–†–ö–ê –ü–û–ö–†–´–¢–ò–Ø –î–ê–ù–ù–´–• =====
  
  async function checkDataCoverage(ticker = selectedTicker.value) {
    try {
      // ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û: –∏—Å–ø–æ–ª—å–∑—É–µ–º getDataCoverage –≤–º–µ—Å—Ç–æ checkDataCoverage
      const coverage = await tradingAPI.getDataCoverage(ticker, Math.max(chartDays.value, signalsDays.value))
      dataCoverage.value = coverage
      return coverage
    } catch (error) {
      console.warn('‚ö†Ô∏è Failed to check data coverage:', error.message)
      return null
    }
  }
  
  // ===== üîÑ –£–ü–†–ê–í–õ–ï–ù–ò–ï –°–û–°–¢–û–Ø–ù–ò–ï–ú =====
  
  async function setTicker(ticker) {
    const isActuallyChanging = ticker !== selectedTicker.value
    const hasNoData = candlesData.value.length === 0
    
    if (!isActuallyChanging && !hasNoData) return
    
    console.log(`üîÑ ${isActuallyChanging ? 'Switching to' : 'Loading data for'} ticker: ${ticker}`)
    selectedTicker.value = ticker
    
    // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –¥–∞–Ω–Ω—ã–µ
    candlesData.value = []
    signalsData.value = []
    dataCoverage.value = null
    currentPrice.value = null
 
    if (isActuallyChanging) {
      candlesData.value = []
      signalsData.value = []
      dataCoverage.value = null
      currentPrice.value = null
    }

    await Promise.all([
        loadCandles(ticker, chartDays.value),
        loadSignals(ticker, signalsDays.value), 
        loadCurrentPrice(ticker)
      ])
  }
  
  async function setChartDays(days) {
    chartDays.value = days
    await loadCandles(selectedTicker.value, days)
  }
  
  async function setSignalsDays(days) {
    signalsDays.value = days
    await loadSignals(selectedTicker.value, days)
  }
  
  function setAutoLoadEnabled(enabled) {
    autoLoadEnabled.value = enabled
    console.log(`üîß Auto-load ${enabled ? 'enabled' : 'disabled'}`)
    
    if (enabled) {
      checkDataCoverage()
    }
  }
  
  function clearErrors() {
    candlesError.value = null
    signalsError.value = null
    tickersError.value = null
  }
  
  // ===== üõ†Ô∏è –£–¢–ò–õ–ò–¢–´ –î–õ–Ø –£–ü–†–ê–í–õ–ï–ù–ò–Ø –î–ê–ù–ù–´–ú–ò =====
  
  /**
   * –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–∞—è –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∫–∞ –≤—Å–µ—Ö –¥–∞–Ω–Ω—ã—Ö
   */
  async function forceReloadData() {
    console.log('üîÑ Force reloading all data...')
    clearErrors()
    
    await Promise.all([
      loadCandles(selectedTicker.value, chartDays.value, true), // force=true
      loadSignals(selectedTicker.value, signalsDays.value),
      loadCurrentPrice(selectedTicker.value)
    ])
  }
  
  /**
   * –Ø–≤–Ω–∞—è –∑–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —Ç–∏–∫–µ—Ä–∞
   */
  async function manualLoadData(ticker = selectedTicker.value, maxDays = 365) {
    isAutoLoading.value = true
    
    try {
      console.log(`üîÑ Manual smart load for ${ticker}...`)
      
      const result = await tradingAPI.smartLoadData(ticker, maxDays, true)
      console.log('‚úÖ Manual load completed:', result)
      
      // –û–±–Ω–æ–≤–ª—è–µ–º —Å–≤–µ—á–∏ –ø–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏
      await loadCandles(ticker, chartDays.value, false)
      
      lastAutoLoadTime.value = new Date()
      return result
    } catch (error) {
      console.error('‚ùå Manual load failed:', error)
      throw error
    } finally {
      isAutoLoading.value = false
    }
  }
  
  /**
   * –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö —Ä–∞–º–æ–∫ –Ω–∞ –æ—Å–Ω–æ–≤–µ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
   */
  async function optimizeTimeframes() {
    const coverage = await checkDataCoverage()
    if (!coverage) return
    
    const availableDays = coverage.coverage.period_days
    
    // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø–æ–¥—Å—Ç—Ä–∞–∏–≤–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–µ —Ä–∞–º–∫–∏ –ø–æ–¥ –¥–æ—Å—Ç—É–ø–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
    if (chartDays.value > availableDays) {
      console.log(`üìÖ Optimizing chart days from ${chartDays.value} to ${availableDays}`)
      chartDays.value = Math.min(availableDays, 90)
      await loadCandles()
    }
  }
  
  /**
   * –ú–∞—Å—Å–æ–≤–∞—è –∑–∞–≥—Ä—É–∑–∫–∞ –Ω–µ–¥–æ—Å—Ç–∞—é—â–∏—Ö –¥–∞–Ω–Ω—ã—Ö
   */
  async function bulkLoadMissingData() {
    isAutoLoading.value = true
    
    try {
      console.log('üöÄ Starting bulk smart load...')
      const result = await tradingAPI.bulkSmartLoad()
      console.log('‚úÖ Bulk load completed:', result)
      
      // –û–±–Ω–æ–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è —Ç–µ–∫—É—â–µ–≥–æ —Ç–∏–∫–µ—Ä–∞
      await forceReloadData()
      
      lastAutoLoadTime.value = new Date()
      return result
    } catch (error) {
      console.error('‚ùå Bulk load failed:', error)
      throw error
    } finally {
      isAutoLoading.value = false
    }
  }
  
  
async function initialize() {
  console.log('üöÄ Initializing Trading Store...')
  
  try {
    await loadTickers()
    
    const currentTicker = selectedTicker.value || 'SBER'
    console.log('üéØ Initializing with ticker:', currentTicker)
    
    await setTicker(currentTicker)
  } catch (error) {
    console.error('‚åê Initialization error:', error)
  }
}
  
  // ===== üì§ –≠–ö–°–ü–û–†–¢ =====
  
  return {
    // üéØ –û—Å–Ω–æ–≤–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
    selectedTicker,
    candlesData,
    signalsData,
    availableTickers,
    currentPrice,
    chartDays,
    signalsDays,
    autoLoadEnabled,
    dataCoverage,
    lastAutoLoadTime,
    
    // üìÑ –ó–∞–≥—Ä—É–∑–æ—á–Ω—ã–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è
    isLoadingCandles,
    isLoadingSignals,
    isLoadingTickers,
    isAutoLoading,
    
    // ‚ùå –û—à–∏–±–∫–∏
    candlesError,
    signalsError,
    tickersError,
    
    // üí´ –í—ã—á–∏—Å–ª—è–µ–º—ã–µ —Å–≤–æ–π—Å—Ç–≤–∞
    formattedCandles,
    hasData,
    isLoading,
    dataQuality,
    
    // üìã –û—Å–Ω–æ–≤–Ω—ã–µ –¥–µ–π—Å—Ç–≤–∏—è
    loadTickers,
    loadCandles,
    loadSignals,
    loadCurrentPrice,
    setTicker,
    setChartDays,
    setSignalsDays,
    setAutoLoadEnabled,
    clearErrors,
    
    // üõ†Ô∏è –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã–º–∏
    checkDataCoverage,
    forceReloadData,
    manualLoadData,
    optimizeTimeframes,
    bulkLoadMissingData,
    
    // üöÄ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
    initialize
  }
})

================================================================================
File: frontend/src/services/api.js
================================================================================
// frontend/src/services/api.js - –ü–û–õ–ù–û–°–¢–¨–Æ –û–ë–ù–û–í–õ–ï–ù–ù–ê–Ø –í–ï–†–°–ò–Ø
import axios from 'axios'

// –ë–∞–∑–æ–≤–∞—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è API
const API_BASE_URL = import.meta.env.VITE_API_URL || 'http://localhost:8000'

const api = axios.create({
  baseURL: API_BASE_URL,
  timeout: 30000,
  headers: {
    'Content-Type': 'application/json',
  }
})

// –ò–Ω—Ç–µ—Ä—Ü–µ–ø—Ç–æ—Ä –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—à–∏–±–æ–∫
api.interceptors.response.use(
  (response) => response,
  (error) => {
    console.error('API Error:', {
      url: error.config?.url,
      method: error.config?.method,
      status: error.response?.status,
      data: error.response?.data
    })
    return Promise.reject(error)
  }
)

export const tradingAPI = {
  // ===== üìä –°–í–ï–ß–ò –ò –†–´–ù–û–ß–ù–´–ï –î–ê–ù–ù–´–ï =====
  
  /**
   * –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–≤–µ—á–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö - –¢–û–õ–¨–ö–û –ß–¢–ï–ù–ò–ï, –±–µ–∑ –∞–≤—Ç–æ-–∑–∞–≥—Ä—É–∑–∫–∏
   * @param {string} ticker - –¢–∏–∫–µ—Ä –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞
   * @param {number} days - –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–Ω–µ–π
   */
  async getCandles(ticker, days = 30) {
    try {
      const response = await api.get(`/api/candles/${ticker}`, {
        params: { days } // ‚úÖ –£–±—Ä–∞–ª–∏ limit
      })
      return response.data
    } catch (error) {
      if (error.response?.status === 404) {
        throw new Error(`No candle data available for ${ticker}. Use smart load to load historical data first.`)
      }
      throw new Error(`Failed to get candles for ${ticker}: ${error.response?.data?.detail || error.message}`)
    }
  },

  /**
   * –ü–æ–ª—É—á–µ–Ω–∏–µ —Ç–µ–∫—É—â–µ–π —Ü–µ–Ω—ã –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞
   * @param {string} ticker - –¢–∏–∫–µ—Ä –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞
   */
  async getCurrentPrice(ticker) {
    try {
      const response = await api.get(`/api/market/${ticker}/price`)
      return response.data
    } catch (error) {
      // –ù–µ –∫—Ä–∏—Ç–∏—á–Ω–∞—è –æ—à–∏–±–∫–∞ - –º–æ–∂–µ–º —Ä–∞–±–æ—Ç–∞—Ç—å –±–µ–∑ —Ç–µ–∫—É—â–µ–π —Ü–µ–Ω—ã
      console.warn(`Failed to get current price for ${ticker}:`, error.message)
      return null
    }
  },

  // ===== üéØ –°–ò–ì–ù–ê–õ–´ =====
  
  /**
   * –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–∏–≥–Ω–∞–ª–æ–≤ –ø–æ —Ç–∏–∫–µ—Ä—É
   * @param {string} ticker - –¢–∏–∫–µ—Ä –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞
   * @param {number} days - –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–Ω–µ–π
   * @param {number} limit - –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–∏–≥–Ω–∞–ª–æ–≤
   */
  async getSignalsByTicker(ticker, days = 365, limit = 100) {
    try {
      const response = await api.get(`/api/signals/ticker/${ticker}`, {
        params: { days, limit }
      })
      return response.data
    } catch (error) {
      throw new Error(`Failed to get signals for ${ticker}: ${error.response?.data?.detail || error.message}`)
    }
  },

  async getTraders() {
    try {
      const response = await api.get('/api/traders');
      return response.data;  // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –º–∞—Å—Å–∏–≤ —Ç—Ä–µ–π–¥–µ—Ä–æ–≤
    } catch (error) {
      console.error('Error fetching traders:', error);
      throw error;  // –ß—Ç–æ–±—ã –æ—à–∏–±–∫–∞ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–ª–∞—Å—å –≤ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–µ
    }
  },

  async getTraderStats(traderId) {
    try {
      const response = await api.get(`/api/traders/${traderId}`);
      return response.data;  // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –æ–±—ä–µ–∫—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
    } catch (error) {
      console.error(`Error fetching trader stats for ${traderId}:`, error);
      throw error;
    }
  },

  getTraderSignals: async (traderId, params = {}) => {
    try {
      const ticker = params.ticker || null;
      const limit = params.limit || 100;
      const queryParams = {};
      if (ticker) queryParams.ticker = ticker;
      if (limit) queryParams.limit = limit;

      const response = await api.get(`/api/traders/${traderId}/signals`, { params: queryParams });
      return response.data;  // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –º–∞—Å—Å–∏–≤ —Å–∏–≥–Ω–∞–ª–æ–≤
    } catch (error) {
      console.error(`Error fetching signals for trader ${traderId}:`, error);
      throw error;
    }
  },

  /**
   * –ü–æ–ª—É—á–µ–Ω–∏–µ –≤—Å–µ—Ö —Å–∏–≥–Ω–∞–ª–æ–≤ —Å —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–µ–π
   * @param {number} days - –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–Ω–µ–π
   * @param {number} limit - –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–∏–≥–Ω–∞–ª–æ–≤
   * @param {string} ticker - –§–∏–ª—å—Ç—Ä –ø–æ —Ç–∏–∫–µ—Ä—É (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
   */
  async getAllSignals(days = 30, limit = 100, ticker = null) {
    try {
      const params = { days, limit }
      if (ticker) params.ticker = ticker
      
      const response = await api.get('/api/signals', { params })
      return response.data
    } catch (error) {
      throw new Error(`Failed to get signals: ${error.response?.data?.detail || error.message}`)
    }
  },

  /**
   * –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–∏–≥–Ω–∞–ª–æ–≤ –ø–æ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–º—É —Ç—Ä–µ–π–¥–µ—Ä—É
   * @param {string} trader - –ò–º—è —Ç—Ä–µ–π–¥–µ—Ä–∞
   * @param {number} days - –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–Ω–µ–π
   * @param {number} limit - –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–∏–≥–Ω–∞–ª–æ–≤
   */
  async getSignalsByTrader(trader, days = 30, limit = 100) {
    try {
      const response = await api.get(`/api/signals/trader/${trader}`, {
        params: { days, limit }
      })
      return response.data
    } catch (error) {
      throw new Error(`Failed to get signals for trader ${trader}: ${error.response?.data?.detail || error.message}`)
    }
  },

  // ===== üìà –¢–ò–ö–ï–†–´ –ò –ò–ù–°–¢–†–£–ú–ï–ù–¢–´ =====
  
  /**
   * –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Ç–∏–∫–µ—Ä–æ–≤
   */
  async getTickers() {
    try {
      const response = await api.get('/api/tickers')
      return response.data
    } catch (error) {
      throw new Error(`Failed to get tickers: ${error.response?.data?.detail || error.message}`)
    }
  },

  /**
   * –ü–æ–∏—Å–∫ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤ –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é –∏–ª–∏ —Ç–∏–∫–µ—Ä—É
   * @param {string} query - –ü–æ–∏—Å–∫–æ–≤–æ–π –∑–∞–ø—Ä–æ—Å
   */
  async searchInstruments(query) {
    try {
      const response = await api.get('/api/instruments/search', {
        params: { q: query }
      })
      return response.data
    } catch (error) {
      throw new Error(`Failed to search instruments: ${error.response?.data?.detail || error.message}`)
    }
  },

  // ===== üîÑ –£–ú–ù–ê–Ø –ó–ê–ì–†–£–ó–ö–ê –î–ê–ù–ù–´–• =====
  
  /**
   * –£–º–Ω–∞—è –∑–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ —Ç–∏–∫–µ—Ä–∞
   * @param {string} ticker - –¢–∏–∫–µ—Ä –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞
   * @param {number} days - –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–Ω–µ–π –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏
   * @param {boolean} force - –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–∞—è –∑–∞–≥—Ä—É–∑–∫–∞
   */
  async smartLoadData(ticker, days = 365, force = false) {
    try {
      const params = { days }
      if (force) params.force = true
      
      const response = await api.post(`/api/data/smart-load/${ticker}`, null, { params })
      return response.data
    } catch (error) {
      throw new Error(`Failed to smart load data for ${ticker}: ${error.response?.data?.detail || error.message}`)
    }
  },

  /**
   * –ú–∞—Å—Å–æ–≤–∞—è —É–º–Ω–∞—è –∑–∞–≥—Ä—É–∑–∫–∞ –¥–ª—è –≤—Å–µ—Ö —Ç–∏–∫–µ—Ä–æ–≤ —Å —Å–∏–≥–Ω–∞–ª–∞–º–∏
   */
  async bulkSmartLoad() {
    try {
      const response = await api.post('/api/data/bulk-smart-load')
      return response.data
    } catch (error) {
      throw new Error(`Failed to perform bulk smart load: ${error.response?.data?.detail || error.message}`)
    }
  },

  /**
   * –£–º–Ω—ã–π –º–µ—Ç–æ–¥ –ø–æ–ª—É—á–µ–Ω–∏—è —Å–≤–µ—á–µ–π —Å –∞–≤—Ç–æ–∑–∞–≥—Ä—É–∑–∫–æ–π –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏
   * @param {string} ticker - –¢–∏–∫–µ—Ä –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞
   * @param {number} days - –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–Ω–µ–π
   * @param {boolean} forceLoad - –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–∞—è –∑–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö
   */
  async getCandlesWithSmartLoad(ticker, days = 30, forceLoad = false) {
    try {
      // –ï—Å–ª–∏ –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–∞—è –∑–∞–≥—Ä—É–∑–∫–∞ - —Å–Ω–∞—á–∞–ª–∞ –∑–∞–≥—Ä—É–∂–∞–µ–º –¥–∞–Ω–Ω—ã–µ
      if (forceLoad) {
        console.log(`üîÑ Force loading data for ${ticker}...`)
        await this.smartLoadData(ticker, Math.max(days, 365), true)
      }

      // –ü—ã—Ç–∞–µ–º—Å—è –ø–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –∏–∑ –ë–î
      try {
        return await this.getCandles(ticker, days)
      } catch (error) {
        // –ï—Å–ª–∏ –¥–∞–Ω–Ω—ã—Ö –Ω–µ—Ç –∏ –Ω–µ –±—ã–ª–æ –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–π –∑–∞–≥—Ä—É–∑–∫–∏ - –ø—ã—Ç–∞–µ–º—Å—è –∑–∞–≥—Ä—É–∑–∏—Ç—å
        if (error.message.includes('No candle data available') && !forceLoad) {
          console.log(`üî• No data found for ${ticker}, attempting smart load...`)
          
          await this.smartLoadData(ticker, Math.max(days, 365), true)
          
          // –ü–æ–≤—Ç–æ—Ä—è–µ–º –∑–∞–ø—Ä–æ—Å –ø–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏
          return await this.getCandles(ticker, days)
        }
        
        throw error
      }
    } catch (error) {
      throw new Error(`Failed to get candles with smart load for ${ticker}: ${error.message}`)
    }
  },

  // ===== üìä –ü–û–ö–†–´–¢–ò–ï –î–ê–ù–ù–´–• =====
  
  /**
   * –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–∫—Ä—ã—Ç–∏—è –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —Ç–∏–∫–µ—Ä–∞
   * @param {string} ticker - –¢–∏–∫–µ—Ä –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞
   * @param {number} days - –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–Ω–µ–π –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏
   */
  async getDataCoverage(ticker, days = 30) {
    try {
      const response = await api.get(`/api/data/coverage/${ticker}`, {
        params: { days }
      })
      return response.data
    } catch (error) {
      throw new Error(`Failed to get data coverage for ${ticker}: ${error.response?.data?.detail || error.message}`)
    }
  },

  // ===== üìà –°–¢–ê–¢–ò–°–¢–ò–ö–ê =====
  
  /**
   * –ü–æ–ª—É—á–µ–Ω–∏–µ –æ–±—â–µ–π —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ —Å–∏—Å—Ç–µ–º—ã
   */
  async getStatistics() {
    try {
      const response = await api.get('/api/statistics')
      return response.data
    } catch (error) {
      throw new Error(`Failed to get statistics: ${error.response?.data?.detail || error.message}`)
    }
  },

  // ===== üõ†Ô∏è –£–ü–†–ê–í–õ–ï–ù–ò–ï –î–ê–ù–ù–´–ú–ò =====
  
  /**
   * –ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ —Å–æ–æ–±—â–µ–Ω–∏–π
   */
  async getParsingStatus() {
    try {
      const response = await api.get('/api/messages/parsing-status')
      return response.data
    } catch (error) {
      throw new Error(`Failed to get parsing status: ${error.response?.data?.detail || error.message}`)
    }
  },

  /**
   * –ó–∞–ø—É—Å–∫ –ø–∞—Ä—Å–∏–Ω–≥–∞ —Å–æ–æ–±—â–µ–Ω–∏–π
   * @param {number} limit - –õ–∏–º–∏—Ç —Å–æ–æ–±—â–µ–Ω–∏–π –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏
   */
  async startMessageParsing(limit = null) {
    try {
      const params = limit ? { limit } : {}
      const response = await api.post('/api/messages/parse', null, { params })
      return response.data
    } catch (error) {
      throw new Error(`Failed to start message parsing: ${error.response?.data?.detail || error.message}`)
    }
  }
}

export default tradingAPI

================================================================================
File: frontend/src/views/SignalsChart.vue
================================================================================
<!-- frontend/src/views/SignalsChart.vue - –ù–û–í–ê–Ø –í–ï–†–°–ò–Ø –° –ù–£–õ–Ø -->
<template>
  <div class="min-h-screen bg-trading-bg text-white">
    <div class="max-w-7xl mx-auto p-4">
      
      <!-- –ó–∞–≥–æ–ª–æ–≤–æ–∫ —Å—Ç—Ä–∞–Ω–∏—Ü—ã -->
      <div class="mb-6">
        <h1 class="text-3xl font-bold mb-2">üìà –ì—Ä–∞—Ñ–∏–∫ —Å —Å–∏–≥–Ω–∞–ª–∞–º–∏ —Ç—Ä–µ–π–¥–µ—Ä–æ–≤</h1>
        <p class="text-gray-400">–ê–Ω–∞–ª–∏–∑ —Ç–æ—Ä–≥–æ–≤—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤ –Ω–∞ –≥—Ä–∞—Ñ–∏–∫–µ —Å–≤–µ—á–µ–π</p>
      </div>

      <!-- –ü—Ä–æ—Å—Ç—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è -->
      <div class="bg-trading-card p-4 rounded-lg border border-trading-border mb-6">
        <div class="grid grid-cols-1 md:grid-cols-4 gap-4">
          <!-- –í—ã–±–æ—Ä —Ç–∏–∫–µ—Ä–∞ -->
          <div>
            <label class="block text-sm font-medium text-gray-300 mb-2">–¢–∏–∫–µ—Ä</label>
            <select 
              v-model="selectedTicker" 
              @change="handleTickerChange"
              class="w-full bg-trading-bg border border-trading-border rounded px-3 py-2 text-white"
              :disabled="isLoading"
            >
              <option value="">–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–∫–µ—Ä</option>
              <option 
                v-for="ticker in availableTickers" 
                :key="ticker.ticker"
                :value="ticker.ticker"
              >
                {{ ticker.ticker }} ({{ ticker.signal_count }} —Å–∏–≥–Ω–∞–ª–æ–≤)
              </option>
            </select>
          </div>

          <!-- –ü–µ—Ä–∏–æ–¥ –≥—Ä–∞—Ñ–∏–∫–∞ -->
          <div>
            <label class="block text-sm font-medium text-gray-300 mb-2">–ü–µ—Ä–∏–æ–¥ –≥—Ä–∞—Ñ–∏–∫–∞</label>
            <select 
              v-model="chartDays" 
              @change="handleDaysChange"
              class="w-full bg-trading-bg border border-trading-border rounded px-3 py-2 text-white"
            >
              <option :value="7">7 –¥–Ω–µ–π</option>
              <option :value="14">14 –¥–Ω–µ–π</option>
              <option :value="30">30 –¥–Ω–µ–π</option>
              <option :value="60">60 –¥–Ω–µ–π</option>
              <option :value="90">90 –¥–Ω–µ–π</option>
            </select>
          </div>

          <!-- –ö–Ω–æ–ø–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è -->
          <div class="flex items-end">
            <button 
              @click="handleRefresh"
              :disabled="isLoading"
              class="w-full px-4 py-2 bg-trading-green text-black rounded hover:bg-green-400 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
            >
              {{ isLoading ? '–ó–∞–≥—Ä—É–∑–∫–∞...' : '–û–±–Ω–æ–≤–∏—Ç—å' }}
            </button>
          </div>

          <!-- –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è -->
          <div class="flex items-end">
            <div class="text-sm text-gray-400">
              <div>–°–≤–µ—á–µ–π: {{ candlesData.length }}</div>
              <div>–°–∏–≥–Ω–∞–ª–æ–≤: {{ signalsData.length }}</div>
            </div>
          </div>
        </div>

        <!-- –û—à–∏–±–∫–∏ -->
        <div v-if="anyError" class="mt-4 p-3 bg-red-900/50 border border-red-700 rounded text-red-200">
          <div class="flex items-center justify-between">
            <span>{{ anyError }}</span>
            <button @click="clearErrors" class="text-red-400 hover:text-red-300">‚úï</button>
          </div>
        </div>
      </div>
      
      <!-- –û—Å–Ω–æ–≤–Ω–æ–π –≥—Ä–∞—Ñ–∏–∫ -->
      <div class="bg-trading-card rounded-lg border border-trading-border overflow-hidden">
        <div class="p-4 border-b border-trading-border">
          <h2 class="text-xl font-semibold">
            {{ selectedTicker ? `${selectedTicker} - –ì—Ä–∞—Ñ–∏–∫ —Å —Å–∏–≥–Ω–∞–ª–∞–º–∏` : '–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–∫–µ—Ä –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞' }}
          </h2>
        </div>
        
        <div class="p-4">
          <!-- –†–µ–∞–ª—å–Ω—ã–π –≥—Ä–∞—Ñ–∏–∫ -->
          <TradingChart
            v-if="selectedTicker && candlesData.length > 0"
            :ticker="selectedTicker"
            :candles-data="formattedCandles"
            :signals-data="signalsData"
            :current-price="currentPrice"
            :is-loading="isLoading"
            :error="anyError"
            @retry="handleRefresh"
          />
          
          <!-- –ó–∞–≥—Ä—É–∑–∫–∞ -->
          <div v-else-if="isLoading" class="text-center py-20">
            <div class="animate-spin w-8 h-8 border-2 border-trading-green border-t-transparent rounded-full mx-auto mb-4"></div>
            <div class="text-gray-400">–ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö...</div>
          </div>
          
          <!-- –ù–µ—Ç —Ç–∏–∫–µ—Ä–∞ -->
          <div v-else-if="!selectedTicker" class="text-center py-20 text-gray-400">
            <div class="text-6xl mb-4">üìà</div>
            <div class="text-xl mb-2">–í—ã–±–µ—Ä–∏—Ç–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç</div>
            <div class="text-sm">–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–∫–µ—Ä –∏–∑ —Å–ø–∏—Å–∫–∞ –≤—ã—à–µ –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –≥—Ä–∞—Ñ–∏–∫–∞</div>
          </div>

          <!-- –ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö -->
          <div v-else class="text-center py-20 text-gray-400">
            <div class="text-6xl mb-4">üì≠</div>
            <div class="text-xl mb-2">–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö</div>
            <div class="text-sm">–î–ª—è –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ —Ç–∏–∫–µ—Ä–∞ –Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö –∑–∞ —É–∫–∞–∑–∞–Ω–Ω—ã–π –ø–µ—Ä–∏–æ–¥</div>
          </div>
        </div>
      </div>

      <!-- –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è -->
      <div v-if="selectedTicker && (candlesData.length > 0 || signalsData.length > 0)" class="mt-6 grid grid-cols-1 md:grid-cols-2 gap-6">
        
        <!-- –ü–æ—Å–ª–µ–¥–Ω–∏–µ —Å–∏–≥–Ω–∞–ª—ã -->
        <div class="bg-trading-card rounded-lg border border-trading-border">
          <div class="p-4 border-b border-trading-border">
            <h3 class="text-lg font-semibold">üéØ –ü–æ—Å–ª–µ–¥–Ω–∏–µ —Å–∏–≥–Ω–∞–ª—ã</h3>
          </div>
          <div class="p-4">
            <div v-if="signalsData.length > 0" class="space-y-3 max-h-64 overflow-y-auto">
              <div 
                v-for="signal in signalsData.slice(0, 5)" 
                :key="signal.id"
                class="p-3 bg-trading-bg border border-trading-border rounded"
              >
                <div class="flex justify-between items-center mb-1">
                  <span class="font-semibold text-white">{{ signal.ticker }}</span>
                  <span 
                    class="text-sm font-medium"
                    :class="signal.direction === 'BUY' ? 'text-trading-green' : 'text-trading-red'"
                  >
                    {{ signal.direction === 'BUY' ? 'üü¢ –ü–æ–∫—É–ø–∫–∞' : 'üî¥ –ü—Ä–æ–¥–∞–∂–∞' }}
                  </span>
                </div>
                <div class="flex justify-between items-center text-xs text-gray-400">
                  <span>{{ formatDate(signal.timestamp) }}</span>
                  <span>{{ signal.trader_name || 'Unknown' }}</span>
                </div>
              </div>
            </div>
            <div v-else class="text-center py-8 text-gray-400">
              <div class="text-2xl mb-2">üîç</div>
              <div>–ù–µ—Ç —Å–∏–≥–Ω–∞–ª–æ–≤</div>
            </div>
          </div>
        </div>

        <!-- –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ —Å–∏–≥–Ω–∞–ª–∞–º -->
        <div class="bg-trading-card rounded-lg border border-trading-border">
          <div class="p-4 border-b border-trading-border">
            <h3 class="text-lg font-semibold">üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Å–∏–≥–Ω–∞–ª–æ–≤</h3>
          </div>
          <div class="p-4">
            <div v-if="signalsData.length > 0" class="space-y-3">
              <div class="flex justify-between">
                <span class="text-gray-400">–í—Å–µ–≥–æ —Å–∏–≥–Ω–∞–ª–æ–≤:</span>
                <span class="font-mono">{{ signalsData.length }}</span>
              </div>
              <div class="flex justify-between">
                <span class="text-gray-400">–ü–æ–∫—É–ø–æ–∫:</span>
                <span class="font-mono text-trading-green">{{ buySignalsCount }}</span>
              </div>
              <div class="flex justify-between">
                <span class="text-gray-400">–ü—Ä–æ–¥–∞–∂:</span>
                <span class="font-mono text-trading-red">{{ sellSignalsCount }}</span>
              </div>
              <div class="flex justify-between">
                <span class="text-gray-400">–°–æ–æ—Ç–Ω–æ—à–µ–Ω–∏–µ:</span>
                <span class="font-mono">{{ signalsRatio }}</span>
              </div>
            </div>
            <div v-else class="text-center py-8 text-gray-400">
              <div class="text-2xl mb-2">üìà</div>
              <div>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –±—É–¥–µ—Ç –¥–æ—Å—Ç—É–ø–Ω–∞ –ø–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏ —Å–∏–≥–Ω–∞–ª–æ–≤</div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup>
import { computed, onMounted, watch } from 'vue'
import { useRoute, useRouter } from 'vue-router'
import { useTradingStore } from '../stores/tradingStore.js'
import TradingChart from '../components/charts/TradingChart.vue'

// Router
const route = useRoute()
const router = useRouter()

// Store - –ø–æ–ª—É—á–∞–µ–º –Ω–∞–ø—Ä—è–º—É—é –±–µ–∑ –¥–µ—Å—Ç—Ä—É–∫—Ç—É—Ä–∏–∑–∞—Ü–∏–∏
const store = useTradingStore()

// Computed properties –∏–∑ store (–±–µ–∑–æ–ø–∞—Å–Ω—ã–µ)
const selectedTicker = computed({
  get: () => store.selectedTicker,
  set: (value) => store.selectedTicker = value
})

const chartDays = computed({
  get: () => store.chartDays,
  set: (value) => store.chartDays = value
})

const candlesData = computed(() => store.candlesData || [])
const signalsData = computed(() => store.signalsData || [])
const availableTickers = computed(() => store.availableTickers || [])
const currentPrice = computed(() => store.currentPrice)
const formattedCandles = computed(() => store.formattedCandles || [])

// Loading states
const isLoading = computed(() => store.isLoading)

// Errors
const anyError = computed(() => {
  return store.candlesError || store.signalsError || store.tickersError
})

// Signal statistics
const buySignalsCount = computed(() => 
  signalsData.value.filter(s => s.direction === 'BUY').length
)

const sellSignalsCount = computed(() => 
  signalsData.value.filter(s => s.direction === 'SELL').length
)

const signalsRatio = computed(() => {
  if (buySignalsCount.value === 0 && sellSignalsCount.value === 0) return '0:0'
  return `${buySignalsCount.value}:${sellSignalsCount.value}`
})

// Methods
async function handleTickerChange() {
  if (selectedTicker.value) {
    console.log('üîÑ Changing ticker to:', selectedTicker.value)
    await store.setTicker(selectedTicker.value)
    
    // –û–±–Ω–æ–≤–ª—è–µ–º URL
    if (route.params.ticker !== selectedTicker.value) {
      await router.replace(`/signals-chart/${selectedTicker.value}`)
    }
  }
}

function handleDaysChange() {
  if (selectedTicker.value) {
    console.log('üìÖ Changing days to:', chartDays.value)
    store.setChartDays(chartDays.value)
  }
}

async function handleRefresh() {
  console.log('üîÑ Force refresh')
  await store.forceReloadData()
}

function clearErrors() {
  store.clearErrors()
}

function formatDate(dateString) {
  try {
    const date = new Date(dateString)
    return date.toLocaleDateString('ru-RU', {
      day: '2-digit',
      month: '2-digit',
      hour: '2-digit',
      minute: '2-digit'
    })
  } catch {
    return 'N/A'
  }
}

// Lifecycle
onMounted(async () => {
  console.log('üìà SignalsChart mounted, route params:', route.params)
  
  try {
    // ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û: –°–Ω–∞—á–∞–ª–∞ –æ–ø—Ä–µ–¥–µ–ª—è–µ–º –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π —Ç–∏–∫–µ—Ä –∏–∑ URL
    const routeTicker = route.params.ticker?.toUpperCase()
    
    if (routeTicker) {
      console.log('üéØ Setting ticker from URL:', routeTicker)
      store.selectedTicker = routeTicker
    }
    
    await store.initialize()
    if (routeTicker && routeTicker !== store.selectedTicker) {
      await store.setTicker(routeTicker)
    }
    
  } catch (error) {
    console.error('‚åê Error initializing SignalsChart:', error)
  }
})

// Watchers
watch(() => route.params.ticker, async (newTicker) => {
  if (newTicker && newTicker.toUpperCase() !== selectedTicker.value) {
    selectedTicker.value = newTicker.toUpperCase()
    await handleTickerChange()
  }
})
</script>

<style scoped>
/* –ê–¥–∞–ø—Ç–∏–≤–Ω–æ—Å—Ç—å */
@media (max-width: 1024px) {
  .grid-cols-4 {
    @apply grid-cols-2;
  }
}

@media (max-width: 640px) {
  .grid-cols-4,
  .grid-cols-2 {
    @apply grid-cols-1;
  }
}
</style>

================================================================================
File: frontend/src/views/TraderProfile.vue
================================================================================
<!-- frontend/src/views/TraderProfile.vue - –ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø –í–ï–†–°–ò–Ø -->
<template>
  <div class="min-h-screen bg-trading-bg text-white p-4">
    <!-- –ï—Å–ª–∏ –Ω–µ—Ç ID - –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö —Ç—Ä–µ–π–¥–µ—Ä–æ–≤ -->
    <div v-if="!currentTraderId">
      <div class="mb-6">
        <h1 class="text-2xl font-bold">üë• –í—Å–µ —Ç—Ä–µ–π–¥–µ—Ä—ã</h1>
        <p class="text-gray-400">–í—ã–±–µ—Ä–∏—Ç–µ —Ç—Ä–µ–π–¥–µ—Ä–∞ –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –ø—Ä–æ—Ñ–∏–ª—è</p>
      </div>

      <!-- –ó–∞–≥—Ä—É–∑–∫–∞ —Å–ø–∏—Å–∫–∞ -->
      <div v-if="isLoadingList" class="flex items-center justify-center h-64">
        <div class="text-center">
          <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-trading-green mx-auto mb-4"></div>
          <p>–ó–∞–≥—Ä—É–∑–∫–∞ —Ç—Ä–µ–π–¥–µ—Ä–æ–≤...</p>
        </div>
      </div>

      <!-- –°–ø–∏—Å–æ–∫ —Ç—Ä–µ–π–¥–µ—Ä–æ–≤ -->
      <div v-else class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
        <div 
          v-for="trader in tradersList" 
          :key="trader.id"
          @click="$router.push(`/trader/${trader.id}`)"
          class="bg-trading-card rounded-lg border border-trading-border p-4 cursor-pointer hover:border-trading-green transition-colors"
        >
          <div class="flex items-center justify-between mb-3">
            <h3 class="font-semibold">{{ trader.name }}</h3>
            <div :class="trader.is_active ? 'text-trading-green' : 'text-gray-400'" class="text-sm">
              {{ trader.is_active ? 'üü¢ –ê–∫—Ç–∏–≤–µ–Ω' : '‚ö™ –ù–µ–∞–∫—Ç–∏–≤–µ–Ω' }}
            </div>
          </div>
          
          <div class="space-y-2 text-sm">
            <div class="flex justify-between">
              <span class="text-gray-400">–°–∏–≥–Ω–∞–ª–æ–≤:</span>
              <span>{{ trader.total_signals || 0 }}</span>
            </div>
            <div v-if="trader.win_rate" class="flex justify-between">
              <span class="text-gray-400">Win Rate:</span>
              <span class="text-trading-green">{{ trader.win_rate }}%</span>
            </div>
            <div v-if="trader.avg_profit_pct" class="flex justify-between">
              <span class="text-gray-400">–°—Ä–µ–¥–Ω—è—è –ø—Ä–∏–±—ã–ª—å:</span>
              <span :class="trader.avg_profit_pct > 0 ? 'text-trading-green' : 'text-trading-red'">
                {{ trader.avg_profit_pct > 0 ? '+' : '' }}{{ trader.avg_profit_pct }}%
              </span>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- –ü—Ä–æ—Ñ–∏–ª—å –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ —Ç—Ä–µ–π–¥–µ—Ä–∞ -->
    <div v-else>
      <!-- –û—Ç–ª–∞–¥–æ—á–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è (—É–±–µ—Ä–µ–º –ø–æ—Ç–æ–º) -->
      <div class="mb-4 p-2 bg-gray-800 rounded text-xs text-gray-300">
        DEBUG: traderId={{ currentTraderId }}, loading={{ isLoading }}, hasStats={{ !!traderStats }}
      </div>

      <!-- –ù–∞–≤–∏–≥–∞—Ü–∏—è –Ω–∞–∑–∞–¥ -->
      <div class="mb-6">
        <button 
          @click="$router.back()"
          class="flex items-center gap-2 text-gray-400 hover:text-white transition-colors mb-4"
        >
          ‚Üê –ù–∞–∑–∞–¥
        </button>
        
        <div v-if="traderStats">
          <h1 class="text-2xl font-bold">üë§ {{ traderStats.name }}</h1>
          <div class="flex items-center gap-4 text-gray-400">
            <span v-if="traderStats.telegram_username">@{{ traderStats.telegram_username }}</span>
            <span :class="traderStats.is_active ? 'text-trading-green' : 'text-gray-400'">
              {{ traderStats.is_active ? 'üü¢ –ê–∫—Ç–∏–≤–µ–Ω' : '‚ö™ –ù–µ–∞–∫—Ç–∏–≤–µ–Ω' }}
            </span>
          </div>
        </div>
      </div>

      <!-- –ó–∞–≥—Ä—É–∑–∫–∞ –ø—Ä–æ—Ñ–∏–ª—è -->
      <div v-if="isLoading" class="flex items-center justify-center h-64">
        <div class="text-center">
          <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-trading-green mx-auto mb-4"></div>
          <p>–ó–∞–≥—Ä—É–∑–∫–∞ –ø—Ä–æ—Ñ–∏–ª—è —Ç—Ä–µ–π–¥–µ—Ä–∞ {{ currentTraderId }}...</p>
        </div>
      </div>

      <!-- –û—à–∏–±–∫–∞ -->
      <div v-else-if="error" class="flex items-center justify-center h-64">
        <div class="text-center">
          <div class="text-4xl mb-4">‚ö†Ô∏è</div>
          <h3 class="text-xl font-semibold mb-2 text-trading-red">–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏</h3>
          <p class="text-gray-400 mb-4">{{ error }}</p>
          <button 
            @click="loadTraderData"
            class="px-4 py-2 bg-trading-green text-black rounded hover:bg-opacity-80 transition-colors"
          >
            –ü–æ–≤—Ç–æ—Ä–∏—Ç—å
          </button>
        </div>
      </div>

      <!-- –î–∞–Ω–Ω—ã–µ —Ç—Ä–µ–π–¥–µ—Ä–∞ -->
      <div v-else-if="traderStats" class="space-y-6">
        <!-- –û—Å–Ω–æ–≤–Ω–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ -->
        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
          <div class="bg-trading-card rounded-lg p-4 border border-trading-border">
            <div class="text-sm text-gray-400">–í—Å–µ–≥–æ —Å–∏–≥–Ω–∞–ª–æ–≤</div>
            <div class="text-2xl font-bold">{{ traderStats.total_signals || 0 }}</div>
          </div>
          <div class="bg-trading-card rounded-lg p-4 border border-trading-border">
            <div class="text-sm text-gray-400">–ó–∞–∫—Ä—ã—Ç—ã—Ö —Å–¥–µ–ª–æ–∫</div>
            <div class="text-2xl font-bold">{{ traderStats.closed_results || 0 }}</div>
          </div>
          <div v-if="traderStats.win_rate" class="bg-trading-card rounded-lg p-4 border border-trading-border">
            <div class="text-sm text-gray-400">Win Rate</div>
            <div class="text-2xl font-bold text-trading-green">{{ traderStats.win_rate }}%</div>
          </div>
          <div v-if="traderStats.avg_profit_pct" class="bg-trading-card rounded-lg p-4 border border-trading-border">
            <div class="text-sm text-gray-400">–°—Ä–µ–¥–Ω—è—è –ø—Ä–∏–±—ã–ª—å</div>
            <div 
              :class="traderStats.avg_profit_pct > 0 ? 'text-trading-green' : 'text-trading-red'"
              class="text-2xl font-bold"
            >
              {{ traderStats.avg_profit_pct > 0 ? '+' : '' }}{{ traderStats.avg_profit_pct }}%
            </div>
          </div>
        </div>

        <!-- –í—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ -->
        <div v-if="traderStats.first_signal_at || traderStats.last_signal_at" class="bg-trading-card rounded-lg p-4 border border-trading-border">
          <h3 class="text-lg font-semibold mb-4">üìÖ –í—Ä–µ–º–µ–Ω–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è</h3>
          <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div v-if="traderStats.first_signal_at">
              <div class="text-sm text-gray-400">–ü–µ—Ä–≤—ã–π —Å–∏–≥–Ω–∞–ª</div>
              <div class="font-semibold">{{ formatDate(traderStats.first_signal_at) }}</div>
            </div>
            <div v-if="traderStats.last_signal_at">
              <div class="text-sm text-gray-400">–ü–æ—Å–ª–µ–¥–Ω–∏–π —Å–∏–≥–Ω–∞–ª</div>
              <div class="font-semibold">{{ formatDate(traderStats.last_signal_at) }}</div>
            </div>
          </div>
        </div>

        <!-- –¢–∏–∫–µ—Ä—ã -->
        <div class="bg-trading-card rounded-lg p-4 border border-trading-border">
          <h3 class="text-lg font-semibold mb-4">üìä –ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã</h3>
          <div v-if="traderTickers.length === 0" class="text-gray-400">
            –ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –æ–± –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞—Ö
          </div>
          <div v-else class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-2">
            <div 
              v-for="ticker in traderTickers" 
              :key="ticker.ticker"
              @click="$router.push(`/signals-chart/${ticker.ticker}`)"
              class="bg-trading-bg p-3 rounded border border-trading-border hover:border-trading-green cursor-pointer transition-colors"
            >
              <div class="font-semibold">{{ ticker.ticker }}</div>
              <div class="text-sm text-gray-400">{{ ticker.count }} —Å–∏–≥–Ω–∞–ª–æ–≤</div>
            </div>
          </div>
        </div>

        <!-- –ü–æ—Å–ª–µ–¥–Ω–∏–µ —Å–∏–≥–Ω–∞–ª—ã -->
        <div class="bg-trading-card rounded-lg p-4 border border-trading-border">
          <div class="flex items-center justify-between mb-4">
            <h3 class="text-lg font-semibold">üéØ –ü–æ—Å–ª–µ–¥–Ω–∏–µ —Å–∏–≥–Ω–∞–ª—ã</h3>
            <button 
              @click="loadMoreSignals"
              class="text-trading-green hover:text-opacity-80 transition-colors text-sm"
            >
              –ü–æ–∫–∞–∑–∞—Ç—å –±–æ–ª—å—à–µ
            </button>
          </div>
          
          <div v-if="traderSignals.length === 0" class="text-gray-400">
            –ù–µ—Ç —Å–∏–≥–Ω–∞–ª–æ–≤ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
          </div>
          <div v-else class="space-y-3">
            <!-- –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–æ–≤—ã–π –∫–æ–º–ø–æ–Ω–µ–Ω—Ç SignalCard -->
            <SignalCard 
              v-for="signal in traderSignals.slice(0, 10)" 
              :key="signal.id"
              :signal="signal"
              @click="onSignalClick"
            />
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, computed, onMounted, watch } from 'vue'
import { useRoute } from 'vue-router'
import tradingAPI from '../services/api.js'
import SignalCard from '../components/SignalCard.vue'

// –î–∞–Ω–Ω—ã–µ
const route = useRoute()

// –ò—Å–ø–æ–ª—å–∑—É–µ–º –æ–±—ã—á–Ω—É—é ref –≤–º–µ—Å—Ç–æ computed –¥–ª—è –ª—É—á—à–µ–≥–æ –∫–æ–Ω—Ç—Ä–æ–ª—è
const currentTraderId = ref(route.params.id)

const isLoading = ref(false)
const isLoadingList = ref(false)
const error = ref(null)

const traderStats = ref(null)
const traderSignals = ref([])
const tradersList = ref([])
const traderTickers = ref([])

// –û—Ç—Å–ª–µ–∂–∏–≤–∞–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏—è –≤ —Ä–æ—É—Ç–µ
watch(() => route.params.id, (newId) => {
  console.log('üîÑ Route changed to:', newId)
  currentTraderId.value = newId
  
  if (newId) {
    // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â–∏–µ –¥–∞–Ω–Ω—ã–µ
    traderStats.value = null
    traderSignals.value = []
    traderTickers.value = []
    error.value = null
    
    // –ó–∞–≥—Ä—É–∂–∞–µ–º –Ω–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ
    loadTraderData()
  } else {
    loadTradersList()
  }
}, { immediate: false })

// –ú–µ—Ç–æ–¥—ã
function formatDate(dateString) {
  return new Date(dateString).toLocaleDateString('ru-RU')
}

async function loadTradersList() {
  console.log('üìã Loading traders list...')
  isLoadingList.value = true
  try {
    const response = await tradingAPI.getTraders()
    tradersList.value = response
    console.log('‚úÖ Loaded traders:', response.length)
  } catch (err) {
    console.error('‚ùå Error loading traders list:', err)
  } finally {
    isLoadingList.value = false
  }
}

async function loadTraderData() {
  if (!currentTraderId.value) {
    console.log('‚ö†Ô∏è No trader ID provided')
    return
  }
  
  console.log('üìä Loading trader data for ID:', currentTraderId.value)
  isLoading.value = true
  error.value = null
  
  try {
    // –ó–∞–≥—Ä—É–∂–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É —Ç—Ä–µ–π–¥–µ—Ä–∞
    console.log('üìà Fetching trader stats...')
    const stats = await tradingAPI.getTraderStats(currentTraderId.value)
    console.log('üìä Raw trader stats response:', stats)
    traderStats.value = stats
    console.log('‚úÖ Trader stats loaded:', stats)
    
    // –ó–∞–≥—Ä—É–∂–∞–µ–º —Å–∏–≥–Ω–∞–ª—ã —Ç—Ä–µ–π–¥–µ—Ä–∞
    console.log('üéØ Fetching trader signals...')
    const signalsResponse = await tradingAPI.getTraderSignals(currentTraderId.value, {
      ticker: null,  // –Ø–≤–Ω–æ –ø–µ—Ä–µ–¥–∞—ë–º null, –µ—Å–ª–∏ –Ω–µ—Ç —Ñ–∏–ª—å—Ç—Ä–∞ –ø–æ —Ç–∏–∫–µ—Ä—É
      limit: 50      // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –¥–æ 50 —Å–∏–≥–Ω–∞–ª–æ–≤
    })
    console.log('üìä Raw signals response:', signalsResponse)
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç—Ä—É–∫—Ç—É—Ä—É –æ—Ç–≤–µ—Ç–∞
    let signalsArray = []
    if (Array.isArray(signalsResponse)) {
      signalsArray = signalsResponse
    } else if (signalsResponse && Array.isArray(signalsResponse.signals)) {
      signalsArray = signalsResponse.signals
    } else if (signalsResponse && signalsResponse.data && Array.isArray(signalsResponse.data)) {
      signalsArray = signalsResponse.data
    } else {
      console.warn('‚ö†Ô∏è Unexpected signals response structure:', signalsResponse)
    }
    
    traderSignals.value = signalsArray
    console.log('‚úÖ Trader signals processed:', traderSignals.value.length, traderSignals.value)
    
    // –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –ø–æ —Ç–∏–∫–µ—Ä–∞–º
    const tickerCounts = {}
    traderSignals.value.forEach(signal => {
      if (signal && signal.ticker) {
        if (!tickerCounts[signal.ticker]) {
          tickerCounts[signal.ticker] = 0
        }
        tickerCounts[signal.ticker]++
      }
    })
    
    traderTickers.value = Object.entries(tickerCounts)
      .map(([ticker, count]) => ({ ticker, count }))
      .sort((a, b) => b.count - a.count)
    
    console.log('‚úÖ Trader tickers processed:', traderTickers.value)
      
  } catch (err) {
    console.error('‚ùå Error loading trader data:', err)
    console.error('‚ùå Error details:', err.response?.data || err)
    error.value = err.message
  } finally {
    isLoading.value = false
  }
}

async function loadMoreSignals() {
  try {
    console.log('üìà Loading more signals...')
    const signalsResponse = await tradingAPI.getTraderSignals(currentTraderId.value, {
      ticker: null,  // –Ø–≤–Ω–æ –ø–µ—Ä–µ–¥–∞—ë–º null
      limit: 100     // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –ª–∏–º–∏—Ç –¥–ª—è "–ü–æ–∫–∞–∑–∞—Ç—å –±–æ–ª—å—à–µ"
    })
    let signalsArray = []
    if (Array.isArray(signalsResponse)) {
      signalsArray = signalsResponse
    } else if (signalsResponse && Array.isArray(signalsResponse.signals)) {
      signalsArray = signalsResponse.signals
    } else if (signalsResponse && signalsResponse.data && Array.isArray(signalsResponse.data)) {
      signalsArray = signalsResponse.data
    } else {
      console.warn('‚ö†Ô∏è Unexpected signals response structure:', signalsResponse)
    }
    
    // –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–µ —Å–∏–≥–Ω–∞–ª—ã –∫ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–º
    traderSignals.value = [...traderSignals.value, ...signalsArray]
    console.log('‚úÖ More signals loaded:', traderSignals.value.length)
  } catch (err) {
    console.error('‚ùå Error loading more signals:', err)
    error.value = `–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤: ${err.message}`
  }
}

function onSignalClick(signal) {
  console.log('üéØ Signal clicked:', signal)
  // –ú–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –ª–æ–≥–∏–∫—É –¥–ª—è –æ—Ç–∫—Ä—ã—Ç–∏—è –¥–µ—Ç–∞–ª—å–Ω–æ–≥–æ –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ —Å–∏–≥–Ω–∞–ª–∞
}

// Lifecycle
onMounted(async () => {
  console.log('üöÄ TraderProfile mounted, route params:', route.params)
  
  if (currentTraderId.value) {
    await loadTraderData()
  } else {
    await loadTradersList()
  }
})
</script>

================================================================================
File: frontend/src/views/TradingDashboard.vue
================================================================================
<!-- frontend/src/views/TradingDashboard.vue - –û–ë–ù–û–í–õ–ï–ù–ù–ê–Ø –í–ï–†–°–ò–Ø -->
<template>
  <div class="min-h-screen bg-trading-bg text-white">
    <div class="max-w-7xl mx-auto p-4">
      
      <!-- –ó–∞–≥–æ–ª–æ–≤–æ–∫ -->
      <div class="mb-8">
        <h1 class="text-3xl font-bold mb-2">üìä –¢–æ—Ä–≥–æ–≤—ã–π –¢–µ—Ä–º–∏–Ω–∞–ª</h1>
        <p class="text-gray-400">–ê–Ω–∞–ª–∏–∑ —Ç–æ—Ä–≥–æ–≤—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤ –∏ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤</p>
      </div>

      <!-- –ë—ã—Å—Ç—Ä—ã–µ —Å—Å—ã–ª–∫–∏ -->
      <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-8">
        <!-- –ì—Ä–∞—Ñ–∏–∫ —Å —Å–∏–≥–Ω–∞–ª–∞–º–∏ -->
        <router-link 
          to="/signals-chart"
          class="bg-trading-card rounded-lg border border-trading-border p-6 hover:border-trading-green transition-colors cursor-pointer group"
        >
          <div class="text-4xl mb-4 group-hover:scale-110 transition-transform">üìà</div>
          <h3 class="text-xl font-semibold mb-2">–ì—Ä–∞—Ñ–∏–∫ —Å —Å–∏–≥–Ω–∞–ª–∞–º–∏</h3>
          <p class="text-gray-400">–ü—Ä–æ—Å–º–∞—Ç—Ä–∏–≤–∞–π—Ç–µ —Ç–æ—Ä–≥–æ–≤—ã–µ —Å–∏–≥–Ω–∞–ª—ã –Ω–∞ –≥—Ä–∞—Ñ–∏–∫–µ —Å–≤–µ—á–µ–π</p>
        </router-link>

        <!-- –¢—Ä–µ–π–¥–µ—Ä—ã -->
        <router-link 
          to="/traders"
          class="bg-trading-card rounded-lg border border-trading-border p-6 hover:border-trading-green transition-colors cursor-pointer group"
        >
          <div class="text-4xl mb-4 group-hover:scale-110 transition-transform">üë•</div>
          <h3 class="text-xl font-semibold mb-2">–¢—Ä–µ–π–¥–µ—Ä—ã</h3>
          <p class="text-gray-400">–ê–Ω–∞–ª–∏–∑–∏—Ä—É–π—Ç–µ –ø—Ä–æ—Ñ–∏–ª–∏ –∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É —Ç—Ä–µ–π–¥–µ—Ä–æ–≤</p>
        </router-link>

        <!-- –ê–Ω–∞–ª–∏—Ç–∏–∫–∞ -->
        <div class="bg-trading-card rounded-lg border border-trading-border p-6 opacity-60">
          <div class="text-4xl mb-4">üìä</div>
          <h3 class="text-xl font-semibold mb-2">–ê–Ω–∞–ª–∏—Ç–∏–∫–∞</h3>
          <p class="text-gray-400">–°–∫–æ—Ä–æ: —É–≥–ª—É–±–ª–µ–Ω–Ω–∞—è –∞–Ω–∞–ª–∏—Ç–∏–∫–∞ –∏ –æ—Ç—á–µ—Ç—ã</p>
        </div>
      </div>

      <!-- –û—Å–Ω–æ–≤–Ω–æ–π –∫–æ–Ω—Ç–µ–Ω—Ç –¥–∞—à–±–æ—Ä–¥–∞ -->
      <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
        
        <!-- –õ–µ–≤–∞—è –∫–æ–ª–æ–Ω–∫–∞: –í—ã–±–æ—Ä —Ç–∏–∫–µ—Ä–∞ –∏ –∫–æ–Ω—Ç—Ä–æ–ª—ã -->
        <div class="lg:col-span-1 space-y-6">
          
          <!-- –í—ã–±–æ—Ä —Ç–∏–∫–µ—Ä–∞ -->
          <div class="bg-trading-card rounded-lg border border-trading-border p-4">
            <h3 class="text-lg font-semibold mb-4">üéØ –í—ã–±–æ—Ä –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞</h3>
            
            <div v-if="isLoadingTickers" class="text-center py-4">
              <div class="animate-spin rounded-full h-6 w-6 border-b-2 border-trading-green mx-auto mb-2"></div>
              <p class="text-sm text-gray-400">–ó–∞–≥—Ä—É–∑–∫–∞...</p>
            </div>
            
            <div v-else-if="tickersError" class="text-center py-4">
              <p class="text-trading-red text-sm">{{ tickersError }}</p>
              <button 
                @click="loadTickers" 
                class="mt-2 px-3 py-1 bg-trading-green text-black rounded text-sm hover:bg-opacity-80"
              >
                –ü–æ–≤—Ç–æ—Ä–∏—Ç—å
              </button>
            </div>
            
            <div v-else class="space-y-2">
              <div 
                v-for="ticker in availableTickers.slice(0, 10)" 
                :key="ticker.ticker"
                @click="setTicker(ticker.ticker)"
                :class="selectedTicker === ticker.ticker ? 'border-trading-green bg-trading-green bg-opacity-10' : 'border-trading-border hover:border-gray-500'"
                class="border rounded p-3 cursor-pointer transition-colors"
              >
                <div class="flex items-center justify-between">
                  <span class="font-medium">{{ ticker.ticker }}</span>
                  <span class="text-sm text-gray-400">{{ ticker.signal_count }} —Å–∏–≥–Ω–∞–ª–æ–≤</span>
                </div>
              </div>
              
              <router-link 
                to="/signals-chart"
                class="block w-full mt-4 px-4 py-2 bg-trading-green text-black rounded text-center hover:bg-opacity-80 transition-colors"
              >
                –û—Ç–∫—Ä—ã—Ç—å –≥—Ä–∞—Ñ–∏–∫ —Å —Å–∏–≥–Ω–∞–ª–∞–º–∏
              </router-link>
            </div>
          </div>

          <!-- –ö–æ–Ω—Ç—Ä–æ–ª—ã –ø–µ—Ä–∏–æ–¥–∞ -->
          <div class="bg-trading-card rounded-lg border border-trading-border p-4">
            <h3 class="text-lg font-semibold mb-4">‚è±Ô∏è –ü–µ—Ä–∏–æ–¥</h3>
            <div class="grid grid-cols-3 gap-2">
              <button 
                v-for="days in [7, 14, 30]" 
                :key="days"
                @click="setChartDays(days)"
                :class="chartDays === days ? 'bg-trading-green text-black' : 'bg-trading-bg border border-trading-border hover:border-gray-500'"
                class="px-3 py-2 rounded text-sm transition-colors"
              >
                {{ days }}–¥
              </button>
            </div>
          </div>

          <!-- –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ —Å–∏–≥–Ω–∞–ª–∞–º -->
          <div v-if="selectedTicker && signalsData.length > 0" class="bg-trading-card rounded-lg border border-trading-border p-4">
            <h3 class="text-lg font-semibold mb-4">üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Å–∏–≥–Ω–∞–ª–æ–≤</h3>
            <div class="space-y-3">
              <div class="flex justify-between">
                <span class="text-gray-400">–í—Å–µ–≥–æ —Å–∏–≥–Ω–∞–ª–æ–≤:</span>
                <span>{{ signalsData.length }}</span>
              </div>
              <div class="flex justify-between">
                <span class="text-gray-400">Long:</span>
                <span class="text-trading-green">{{ signalsData.filter(s => s.direction === 'long').length }}</span>
              </div>
              <div class="flex justify-between">
                <span class="text-gray-400">Short:</span>
                <span class="text-trading-red">{{ signalsData.filter(s => s.direction === 'short').length }}</span>
              </div>
              <div class="flex justify-between">
                <span class="text-gray-400">–¢—Ä–µ–π–¥–µ—Ä–æ–≤:</span>
                <span>{{ [...new Set(signalsData.map(s => s.author))].length }}</span>
              </div>
            </div>
          </div>
        </div>

        <!-- –ü—Ä–∞–≤–∞—è –∫–æ–ª–æ–Ω–∫–∞: –ì—Ä–∞—Ñ–∏–∫ -->
        <div class="lg:col-span-2">
          <div class="bg-trading-card rounded-lg border border-trading-border p-4">
            <div class="flex items-center justify-between mb-4">
              <h3 class="text-lg font-semibold">
                üìà {{ selectedTicker || '–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–∫–µ—Ä' }}
              </h3>
              <div v-if="currentPrice" class="text-right">
                <div class="text-sm text-gray-400">–¢–µ–∫—É—â–∞—è —Ü–µ–Ω–∞</div>
                <div class="text-lg font-semibold text-trading-green">{{ currentPrice }}</div>
              </div>
            </div>

            <!-- –°–æ—Å—Ç–æ—è–Ω–∏—è –≥—Ä–∞—Ñ–∏–∫–∞ -->
            <div class="h-96">
              <!-- –ù–µ –≤—ã–±—Ä–∞–Ω —Ç–∏–∫–µ—Ä -->
              <div v-if="!selectedTicker" class="flex items-center justify-center h-full">
                <div class="text-center">
                  <div class="text-6xl mb-4">üìä</div>
                  <h4 class="text-xl font-semibold mb-2">–í—ã–±–µ—Ä–∏—Ç–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç</h4>
                  <p class="text-gray-400">–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–∫–µ—Ä –∏–∑ —Å–ø–∏—Å–∫–∞ —Å–ª–µ–≤–∞ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –≥—Ä–∞—Ñ–∏–∫–∞</p>
                </div>
              </div>

              <!-- –ó–∞–≥—Ä—É–∑–∫–∞ -->
              <div v-else-if="isLoading" class="flex items-center justify-center h-full">
                <div class="text-center">
                  <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-trading-green mx-auto mb-4"></div>
                  <p>–ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö...</p>
                </div>
              </div>

              <!-- –û—à–∏–±–∫–∞ -->
              <div v-else-if="candlesError" class="flex items-center justify-center h-full">
                <div class="text-center">
                  <div class="text-4xl mb-4">‚ö†Ô∏è</div>
                  <h4 class="text-xl font-semibold mb-2 text-trading-red">–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏</h4>
                  <p class="text-gray-400 mb-4">{{ candlesError }}</p>
                  <button 
                    @click="loadCandles(selectedTicker, chartDays)"
                    class="px-4 py-2 bg-trading-green text-black rounded hover:bg-opacity-80 transition-colors"
                  >
                    –ü–æ–≤—Ç–æ—Ä–∏—Ç—å
                  </button>
                </div>
              </div>

              <!-- –ì—Ä–∞—Ñ–∏–∫ (–∑–¥–µ—Å—å –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞—à —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π –≥—Ä–∞—Ñ–∏–∫) -->
              <div v-else-if="hasData" class="h-full">
                <!-- –ó–∞–≥–ª—É—à–∫–∞ –¥–ª—è –≥—Ä–∞—Ñ–∏–∫–∞ - –∑–¥–µ—Å—å –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞—à LightweightCharts –∫–æ–º–ø–æ–Ω–µ–Ω—Ç -->
                <div class="flex items-center justify-center h-full border-2 border-dashed border-trading-border rounded">
                  <div class="text-center">
                    <div class="text-4xl mb-4">üìà</div>
                    <p class="text-gray-400">–ì—Ä–∞—Ñ–∏–∫ –∑–∞–≥—Ä—É–∂–µ–Ω</p>
                    <p class="text-sm text-gray-500">{{ formattedCandles.length }} —Å–≤–µ—á–µ–π</p>
                    <router-link 
                      :to="`/signals-chart/${selectedTicker}`"
                      class="inline-block mt-4 px-4 py-2 bg-trading-green text-black rounded hover:bg-opacity-80 transition-colors"
                    >
                      –û—Ç–∫—Ä—ã—Ç—å —Å —Å–∏–≥–Ω–∞–ª–∞–º–∏
                    </router-link>
                  </div>
                </div>
              </div>

              <!-- –ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö -->
              <div v-else class="flex items-center justify-center h-full">
                <div class="text-center">
                  <div class="text-4xl mb-4">üì≠</div>
                  <h4 class="text-xl font-semibold mb-2">–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö</h4>
                  <p class="text-gray-400">–î–ª—è –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ —Ç–∏–∫–µ—Ä–∞ –Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö –∑–∞ —É–∫–∞–∑–∞–Ω–Ω—ã–π –ø–µ—Ä–∏–æ–¥</p>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup>
import { onMounted } from 'vue'
import { useTradingStore } from '../stores/tradingStore.js'

// Store
const store = useTradingStore()

// –î–µ—Å—Ç—Ä—É–∫—Ç—É—Ä–∏–∑–∞—Ü–∏—è –∏–∑ store
const {
  selectedTicker,
  candlesData,
  signalsData,
  availableTickers,
  currentPrice,
  chartDays,
  isLoadingCandles,
  isLoadingSignals,
  isLoadingTickers,
  candlesError,
  signalsError,
  tickersError,
  formattedCandles,
  hasData,
  isLoading,
  loadTickers,
  loadCandles,
  loadSignals,
  setTicker,
  setChartDays,
  initialize
} = store

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
onMounted(() => {
  initialize()
})
</script>

<style scoped>
.trading-dashboard {
  @apply min-h-screen bg-trading-bg text-white;
}

.dashboard-header {
  @apply border-b border-trading-border bg-trading-card;
}

.header-content {
  @apply container mx-auto px-4 py-4 flex items-center justify-between;
}

.api-status {
  @apply flex items-center space-x-2 px-3 py-1 rounded-full text-xs;
}

.status-healthy {
  @apply bg-green-900/30 text-green-300;
}

.status-unhealthy {
  @apply bg-red-900/30 text-red-300;
}

.status-unknown {
  @apply bg-yellow-900/30 text-yellow-300;
}

.status-indicator {
  @apply w-2 h-2 rounded-full bg-current animate-pulse;
}

.refresh-all-btn {
  @apply px-4 py-2 bg-trading-green text-black rounded hover:bg-green-400;
  @apply disabled:opacity-50 disabled:cursor-not-allowed;
  @apply transition-colors duration-200;
}

.dashboard-main {
  @apply container mx-auto px-4 py-6;
}

.dashboard-grid {
  @apply grid grid-cols-1 lg:grid-cols-4 gap-6;
}

.controls-panel {
  @apply lg:col-span-4;
}

.chart-panel {
  @apply lg:col-span-3;
}

.info-panels {
  @apply lg:col-span-1 space-y-6;
}

.stats-panel,
.tickers-panel,
.signals-panel {
  @apply bg-trading-card border border-trading-border rounded-lg p-4;
}

.panel-title {
  @apply text-lg font-semibold mb-4 text-gray-200;
}

.stats-grid {
  @apply grid grid-cols-2 gap-4;
}

.stat-item {
  @apply text-center;
}

.stat-label {
  @apply block text-xs text-gray-400 mb-1;
}

.stat-value {
  @apply block text-lg font-semibold text-white;
}

.tickers-list,
.signals-list {
  @apply space-y-2 max-h-64 overflow-y-auto;
}

.ticker-item {
  @apply p-3 bg-trading-bg border border-trading-border rounded cursor-pointer;
  @apply hover:bg-gray-700 transition-colors duration-200;
}

.ticker-active {
  @apply border-trading-green bg-trading-green/10;
}

.ticker-info {
  @apply flex justify-between items-center;
}

.ticker-symbol {
  @apply font-semibold text-white;
}

.ticker-signals {
  @apply text-xs text-gray-400;
}

.signal-item {
  @apply p-3 bg-trading-bg border border-trading-border rounded;
}

.signal-header {
  @apply flex justify-between items-center mb-1;
}

.signal-ticker {
  @apply font-semibold text-white;
}

.signal-direction {
  @apply text-sm font-medium;
}

.signal-details {
  @apply flex justify-between items-center text-xs text-gray-400;
}

.global-notification {
  @apply fixed bottom-4 right-4 max-w-md z-50;
}

.global-notification.error {
  @apply bg-red-900/90 border border-red-700 text-red-100;
}

.notification-content {
  @apply flex items-start space-x-3 p-4 rounded-lg backdrop-blur;
}

.notification-icon {
  @apply w-5 h-5 flex-shrink-0 mt-0.5;
}

.notification-title {
  @apply font-semibold;
}

.notification-message {
  @apply text-sm opacity-90;
}

.notification-close {
  @apply ml-auto flex-shrink-0 text-current hover:text-white;
}

/* –ê–¥–∞–ø—Ç–∏–≤–Ω–æ—Å—Ç—å */
@media (max-width: 1024px) {
  .dashboard-grid {
    @apply grid-cols-1;
  }
  
  .stats-grid {
    @apply grid-cols-4;
  }
}

@media (max-width: 640px) {
  .header-content {
    @apply flex-col space-y-3 items-start;
  }
  
  .stats-grid {
    @apply grid-cols-2;
  }
}
</style>

================================================================================
File: frontend/src/router/index.js
================================================================================
// frontend/src/router/index.js - –û–ë–ù–û–í–õ–ï–ù–ù–ê–Ø –í–ï–†–°–ò–Ø
import { createRouter, createWebHistory } from 'vue-router'
import TradingDashboard from '../views/TradingDashboard.vue'
import SignalsChart from '../views/SignalsChart.vue'
import TraderProfile from '../views/TraderProfile.vue'

const routes = [
  {
    path: '/',
    name: 'Dashboard',
    component: TradingDashboard,
    meta: { title: 'üìä –¢–æ—Ä–≥–æ–≤—ã–π –¢–µ—Ä–º–∏–Ω–∞–ª' }
  },
  {
    path: '/signals-chart/:ticker?',
    name: 'SignalsChart',
    component: SignalsChart,
    meta: { title: 'üìà –ì—Ä–∞—Ñ–∏–∫ —Å —Å–∏–≥–Ω–∞–ª–∞–º–∏' }
  },
  {
    path: '/trader/:id',
    name: 'TraderProfile',
    component: TraderProfile,
    meta: { title: 'üë§ –ü—Ä–æ—Ñ–∏–ª—å —Ç—Ä–µ–π–¥–µ—Ä–∞' }
  },
  {
    path: '/traders',
    name: 'TradersOverview',
    component: TraderProfile, // –ú–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ç–æ—Ç –∂–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç –±–µ–∑ ID –¥–ª—è —Å–ø–∏—Å–∫–∞
    meta: { title: 'üë• –¢—Ä–µ–π–¥–µ—Ä—ã' }
  }
]

const router = createRouter({
  history: createWebHistory(),
  routes
})

router.beforeEach((to) => {
  document.title = to.meta.title || 'Trader Tracker'
})

export default router

================================================================================
File: frontend/src/components/AppNavigation.vue
================================================================================
<!-- frontend/src/components/AppNavigation.vue -->
<template>
  <nav class="bg-trading-card border-b border-trading-border">
    <div class="max-w-7xl mx-auto px-4">
      <div class="flex items-center justify-between h-16">
        <!-- –õ–æ–≥–æ—Ç–∏–ø/–ù–∞–∑–≤–∞–Ω–∏–µ -->
        <div class="flex items-center">
          <router-link to="/" class="flex items-center gap-2 text-xl font-bold text-white hover:text-trading-green transition-colors">
            üìä Trader Tracker
          </router-link>
        </div>

        <!-- –û—Å–Ω–æ–≤–Ω–∞—è –Ω–∞–≤–∏–≥–∞—Ü–∏—è -->
        <div class="hidden md:flex items-center space-x-6">
          <router-link 
            to="/" 
            :class="$route.name === 'Dashboard' ? 'text-trading-green' : 'text-gray-300 hover:text-white'"
            class="transition-colors"
          >
            üè† –î–∞—à–±–æ—Ä–¥
          </router-link>
          
          <router-link 
            to="/signals-chart" 
            :class="$route.name === 'SignalsChart' ? 'text-trading-green' : 'text-gray-300 hover:text-white'"
            class="transition-colors"
          >
            üìà –ì—Ä–∞—Ñ–∏–∫ —Å–∏–≥–Ω–∞–ª–æ–≤
          </router-link>
          
          <router-link 
            to="/traders" 
            :class="$route.name === 'TraderProfile' ? 'text-trading-green' : 'text-gray-300 hover:text-white'"
            class="transition-colors"
          >
            üë• –¢—Ä–µ–π–¥–µ—Ä—ã
          </router-link>
        </div>

        <!-- –ú–æ–±–∏–ª—å–Ω–æ–µ –º–µ–Ω—é -->
        <div class="md:hidden">
          <button 
            @click="isMobileMenuOpen = !isMobileMenuOpen"
            class="text-gray-300 hover:text-white focus:outline-none focus:text-white"
          >
            <svg class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" />
            </svg>
          </button>
        </div>
      </div>

      <!-- –ú–æ–±–∏–ª—å–Ω–æ–µ –º–µ–Ω—é -->
      <div v-if="isMobileMenuOpen" class="md:hidden py-4 border-t border-trading-border">
        <div class="flex flex-col space-y-3">
          <router-link 
            to="/" 
            @click="isMobileMenuOpen = false"
            :class="$route.name === 'Dashboard' ? 'text-trading-green' : 'text-gray-300'"
            class="block hover:text-white transition-colors"
          >
            üè† –î–∞—à–±–æ—Ä–¥
          </router-link>
          
          <router-link 
            to="/signals-chart" 
            @click="isMobileMenuOpen = false"
            :class="$route.name === 'SignalsChart' ? 'text-trading-green' : 'text-gray-300'"
            class="block hover:text-white transition-colors"
          >
            üìà –ì—Ä–∞—Ñ–∏–∫ —Å–∏–≥–Ω–∞–ª–æ–≤
          </router-link>
          
          <router-link 
            to="/traders" 
            @click="isMobileMenuOpen = false"
            :class="$route.name === 'TraderProfile' ? 'text-trading-green' : 'text-gray-300'"
            class="block hover:text-white transition-colors"
          >
            üë• –¢—Ä–µ–π–¥–µ—Ä—ã
          </router-link>
        </div>
      </div>
    </div>
  </nav>
</template>

<script setup>
import { ref } from 'vue'

const isMobileMenuOpen = ref(false)
</script>

================================================================================
File: frontend/src/components/DataManagement.vue
================================================================================
<!-- frontend/src/components/DataManagement.vue -->
<template>
  <div class="data-management bg-trading-card rounded-lg border border-trading-border p-6">
    <h2 class="text-2xl font-bold mb-6">üõ†Ô∏è –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã–º–∏</h2>
    
    <!-- –°—Ç–∞—Ç—É—Å —Å–∏—Å—Ç–µ–º—ã -->
    <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
      <div class="bg-trading-bg rounded-lg p-4 border border-trading-border">
        <h3 class="font-semibold mb-2">üìä –ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã</h3>
        <div class="text-2xl font-bold text-blue-400">{{ systemStats.total_instruments || 0 }}</div>
        <div class="text-sm text-gray-400">
          –° –¥–∞–Ω–Ω—ã–º–∏: {{ systemStats.instruments_with_data || 0 }}
        </div>
      </div>
      
      <div class="bg-trading-bg rounded-lg p-4 border border-trading-border">
        <h3 class="font-semibold mb-2">üïØÔ∏è –°–≤–µ—á–∏</h3>
        <div class="text-2xl font-bold text-green-400">{{ formatNumber(systemStats.total_candles) }}</div>
        <div class="text-sm text-gray-400">–ó–∞ –≤—Å–µ –≤—Ä–µ–º—è</div>
      </div>
      
      <div class="bg-trading-bg rounded-lg p-4 border border-trading-border">
        <h3 class="font-semibold mb-2">üéØ –°–∏–≥–Ω–∞–ª—ã</h3>
        <div class="text-2xl font-bold text-yellow-400">{{ systemStats.total_signals || 0 }}</div>
        <div class="text-sm text-gray-400">
          –ê–∫—Ç–∏–≤–Ω—ã—Ö: {{ systemStats.active_signals || 0 }}
        </div>
      </div>
    </div>
    
    <!-- –ü–∞–Ω–µ–ª—å –¥–µ–π—Å—Ç–≤–∏–π -->
    <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
      <!-- –ë—ã—Å—Ç—Ä—ã–µ –¥–µ–π—Å—Ç–≤–∏—è -->
      <div class="space-y-4">
        <h3 class="text-lg font-semibold">‚ö° –ë—ã—Å—Ç—Ä—ã–µ –¥–µ–π—Å—Ç–≤–∏—è</h3>
        
        <button 
          @click="syncInstruments"
          :disabled="isLoading"
          class="w-full p-3 bg-blue-600 hover:bg-blue-700 disabled:bg-gray-600 rounded-lg text-white font-medium"
        >
          üîÑ –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞—Ç—å –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã
        </button>
        
        <button 
          @click="bulkLoadPopular"
          :disabled="isLoading"
          class="w-full p-3 bg-green-600 hover:bg-green-700 disabled:bg-gray-600 rounded-lg text-white font-medium"
        >
          üöÄ –ó–∞–≥—Ä—É–∑–∏—Ç—å –ø–æ–ø—É–ª—è—Ä–Ω—ã–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã
        </button>
        
        <button 
          @click="bulkSmartLoad"
          :disabled="isLoading"
          class="w-full p-3 bg-purple-600 hover:bg-purple-700 disabled:bg-gray-600 rounded-lg text-white font-medium"
        >
          üß† –£–º–Ω–∞—è –º–∞—Å—Å–æ–≤–∞—è –∑–∞–≥—Ä—É–∑–∫–∞
        </button>
      </div>
      
      <!-- –ò–Ω–¥–∏–≤–∏–¥—É–∞–ª—å–Ω–∞—è –∑–∞–≥—Ä—É–∑–∫–∞ -->
      <div class="space-y-4">
        <h3 class="text-lg font-semibold">üéØ –ò–Ω–¥–∏–≤–∏–¥—É–∞–ª—å–Ω–∞—è –∑–∞–≥—Ä—É–∑–∫–∞</h3>
        
        <div class="flex gap-2">
          <input 
            v-model="manualTicker" 
            type="text" 
            placeholder="–í–≤–µ–¥–∏—Ç–µ —Ç–∏–∫–µ—Ä (SBER)"
            class="flex-1 p-2 rounded bg-trading-bg border border-trading-border text-white"
            @keyup.enter="loadManualTicker"
          >
          <button 
            @click="loadManualTicker"
            :disabled="!manualTicker || isLoading"
            class="px-4 py-2 bg-orange-600 hover:bg-orange-700 disabled:bg-gray-600 rounded text-white"
          >
            –ó–∞–≥—Ä—É–∑–∏—Ç—å
          </button>
        </div>
        
        <div class="grid grid-cols-2 gap-2">
          <select 
            v-model="manualDays" 
            class="p-2 rounded bg-trading-bg border border-trading-border text-white"
          >
            <option value="30">30 –¥–Ω–µ–π</option>
            <option value="60">60 –¥–Ω–µ–π</option>
            <option value="90">90 –¥–Ω–µ–π</option>
            <option value="180">180 –¥–Ω–µ–π</option>
            <option value="365">365 –¥–Ω–µ–π</option>
          </select>
          
          <label class="flex items-center gap-2">
            <input 
              v-model="forceReload" 
              type="checkbox"
              class="rounded"
            >
            <span class="text-sm">–ü–µ—Ä–µ–∑–∞–ø–∏—Å–∞—Ç—å</span>
          </label>
        </div>
      </div>
    </div>
    
    <!-- –ü—Ä–æ–≥—Ä–µ—Å—Å –∑–∞–≥—Ä—É–∑–∫–∏ -->
    <div v-if="isLoading" class="mb-6">
      <div class="bg-trading-bg rounded-lg p-4 border border-trading-border">
        <div class="flex items-center gap-3 mb-3">
          <div class="animate-spin rounded-full h-6 w-6 border-b-2 border-blue-500"></div>
          <span class="font-medium">{{ loadingStatus }}</span>
        </div>
        
        <div v-if="bulkProgress.total > 0" class="space-y-2">
          <div class="flex justify-between text-sm">
            <span>–ü—Ä–æ–≥—Ä–µ—Å—Å: {{ bulkProgress.completed }}/{{ bulkProgress.total }}</span>
            <span>{{ Math.round((bulkProgress.completed / bulkProgress.total) * 100) }}%</span>
          </div>
          <div class="w-full bg-gray-700 rounded-full h-2">
            <div 
              class="bg-blue-600 h-2 rounded-full transition-all duration-300"
              :style="{ width: (bulkProgress.completed / bulkProgress.total) * 100 + '%' }"
            ></div>
          </div>
        </div>
      </div>
    </div>
    
    <!-- –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø–æ—Å–ª–µ–¥–Ω–µ–π –æ–ø–µ—Ä–∞—Ü–∏–∏ -->
    <div v-if="lastResult" class="mb-6">
      <div :class="[
        'rounded-lg p-4 border',
        lastResult.success ? 'bg-green-900 border-green-600' : 'bg-red-900 border-red-600'
      ]">
        <h4 class="font-semibold mb-2">
          {{ lastResult.success ? '‚úÖ' : '‚ùå' }} –†–µ–∑—É–ª—å—Ç–∞—Ç –æ–ø–µ—Ä–∞—Ü–∏–∏
        </h4>
        <div class="text-sm space-y-1">
          <div v-if="lastResult.message">{{ lastResult.message }}</div>
          <div v-if="lastResult.completed">–ó–∞–≤–µ—Ä—à–µ–Ω–æ: {{ lastResult.completed }}</div>
          <div v-if="lastResult.failed">–ù–µ—É–¥–∞—á–Ω–æ: {{ lastResult.failed }}</div>
          <div v-if="lastResult.total_candles">–ó–∞–≥—Ä—É–∂–µ–Ω–æ —Å–≤–µ—á–µ–π: {{ formatNumber(lastResult.total_candles) }}</div>
        </div>
      </div>
    </div>
    
    <!-- –¢–∞–±–ª–∏—Ü–∞ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤ -->
    <div v-if="instrumentsStatus.length > 0">
      <h3 class="text-lg font-semibold mb-4">üìã –°–æ—Å—Ç–æ—è–Ω–∏–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤</h3>
      
      <div class="bg-trading-bg rounded-lg border border-trading-border overflow-hidden">
        <div class="overflow-x-auto max-h-96">
          <table class="w-full">
            <thead class="bg-trading-card sticky top-0">
              <tr>
                <th class="px-4 py-3 text-left">–¢–∏–∫–µ—Ä</th>
                <th class="px-4 py-3 text-left">–ù–∞–∑–≤–∞–Ω–∏–µ</th>
                <th class="px-4 py-3 text-left">–°–≤–µ—á–∏</th>
                <th class="px-4 py-3 text-left">–ü–æ–∫—Ä—ã—Ç–∏–µ</th>
                <th class="px-4 py-3 text-left">–î–µ–π—Å—Ç–≤–∏—è</th>
              </tr>
            </thead>
            <tbody>
              <tr v-for="(instrument, index) in instrumentsStatus" :key="instrument.ticker"
                  :class="index % 2 === 0 ? 'bg-trading-bg' : 'bg-trading-card'">
                <td class="px-4 py-3 font-medium">{{ instrument.ticker }}</td>
                <td class="px-4 py-3 text-sm max-w-xs truncate">{{ instrument.name || 'N/A' }}</td>
                <td class="px-4 py-3 text-sm">{{ formatNumber(instrument.candles_count) }}</td>
                <td class="px-4 py-3">
                  <div class="flex items-center gap-2">
                    <div :class="[
                      'w-3 h-3 rounded-full',
                      instrument.has_data ? 'bg-green-500' : 'bg-red-500'
                    ]"></div>
                    <span class="text-sm">
                      {{ instrument.has_data ? '–ï—Å—Ç—å –¥–∞–Ω–Ω—ã–µ' : '–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö' }}
                    </span>
                  </div>
                </td>
                <td class="px-4 py-3">
                  <button 
                    @click="loadSingleInstrument(instrument.ticker)"
                    :disabled="isLoading"
                    class="px-3 py-1 bg-blue-600 hover:bg-blue-700 disabled:bg-gray-600 rounded text-xs text-white"
                  >
                    –ó–∞–≥—Ä—É–∑–∏—Ç—å
                  </button>
                </td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted } from 'vue'
import tradingAPI from '../services/api.js'

// –†–µ–∞–∫—Ç–∏–≤–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
const isLoading = ref(false)
const loadingStatus = ref('')
const systemStats = ref({})
const instrumentsStatus = ref([])
const lastResult = ref(null)

// –ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Ä—É—á–Ω–æ–π –∑–∞–≥—Ä—É–∑–∫–∏
const manualTicker = ref('')
const manualDays = ref(60)
const forceReload = ref(false)

// –ü—Ä–æ–≥—Ä–µ—Å—Å –º–∞—Å—Å–æ–≤–æ–π –∑–∞–≥—Ä—É–∑–∫–∏
const bulkProgress = ref({
  completed: 0,
  total: 0
})

// –ú–µ—Ç–æ–¥—ã
const loadSystemStats = async () => {
  try {
    const stats = await tradingAPI.getSystemStats()
    systemStats.value = stats
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏:', error)
  }
}

const loadDataStatus = async () => {
  try {
    const status = await tradingAPI.getDataStatus()
    instrumentsStatus.value = status.instruments || []
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Å—Ç–∞—Ç—É—Å–∞ –¥–∞–Ω–Ω—ã—Ö:', error)
  }
}

const syncInstruments = async () => {
  isLoading.value = true
  loadingStatus.value = '–°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤...'
  
  try {
    const result = await tradingAPI.syncInstruments()
    lastResult.value = {
      success: true,
      message: `–°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞–Ω–æ ${result.synced_instruments} –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤`,
      completed: result.synced_instruments
    }
    
    await loadSystemStats()
    await loadDataStatus()
  } catch (error) {
    lastResult.value = {
      success: false,
      message: `–û—à–∏–±–∫–∞ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏: ${error.message}`
    }
  } finally {
    isLoading.value = false
    loadingStatus.value = ''
  }
}

const bulkLoadPopular = async () => {
  isLoading.value = true
  loadingStatus.value = '–ó–∞–≥—Ä—É–∑–∫–∞ –ø–æ–ø—É–ª—è—Ä–Ω—ã—Ö –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤...'
  
  try {
    // –ó–¥–µ—Å—å –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π endpoint bulk_load_popular_instruments
    const result = await tradingAPI.loadHistoricalCandles('SBER', '5min', 90) // –ü—Ä–∏–º–µ—Ä–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è
    
    lastResult.value = {
      success: true,
      message: '–ü–æ–ø—É–ª—è—Ä–Ω—ã–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã –∑–∞–≥—Ä—É–∂–µ–Ω—ã',
      total_candles: result.loaded_candles || 0
    }
    
    await loadSystemStats()
  } catch (error) {
    lastResult.value = {
      success: false,
      message: `–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏: ${error.message}`
    }
  } finally {
    isLoading.value = false
    loadingStatus.value = ''
  }
}

const bulkSmartLoad = async () => {
  isLoading.value = true
  loadingStatus.value = '–£–º–Ω–∞—è –º–∞—Å—Å–æ–≤–∞—è –∑–∞–≥—Ä—É–∑–∫–∞...'
  bulkProgress.value = { completed: 0, total: 0 }
  
  try {
    const result = await tradingAPI.bulkSmartLoad()
    
    bulkProgress.value.total = result.total_tickers || 0
    bulkProgress.value.completed = result.processed?.length || 0
    
    lastResult.value = {
      success: result.processed?.length > 0,
      message: `–û–±—Ä–∞–±–æ—Ç–∞–Ω–æ ${result.processed?.length || 0} –∏–∑ ${result.total_tickers || 0} —Ç–∏–∫–µ—Ä–æ–≤`,
      completed: result.processed?.length || 0,
      failed: result.failed?.length || 0,
      total_candles: result.processed?.reduce((sum, p) => sum + (p.load_result?.loaded_candles || 0), 0) || 0
    }
    
    await loadSystemStats()
    await loadDataStatus()
  } catch (error) {
    lastResult.value = {
      success: false,
      message: `–û—à–∏–±–∫–∞ –º–∞—Å—Å–æ–≤–æ–π –∑–∞–≥—Ä—É–∑–∫–∏: ${error.message}`
    }
  } finally {
    isLoading.value = false
    loadingStatus.value = ''
    bulkProgress.value = { completed: 0, total: 0 }
  }
}

const loadManualTicker = async () => {
  if (!manualTicker.value.trim()) return
  
  isLoading.value = true
  loadingStatus.value = `–ó–∞–≥—Ä—É–∑–∫–∞ ${manualTicker.value}...`
  
  try {
    const result = await tradingAPI.smartLoadData(
      manualTicker.value.toUpperCase(),
      manualDays.value,
      true
    )
    
    lastResult.value = {
      success: result.load_result?.success || false,
      message: `${manualTicker.value}: ${result.load_result?.message || '–ó–∞–≥—Ä—É–∂–µ–Ω–æ'}`,
      total_candles: result.load_result?.loaded_candles || 0
    }
    
    await loadSystemStats()
    await loadDataStatus()
    
    // –û—á–∏—â–∞–µ–º –ø–æ–ª–µ –ø–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–π –∑–∞–≥—Ä—É–∑–∫–∏
    if (result.load_result?.success) {
      manualTicker.value = ''
    }
  } catch (error) {
    lastResult.value = {
      success: false,
      message: `–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ ${manualTicker.value}: ${error.message}`
    }
  } finally {
    isLoading.value = false
    loadingStatus.value = ''
  }
}

const loadSingleInstrument = async (ticker) => {
  isLoading.value = true
  loadingStatus.value = `–ó–∞–≥—Ä—É–∑–∫–∞ ${ticker}...`
  
  try {
    const result = await tradingAPI.smartLoadData(ticker, 60, true)
    
    lastResult.value = {
      success: result.load_result?.success || false,
      message: `${ticker}: –∑–∞–≥—Ä—É–∂–µ–Ω–æ ${result.load_result?.loaded_candles || 0} —Å–≤–µ—á–µ–π`,
      total_candles: result.load_result?.loaded_candles || 0
    }
    
    await loadDataStatus()
  } catch (error) {
    lastResult.value = {
      success: false,
      message: `–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ ${ticker}: ${error.message}`
    }
  } finally {
    isLoading.value = false
    loadingStatus.value = ''
  }
}

// –£—Ç–∏–ª–∏—Ç—ã
const formatNumber = (num) => {
  if (!num) return '0'
  return new Intl.NumberFormat('ru-RU').format(num)
}

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
onMounted(async () => {
  await Promise.all([
    loadSystemStats(),
    loadDataStatus()
  ])
})
</script>

<style scoped>
.data-management {
  max-width: 1200px;
  margin: 0 auto;
}

/* –ê–Ω–∏–º–∞—Ü–∏—è –¥–ª—è –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–≤ */
@keyframes spin {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}

.animate-spin {
  animation: spin 1s linear infinite;
}
</style>

================================================================================
File: frontend/src/components/SignalCard.vue
================================================================================
<!-- frontend/src/components/SignalCard.vue -->
<template>
  <div 
    class="signal-card"
    :class="[
      'bg-trading-bg p-4 rounded-lg border transition-all cursor-pointer',
      directionClass,
      'hover:border-opacity-80 hover:transform hover:scale-[1.02]'
    ]"
    @click="$emit('click', signal)"
  >
    <!-- –ó–∞–≥–æ–ª–æ–≤–æ–∫ —Å —Ç–∏–∫–µ—Ä–æ–º –∏ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ–º -->
    <div class="flex items-center justify-between mb-3">
      <div class="flex items-center gap-3">
        <!-- –ò–∫–æ–Ω–∫–∞ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è -->
        <div 
          class="w-8 h-8 rounded-full flex items-center justify-center text-sm font-bold"
          :class="signal.direction === 'long' ? 'bg-trading-green text-black' : 'bg-trading-red text-white'"
        >
          {{ signal.direction === 'long' ? 'üü¢' : 'üî¥' }}
        </div>
        
        <!-- –¢–∏–∫–µ—Ä -->
        <div>
          <div class="font-bold text-lg">{{ signal.ticker }}</div>
          <div class="text-xs text-gray-400">
            {{ signal.direction === 'long' ? 'LONG' : 'SHORT' }} –ø–æ–∑–∏—Ü–∏—è
          </div>
        </div>
      </div>
      
      <!-- –í—Ä–µ–º—è –∏ —Å—Ç–∞—Ç—É—Å -->
      <div class="text-right">
        <div class="text-sm font-medium">{{ formatTime(signal.timestamp) }}</div>
        <div class="text-xs text-gray-400">{{ formatDate(signal.timestamp) }}</div>
        <div v-if="signal.signal_type" class="text-xs font-medium mt-1" :class="typeClass">
          {{ getTypeLabel(signal.signal_type) }}
        </div>
      </div>
    </div>

    <!-- –¶–µ–Ω—ã -->
    <div class="grid grid-cols-3 gap-3 mb-3">
      <!-- –¶–µ–Ω–∞ –≤—Ö–æ–¥–∞ -->
      <div v-if="signal.target_price" class="text-center">
        <div class="text-xs text-gray-400">–í—Ö–æ–¥</div>
        <div class="font-semibold">{{ formatPrice(signal.target_price) }}</div>
      </div>
      
      <!-- Stop Loss -->
      <div v-if="signal.stop_loss" class="text-center">
        <div class="text-xs text-gray-400">Stop Loss</div>
        <div class="font-semibold text-trading-red">{{ formatPrice(signal.stop_loss) }}</div>
      </div>
      
      <!-- Take Profit -->
      <div v-if="signal.take_profit" class="text-center">
        <div class="text-xs text-gray-400">Take Profit</div>
        <div class="font-semibold text-trading-green">{{ formatPrice(signal.take_profit) }}</div>
      </div>
    </div>

    <!-- –£—Ä–æ–≤–µ–Ω—å —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç–∏ -->
    <div v-if="signal.confidence_score || signal.confidence_level" class="mb-3">
      <div class="flex items-center gap-2">
        <span class="text-xs text-gray-400">–£–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å:</span>
        <div class="flex-1 bg-trading-card rounded-full h-2">
          <div 
            class="h-2 rounded-full transition-all"
            :class="confidenceClass"
            :style="{ width: confidenceWidth }"
          ></div>
        </div>
        <span class="text-xs font-medium">{{ confidenceText }}</span>
      </div>
    </div>

    <!-- –ê–≤—Ç–æ—Ä -->
    <div v-if="signal.author" class="flex items-center justify-between text-sm">
      <div class="flex items-center gap-2">
        <span class="text-gray-400">–¢—Ä–µ–π–¥–µ—Ä:</span>
        <span class="font-medium">{{ signal.author }}</span>
      </div>
      
      <!-- –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è -->
      <div class="flex items-center gap-2 text-xs text-gray-400">
        <span v-if="signal.timeframe">{{ signal.timeframe }}</span>
        <span v-if="signal.views" title="–ü—Ä–æ—Å–º–æ—Ç—Ä—ã">üëÅ {{ signal.views }}</span>
      </div>
    </div>

    <!-- –û—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π —Ç–µ–∫—Å—Ç (—Å–∫—Ä—ã—Ç—ã–π, —Ä–∞—Å–∫—Ä—ã–≤–∞–µ—Ç—Å—è –ø–æ –∫–ª–∏–∫—É) -->
    <div v-if="showFullText && signal.original_text" class="mt-3 pt-3 border-t border-trading-border">
      <div class="text-xs text-gray-400 mb-1">–û—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π —Ç–µ–∫—Å—Ç:</div>
      <div class="text-sm bg-trading-card p-2 rounded text-gray-300 leading-relaxed">
        {{ signal.original_text }}
      </div>
    </div>

    <!-- –ö–Ω–æ–ø–∫–∞ —Ä–∞–∑–≤–µ—Ä–Ω—É—Ç—å -->
    <div v-if="signal.original_text && !showFullText" class="mt-2 text-center">
      <button 
        @click.stop="showFullText = true"
        class="text-xs text-trading-green hover:text-opacity-80 transition-colors"
      >
        –ü–æ–∫–∞–∑–∞—Ç—å –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π —Ç–µ–∫—Å—Ç ‚Üì
      </button>
    </div>
  </div>
</template>

<script setup>
import { ref, computed } from 'vue'

// Props
const props = defineProps({
  signal: {
    type: Object,
    required: true
  }
})

// Events
defineEmits(['click'])

// –°–æ—Å—Ç–æ—è–Ω–∏–µ
const showFullText = ref(false)

// –í—ã—á–∏—Å–ª—è–µ–º—ã–µ —Å–≤–æ–π—Å—Ç–≤–∞
const directionClass = computed(() => {
  return props.signal.direction === 'long' 
    ? 'border-trading-green border-opacity-30' 
    : 'border-trading-red border-opacity-30'
})

const typeClass = computed(() => {
  const type = props.signal.signal_type
  switch (type) {
    case 'entry': return 'text-trading-green'
    case 'exit': return 'text-trading-red'
    case 'update': return 'text-trading-yellow'
    default: return 'text-gray-400'
  }
})

const confidenceClass = computed(() => {
  const confidence = getConfidenceValue()
  if (confidence >= 0.8) return 'bg-trading-green'
  if (confidence >= 0.6) return 'bg-trading-yellow'
  if (confidence >= 0.4) return 'bg-orange-500'
  return 'bg-trading-red'
})

const confidenceWidth = computed(() => {
  const confidence = getConfidenceValue()
  return `${confidence * 100}%`
})

const confidenceText = computed(() => {
  const confidence = getConfidenceValue()
  if (props.signal.confidence_level) {
    return props.signal.confidence_level.toUpperCase()
  }
  return `${Math.round(confidence * 100)}%`
})

// –ú–µ—Ç–æ–¥—ã
function getConfidenceValue() {
  if (props.signal.confidence_score) {
    return parseFloat(props.signal.confidence_score)
  }
  
  const level = props.signal.confidence_level
  switch (level) {
    case 'high': return 0.9
    case 'medium': return 0.7
    case 'low': return 0.4
    default: return 0.5
  }
}

function getTypeLabel(type) {
  switch (type) {
    case 'entry': return '–í–•–û–î'
    case 'exit': return '–í–´–•–û–î'
    case 'update': return '–û–ë–ù–û–í–õ–ï–ù–ò–ï'
    default: return type?.toUpperCase() || '–°–ò–ì–ù–ê–õ'
  }
}

function formatPrice(price) {
  if (!price) return '‚Äî'
  return parseFloat(price).toLocaleString('ru-RU', {
    minimumFractionDigits: 2,
    maximumFractionDigits: 4
  })
}

function formatTime(dateString) {
  return new Date(dateString).toLocaleTimeString('ru-RU', {
    hour: '2-digit',
    minute: '2-digit'
  })
}

function formatDate(dateString) {
  return new Date(dateString).toLocaleDateString('ru-RU', {
    day: '2-digit',
    month: '2-digit'
  })
}
</script>

<style scoped>
.signal-card {
  transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
}

.signal-card:hover {
  box-shadow: 0 4px 12px rgba(0, 212, 170, 0.15);
}
</style>

================================================================================
File: frontend/src/components/charts/ChartControls.vue
================================================================================
<!-- frontend/src/components/charts/ChartControls.vue -->
<template>
  <div class="chart-controls">
    <div class="controls-grid">
      <!-- –í—ã–±–æ—Ä —Ç–∏–∫–µ—Ä–∞ -->
      <div class="control-group">
        <label class="control-label">–¢–∏–∫–µ—Ä</label>
        <div class="ticker-selector">
          <select 
            :value="selectedTicker" 
            @change="handleTickerChange"
            class="ticker-select"
            :disabled="isLoading"
          >
            <option value="" disabled>–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–∫–µ—Ä</option>
            <option 
              v-for="ticker in availableTickers" 
              :key="ticker.ticker"
              :value="ticker.ticker"
            >
              {{ ticker.ticker }} ({{ ticker.signal_count }} —Å–∏–≥–Ω–∞–ª–æ–≤)
            </option>
          </select>
          
          <!-- –ö–Ω–æ–ø–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å–ø–∏—Å–∫–∞ —Ç–∏–∫–µ—Ä–æ–≤ -->
          <button 
            @click="handleRefreshTickers"
            class="refresh-btn"
            :disabled="isLoadingTickers"
            title="–û–±–Ω–æ–≤–∏—Ç—å —Å–ø–∏—Å–æ–∫ —Ç–∏–∫–µ—Ä–æ–≤"
          >
            <div v-if="isLoadingTickers" class="w-4 h-4 border-2 border-gray-400 border-t-transparent rounded-full animate-spin"></div>
            <svg v-else class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
            </svg>
          </button>
        </div>
      </div>

      <!-- –ü–µ—Ä–∏–æ–¥ –¥–∞–Ω–Ω—ã—Ö -->
      <div class="control-group">
        <label class="control-label">–ü–µ—Ä–∏–æ–¥</label>
        <select 
          :value="chartDays" 
          @change="handleDaysChange"
          class="period-select"
          :disabled="isLoading"
        >
          <option :value="1">1 –¥–µ–Ω—å</option>
          <option :value="3">3 –¥–Ω—è</option>
          <option :value="7">7 –¥–Ω–µ–π</option>
          <option :value="14">14 –¥–Ω–µ–π</option>
          <option :value="30">30 –¥–Ω–µ–π</option>
          <option :value="90">90 –¥–Ω–µ–π</option>
        </select>
      </div>

      <!-- –ê–≤—Ç–æ–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ -->
      <div class="control-group">
        <label class="control-label">–ê–≤—Ç–æ–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ</label>
        <div class="auto-refresh-toggle">
          <button 
            @click="toggleAutoRefresh"
            class="toggle-btn"
            :class="{ 'toggle-active': autoRefresh }"
            :disabled="isLoading"
          >
            <span class="toggle-indicator"></span>
            <span class="text-sm">{{ autoRefresh ? '–í–∫–ª' : '–í—ã–∫–ª' }}</span>
          </button>
          
          <select 
            v-if="autoRefresh"
            v-model="autoRefreshInterval"
            class="interval-select"
            :disabled="isLoading"
          >
            <option :value="10">10 —Å–µ–∫</option>
            <option :value="30">30 —Å–µ–∫</option>
            <option :value="60">1 –º–∏–Ω</option>
            <option :value="300">5 –º–∏–Ω</option>
          </select>
        </div>
      </div>

      <!-- –î–µ–π—Å—Ç–≤–∏—è -->
      <div class="control-group actions-group">
        <button 
          @click="handleRefresh"
          class="action-btn refresh"
          :disabled="isLoading"
          title="–û–±–Ω–æ–≤–∏—Ç—å –¥–∞–Ω–Ω—ã–µ"
        >
          <div v-if="isLoading" class="w-4 h-4 border-2 border-white border-t-transparent rounded-full animate-spin"></div>
          <svg v-else class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
          </svg>
          <span class="hidden sm:inline">–û–±–Ω–æ–≤–∏—Ç—å</span>
        </button>

        <button 
          @click="handleResetView"
          class="action-btn secondary"
          :disabled="isLoading || !hasData"
          title="–°–±—Ä–æ—Å–∏—Ç—å –º–∞—Å—à—Ç–∞–±"
        >
          <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
          </svg>
          <span class="hidden sm:inline">–°–±—Ä–æ—Å</span>
        </button>
      </div>
    </div>

    <!-- –°—Ç–∞—Ç—É—Å –∏ –æ—à–∏–±–∫–∏ -->
    <div v-if="error" class="error-message">
      <div class="flex items-center space-x-2">
        <svg class="w-4 h-4 text-red-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
        </svg>
        <span class="text-sm">{{ error }}</span>
        <button @click="clearError" class="text-red-400 hover:text-red-300">
          <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
          </svg>
        </button>
      </div>
    </div>

    <!-- –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø–æ—Å–ª–µ–¥–Ω–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ -->
    <div v-if="lastUpdate && !error" class="status-info">
      <div class="flex items-center justify-between text-xs text-gray-400">
        <div class="flex items-center space-x-2">
          <div class="w-2 h-2 bg-green-400 rounded-full animate-pulse"></div>
          <span>–ü–æ—Å–ª–µ–¥–Ω–µ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ: {{ formatLastUpdate }}</span>
        </div>
        <div v-if="autoRefresh" class="flex items-center space-x-1">
          <span>–°–ª–µ–¥—É—é—â–µ–µ —á–µ—Ä–µ–∑: {{ nextUpdateIn }}—Å</span>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, computed, onMounted, onBeforeUnmount } from 'vue'

// Props
const props = defineProps({
  selectedTicker: {
    type: String,
    required: true
  },
  availableTickers: {
    type: Array,
    default: () => []
  },
  chartDays: {
    type: Number,
    default: 7
  },
  isLoading: {
    type: Boolean,
    default: false
  },
  isLoadingTickers: {
    type: Boolean,
    default: false
  },
  hasData: {
    type: Boolean,
    default: false
  },
  error: {
    type: String,
    default: null
  },
  lastUpdate: {
    type: Date,
    default: null
  }
})

// Events
const emit = defineEmits([
  'ticker-change',
  'days-change',
  'refresh',
  'refresh-tickers',
  'reset-view',
  'clear-error'
])

// State
const autoRefresh = ref(false)
const autoRefreshInterval = ref(60) // —Å–µ–∫—É–Ω–¥—ã
const countdown = ref(0)

let refreshTimer = null
let countdownTimer = null

// Computed
const formatLastUpdate = computed(() => {
  if (!props.lastUpdate) return '‚Äî'
  return props.lastUpdate.toLocaleTimeString('ru-RU')
})

const nextUpdateIn = computed(() => countdown.value)

// Methods
function handleTickerChange(event) {
  const newTicker = event.target.value
  if (newTicker && newTicker !== props.selectedTicker) {
    emit('ticker-change', newTicker)
  }
}

function handleDaysChange(event) {
  const newDays = parseInt(event.target.value)
  if (newDays && newDays !== props.chartDays) {
    emit('days-change', newDays)
  }
}

function handleRefresh() {
  emit('refresh')
  resetCountdown()
}

function handleRefreshTickers() {
  emit('refresh-tickers')
}

function handleResetView() {
  emit('reset-view')
}

function clearError() {
  emit('clear-error')
}

function toggleAutoRefresh() {
  autoRefresh.value = !autoRefresh.value
  
  if (autoRefresh.value) {
    startAutoRefresh()
  } else {
    stopAutoRefresh()
  }
}

function startAutoRefresh() {
  stopAutoRefresh() // –û—á–∏—â–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â–∏–µ —Ç–∞–π–º–µ—Ä—ã
  
  resetCountdown()
  
  refreshTimer = setInterval(() => {
    handleRefresh()
  }, autoRefreshInterval.value * 1000)
  
  countdownTimer = setInterval(() => {
    countdown.value--
    if (countdown.value <= 0) {
      resetCountdown()
    }
  }, 1000)
}

function stopAutoRefresh() {
  if (refreshTimer) {
    clearInterval(refreshTimer)
    refreshTimer = null
  }
  
  if (countdownTimer) {
    clearInterval(countdownTimer)
    countdownTimer = null
  }
  
  countdown.value = 0
}

function resetCountdown() {
  countdown.value = autoRefreshInterval.value
}

// Watchers
function watchAutoRefreshInterval() {
  if (autoRefresh.value) {
    startAutoRefresh()
  }
}

// Lifecycle
onMounted(() => {
  // –ê–≤—Ç–æ–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –º–æ–∂–Ω–æ –≤–∫–ª—é—á–∏—Ç—å –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
  // autoRefresh.value = true
  // startAutoRefresh()
})

onBeforeUnmount(() => {
  stopAutoRefresh()
})

// Watch changes in interval
const intervalWatcher = () => {
  watchAutoRefreshInterval()
}
</script>

<style scoped>
.chart-controls {
  @apply bg-trading-card border border-trading-border rounded-lg p-4 space-y-4;
}

.controls-grid {
  @apply grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4;
}

.control-group {
  @apply space-y-2;
}

.actions-group {
  @apply flex flex-col sm:flex-row gap-2;
}

.control-label {
  @apply block text-sm font-medium text-gray-300;
}

.ticker-selector {
  @apply flex space-x-2;
}

.ticker-select,
.period-select,
.interval-select {
  @apply flex-1 bg-trading-bg border border-trading-border rounded px-3 py-2;
  @apply text-white text-sm focus:outline-none focus:ring-2 focus:ring-trading-green focus:border-transparent;
  @apply disabled:opacity-50 disabled:cursor-not-allowed;
}

.ticker-select {
  @apply min-w-0; /* –†–∞–∑—Ä–µ—à–∞–µ–º —Å–∂–∞—Ç–∏–µ */
}

.refresh-btn {
  @apply px-3 py-2 bg-trading-bg border border-trading-border rounded;
  @apply text-gray-300 hover:text-white hover:bg-gray-600;
  @apply disabled:opacity-50 disabled:cursor-not-allowed;
  @apply transition-colors duration-200;
}

.auto-refresh-toggle {
  @apply flex space-x-2;
}

.toggle-btn {
  @apply flex items-center space-x-2 px-3 py-2 rounded border;
  @apply border-trading-border bg-trading-bg text-gray-300;
  @apply hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed;
  @apply transition-all duration-200;
}

.toggle-active {
  @apply border-trading-green bg-trading-green/20 text-trading-green;
}

.toggle-indicator {
  @apply w-2 h-2 rounded-full bg-current;
}

.action-btn {
  @apply flex items-center justify-center space-x-2 px-4 py-2 rounded;
  @apply font-medium text-sm disabled:opacity-50 disabled:cursor-not-allowed;
  @apply transition-all duration-200;
}

.action-btn.refresh {
  @apply bg-trading-green text-black hover:bg-green-400;
}

.action-btn.secondary {
  @apply bg-trading-border text-gray-300 hover:bg-gray-500 hover:text-white;
}

.error-message {
  @apply bg-red-900/50 border border-red-700 rounded p-3 text-red-200;
}

.status-info {
  @apply border-t border-trading-border pt-3;
}

/* –ê–¥–∞–ø—Ç–∏–≤–Ω–æ—Å—Ç—å */
@media (max-width: 640px) {
  .controls-grid {
    @apply grid-cols-1;
  }
  
  .ticker-selector {
    @apply flex-col space-y-2 space-x-0;
  }
  
  .auto-refresh-toggle {
    @apply flex-col space-y-2 space-x-0;
  }
}
</style>

================================================================================
File: frontend/src/components/charts/TradingChart.vue
================================================================================
<!-- frontend/src/components/charts/TradingChart.vue -->
<template>
  <div class="trading-chart-container">
    <!-- –ó–∞–≥–æ–ª–æ–≤–æ–∫ —Å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π -->
    <div class="chart-header">
      <div class="flex items-center justify-between">
        <div class="flex items-center space-x-4">
          <h3 class="text-xl font-bold text-white">
            {{ ticker }}
          </h3>
          <div v-if="currentPrice" class="text-lg font-mono text-trading-green">
            {{ formatPrice(currentPrice) }} ‚ÇΩ
          </div>
          <div v-if="priceChange" class="text-sm" :class="priceChangeColor">
            {{ priceChange > 0 ? '+' : '' }}{{ formatPrice(priceChange) }} ({{ formatPercent(priceChangePercent) }}%)
          </div>
        </div>
        
        <div class="flex items-center space-x-2">
          <!-- –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä –∑–∞–≥—Ä—É–∑–∫–∏ -->
          <div v-if="isLoading" class="flex items-center space-x-2 text-yellow-400">
            <div class="animate-spin w-4 h-4 border-2 border-yellow-400 border-t-transparent rounded-full"></div>
            <span class="text-sm">–ó–∞–≥—Ä—É–∑–∫–∞...</span>
          </div>
          
          <!-- –ü–æ—Å–ª–µ–¥–Ω–µ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ -->
          <div v-if="lastUpdate" class="text-xs text-gray-400">
            –û–±–Ω–æ–≤–ª–µ–Ω–æ: {{ formatTime(lastUpdate) }}
          </div>
        </div>
      </div>
    </div>

    <!-- –û–±–ª–∞—Å—Ç—å –≥—Ä–∞—Ñ–∏–∫–∞ -->
    <div class="chart-wrapper">
      <div 
        ref="chartContainer" 
        class="chart-container"
        :class="{ 'chart-loading': isLoading }"
      ></div>
      
      <!-- –°–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ -->
      <div v-if="error" class="error-overlay">
        <div class="bg-red-900/80 text-red-200 p-4 rounded-lg backdrop-blur">
          <h4 class="font-semibold mb-2">–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –¥–∞–Ω–Ω—ã—Ö</h4>
          <p class="text-sm">{{ error }}</p>
          <button 
            @click="$emit('retry')"
            class="mt-3 px-4 py-2 bg-red-600 hover:bg-red-700 rounded text-sm transition-colors"
          >
            –ü–æ–≤—Ç–æ—Ä–∏—Ç—å –ø–æ–ø—ã—Ç–∫—É
          </button>
        </div>
      </div>
      
      <!-- –°–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–∏ –¥–∞–Ω–Ω—ã—Ö -->
      <div v-if="!isLoading && !error && !hasData" class="no-data-overlay">
        <div class="bg-gray-800/80 text-gray-300 p-6 rounded-lg backdrop-blur text-center">
          <div class="text-4xl mb-4">üìä</div>
          <h4 class="font-semibold mb-2">–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö</h4>
          <p class="text-sm">–î–∞–Ω–Ω—ã–µ –¥–ª—è {{ ticker }} –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç</p>
        </div>
      </div>
    </div>

    <!-- –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –¥–∞–Ω–Ω—ã—Ö -->
    <div v-if="hasData" class="chart-info">
      <div class="flex justify-between text-xs text-gray-400">
        <span>–°–≤–µ—á–µ–π: {{ candlesCount }}</span>
        <span>–ü–µ—Ä–∏–æ–¥: {{ formatPeriod }}</span>
        <span>–ò–Ω—Ç–µ—Ä–≤–∞–ª: 5 –º–∏–Ω</span>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted, onBeforeUnmount, watch, computed, nextTick } from 'vue'
import { createChart } from 'lightweight-charts'

// Props
const props = defineProps({
  ticker: {
    type: String,
    required: true
  },
  candlesData: {
    type: Array,
    default: () => []
  },
  currentPrice: {
    type: Number,
    default: null
  },
  isLoading: {
    type: Boolean,
    default: false
  },
  error: {
    type: String,
    default: null
  }
})

// Events
const emit = defineEmits(['retry'])

// Refs
const chartContainer = ref(null)
let chart = null
let candlestickSeries = null

// Computed
const hasData = computed(() => props.candlesData.length > 0)
const candlesCount = computed(() => props.candlesData.length)

const lastUpdate = computed(() => {
  if (!hasData.value) return null
  const lastCandle = props.candlesData[props.candlesData.length - 1]
  return new Date(lastCandle.time * 1000) // Convert from seconds
})

const priceChange = computed(() => {
  if (!hasData.value || props.candlesData.length < 2) return null
  const current = props.candlesData[props.candlesData.length - 1].close
  const previous = props.candlesData[props.candlesData.length - 2].close
  return current - previous
})

const priceChangePercent = computed(() => {
  if (!priceChange.value || !hasData.value) return null
  const previous = props.candlesData[props.candlesData.length - 2].close
  return (priceChange.value / previous) * 100
})

const priceChangeColor = computed(() => {
  if (!priceChange.value) return 'text-gray-400'
  return priceChange.value > 0 ? 'text-trading-green' : 'text-trading-red'
})

const formatPeriod = computed(() => {
  if (!hasData.value) return ''
  const first = new Date(props.candlesData[0].time * 1000)
  const last = new Date(props.candlesData[props.candlesData.length - 1].time * 1000)
  return `${formatDate(first)} - ${formatDate(last)}`
})

// Chart configuration
const chartOptions = {
  layout: {
    background: { color: '#1a1a1a' },
    textColor: '#d1d5db',
  },
  grid: {
    vertLines: { color: '#374151' },
    horzLines: { color: '#374151' },
  },
  rightPriceScale: {
    borderColor: '#4b5563',
    textColor: '#d1d5db',
  },
  timeScale: {
    borderColor: '#4b5563',
    textColor: '#d1d5db',
    timeVisible: true,
    secondsVisible: false,
  },
  crosshair: {
    mode: 1, // Normal crosshair
    vertLine: {
      color: '#6b7280',
      width: 1,
      style: 2, // Dashed
    },
    horzLine: {
      color: '#6b7280',
      width: 1,
      style: 2, // Dashed
    },
  },
}

const candlestickOptions = {
  upColor: '#00d4aa',
  downColor: '#ff4747',
  borderDownColor: '#ff4747',
  borderUpColor: '#00d4aa',
  wickDownColor: '#ff4747',
  wickUpColor: '#00d4aa',
}

// Methods
function formatPrice(price) {
  if (typeof price !== 'number') return '‚Äî'
  return price.toFixed(2)
}

function formatPercent(percent) {
  if (typeof percent !== 'number') return '‚Äî'
  return percent.toFixed(2)
}

function formatTime(date) {
  return date.toLocaleTimeString('ru-RU', { 
    hour: '2-digit', 
    minute: '2-digit' 
  })
}

function formatDate(date) {
  return date.toLocaleDateString('ru-RU', { 
    day: '2-digit', 
    month: '2-digit' 
  })
}

function initChart() {
  if (!chartContainer.value) return

  // –°–æ–∑–¥–∞–µ–º –≥—Ä–∞—Ñ–∏–∫
  chart = createChart(chartContainer.value, {
    ...chartOptions,
    width: chartContainer.value.clientWidth,
    height: 400,
  })

  // –°–æ–∑–¥–∞–µ–º —Å–µ—Ä–∏—é —Å–≤–µ—á–µ–π
  candlestickSeries = chart.addCandlestickSeries(candlestickOptions)

  // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ä–∞–∑–º–µ—Ä–∞
  const resizeObserver = new ResizeObserver(() => {
    if (chart && chartContainer.value) {
      chart.applyOptions({
        width: chartContainer.value.clientWidth,
      })
    }
  })
  
  resizeObserver.observe(chartContainer.value)
  
  // –°–æ—Ö—Ä–∞–Ω—è–µ–º observer –¥–ª—è cleanup
  chart._resizeObserver = resizeObserver
}

function updateChartData() {
  if (!candlestickSeries || !hasData.value) return

  try {
    // –°–æ—Ä—Ç–∏—Ä—É–µ–º –¥–∞–Ω–Ω—ã–µ –ø–æ –≤—Ä–µ–º–µ–Ω–∏ (–Ω–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π)
    const sortedData = [...props.candlesData].sort((a, b) => a.time - b.time)
    
    // –û–±–Ω–æ–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ
    candlestickSeries.setData(sortedData)
    
    // –ê–≤—Ç–æ–º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ
    chart.timeScale().fitContent()
    
    console.log(`üìà –ì—Ä–∞—Ñ–∏–∫ –æ–±–Ω–æ–≤–ª–µ–Ω: ${sortedData.length} —Å–≤–µ—á–µ–π –¥–ª—è ${props.ticker}`)
  } catch (error) {
    console.error('‚ùå –û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –≥—Ä–∞—Ñ–∏–∫–∞:', error)
  }
}

function destroyChart() {
  if (chart) {
    if (chart._resizeObserver) {
      chart._resizeObserver.disconnect()
    }
    chart.remove()
    chart = null
    candlestickSeries = null
  }
}

// Lifecycle
onMounted(async () => {
  await nextTick()
  initChart()
  if (hasData.value) {
    updateChartData()
  }
})

onBeforeUnmount(() => {
  destroyChart()
})

// Watchers
watch(() => props.candlesData, () => {
  if (chart && candlestickSeries) {
    updateChartData()
  }
}, { deep: true })

watch(() => props.ticker, () => {
  // –ü—Ä–∏ —Å–º–µ–Ω–µ —Ç–∏–∫–µ—Ä–∞ –æ—á–∏—â–∞–µ–º –≥—Ä–∞—Ñ–∏–∫
  if (candlestickSeries) {
    candlestickSeries.setData([])
  }
})
</script>

<style scoped>
.trading-chart-container {
  @apply bg-trading-card border border-trading-border rounded-lg overflow-hidden;
}

.chart-header {
  @apply p-4 border-b border-trading-border bg-gradient-to-r from-trading-card to-trading-bg;
}

.chart-wrapper {
  @apply relative;
}

.chart-container {
  @apply w-full transition-opacity duration-300;
}

.chart-loading {
  @apply opacity-60;
}

.error-overlay,
.no-data-overlay {
  @apply absolute inset-0 flex items-center justify-center;
  @apply bg-black/20 backdrop-blur-sm;
}

.chart-info {
  @apply p-3 bg-trading-bg border-t border-trading-border;
}

/* –ê–Ω–∏–º–∞—Ü–∏—è –∑–∞–≥—Ä—É–∑–∫–∏ */
@keyframes pulse-loading {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

.chart-loading {
  animation: pulse-loading 2s ease-in-out infinite;
}
</style>
